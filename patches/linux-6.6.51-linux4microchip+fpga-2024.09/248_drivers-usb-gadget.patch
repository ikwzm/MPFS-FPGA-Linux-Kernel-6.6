--- linux-6.6.51/drivers/usb/gadget/udc/atmel_usba_udc.c	2024-12-05 13:07:54.638582000 +0900
+++ linux4microchip-fpga-2024.09/drivers/usb/gadget/udc/atmel_usba_udc.c	2024-12-04 16:41:34.985366500 +0900
@@ -1864,6 +1864,8 @@
 
 	pm_stay_awake(&udc->pdev->dev);
 
+	phy_power_on(udc->phy);
+
 	ret = clk_prepare_enable(udc->pclk);
 	if (ret)
 		return ret;
@@ -1885,6 +1887,8 @@
 	clk_disable_unprepare(udc->hclk);
 	clk_disable_unprepare(udc->pclk);
 
+	phy_power_off(udc->phy);
+
 	udc->clocked = false;
 
 	pm_relax(&udc->pdev->dev);
@@ -1950,6 +1954,7 @@
 	vbus = vbus_is_present(udc);
 	if (vbus != udc->vbus_prev) {
 		if (vbus) {
+			phy_set_mode_ext(udc->phy, PHY_MODE_USB_DEVICE, 1);
 			usba_start(udc);
 		} else {
 			udc->suspended = false;
@@ -1957,6 +1962,7 @@
 				udc->driver->disconnect(&udc->gadget);
 
 			usba_stop(udc);
+			phy_set_mode_ext(udc->phy, PHY_MODE_USB_DEVICE, 0);
 		}
 		udc->vbus_prev = vbus;
 	}
@@ -2003,6 +2009,7 @@
 	/* If Vbus is present, enable the controller and wait for reset */
 	udc->vbus_prev = vbus_is_present(udc);
 	if (udc->vbus_prev) {
+		phy_set_mode_ext(udc->phy, PHY_MODE_USB_DEVICE, 1);
 		ret = usba_start(udc);
 		if (ret)
 			goto err;
@@ -2089,6 +2096,25 @@
 	{ .nr_banks = 2, .can_isoc = 1 },		/* ep 15 */
 };
 
+static const struct usba_ep_config ep_config_sama7[] __initconst = {
+	{ .nr_banks = 1 },				/* ep 0 */
+	{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 },	/* ep 1 */
+	{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 },	/* ep 2 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 3 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 4 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 5 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 6 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 7 */
+	{ .nr_banks = 1 },				/* ep 8 */
+	{ .nr_banks = 1 },				/* ep 9 */
+	{ .nr_banks = 1 },				/* ep 10 */
+	{ .nr_banks = 1 },				/* ep 11 */
+	{ .nr_banks = 1 },				/* ep 12 */
+	{ .nr_banks = 1 },				/* ep 13 */
+	{ .nr_banks = 1 },				/* ep 14 */
+	{ .nr_banks = 1 },				/* ep 15 */
+};
+
 static const struct usba_udc_config udc_at91sam9rl_cfg = {
 	.errata = &at91sam9rl_errata,
 	.config = ep_config_sam9,
@@ -2115,11 +2141,18 @@
 	.ep_prealloc = false,
 };
 
+static const struct usba_udc_config udc_sama7g5_cfg = {
+	.num_ep = ARRAY_SIZE(ep_config_sama7),
+	.config = ep_config_sama7,
+	.ep_prealloc = false,
+};
+
 static const struct of_device_id atmel_udc_dt_ids[] = {
 	{ .compatible = "atmel,at91sam9rl-udc", .data = &udc_at91sam9rl_cfg },
 	{ .compatible = "atmel,at91sam9g45-udc", .data = &udc_at91sam9g45_cfg },
 	{ .compatible = "atmel,sama5d3-udc", .data = &udc_sama5d3_cfg },
 	{ .compatible = "microchip,sam9x60-udc", .data = &udc_sam9x60_cfg },
+	{ .compatible = "microchip,sama7g5-udc", .data = &udc_sama7g5_cfg },
 	{ /* sentinel */ }
 };
 
@@ -2161,6 +2194,8 @@
 			return ERR_CAST(udc->pmc);
 	}
 
+	udc->phy = devm_phy_optional_get(&pdev->dev, "usb");
+
 	udc->num_ep = 0;
 
 	udc->vbus_pin = devm_gpiod_get_optional(&pdev->dev, "atmel,vbus",
@@ -2327,6 +2362,9 @@
 
 	udc->usba_ep = atmel_udc_of_init(pdev, udc);
 
+	phy_init(udc->phy);
+	phy_set_mode(udc->phy, PHY_MODE_USB_DEVICE);
+
 	toggle_bias(udc, 0);
 
 	if (IS_ERR(udc->usba_ep))
@@ -2434,8 +2472,10 @@
 	/* If Vbus is present, enable the controller and wait for reset */
 	mutex_lock(&udc->vbus_mutex);
 	udc->vbus_prev = vbus_is_present(udc);
-	if (udc->vbus_prev)
+	if (udc->vbus_prev) {
+		phy_set_mode_ext(udc->phy, PHY_MODE_USB_DEVICE, 1);
 		usba_start(udc);
+	}
 	mutex_unlock(&udc->vbus_mutex);
 
 	return 0;
--- linux-6.6.51/drivers/usb/gadget/udc/atmel_usba_udc.h	2024-12-05 13:07:54.639579300 +0900
+++ linux4microchip-fpga-2024.09/drivers/usb/gadget/udc/atmel_usba_udc.h	2024-12-04 16:41:34.985366500 +0900
@@ -8,6 +8,7 @@
 #define __LINUX_USB_GADGET_USBA_UDC_H__
 
 #include <linux/gpio/consumer.h>
+#include <linux/phy/phy.h>
 
 /* USB register offsets */
 #define USBA_CTRL				0x0000
@@ -357,6 +358,7 @@
 	struct dentry *debugfs_root;
 #endif
 
+	struct phy *phy;
 	struct regmap *pmc;
 };
 
