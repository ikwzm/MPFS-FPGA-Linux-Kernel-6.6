--- linux-6.6.51/Documentation/devicetree/bindings/mmc/cdns,sdhci.yaml	2024-12-05 13:07:31.152904400 +0900
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/mmc/cdns,sdhci.yaml	2024-12-04 16:41:10.385917600 +0900
@@ -15,6 +15,7 @@
       - enum:
           - amd,pensando-elba-sd4hc
           - microchip,mpfs-sd4hc
+          - microchip,pic64gx-sd4hc
           - socionext,uniphier-sd4hc
       - const: cdns,sd4hc
 
@@ -113,6 +114,8 @@
     minimum: 0
     maximum: 0x7f
 
+  dma-noncoherent: true
+
 required:
   - compatible
   - reg
@@ -120,7 +123,7 @@
   - clocks
 
 allOf:
-  - $ref: mmc-controller.yaml
+  - $ref: sdhci-common.yaml#
   - if:
       properties:
         compatible:
--- linux-6.6.51/drivers/mmc/host/atmel-mci.c	2024-12-05 13:07:48.746346400 +0900
+++ linux4microchip-fpga-2024.09/drivers/mmc/host/atmel-mci.c	2024-12-04 16:41:28.918597400 +0900
@@ -37,6 +37,7 @@
 #include <asm/cacheflush.h>
 #include <asm/io.h>
 #include <asm/unaligned.h>
+#include "../core/pwrseq.h"
 
 #define ATMCI_MAX_NR_SLOTS	2
 
@@ -227,6 +228,7 @@
 /**
  * struct mci_platform_data - board-specific MMC/SDcard configuration
  * @dma_slave: DMA slave interface to use in data transfers.
+ * @dma_filter: Filtering function to filter the DMA channel
  * @slot: Per-slot configuration data.
  */
 struct mci_platform_data {
@@ -674,8 +676,10 @@
 					      "cd", GPIOD_IN, "cd-gpios");
 		err = PTR_ERR_OR_ZERO(pdata->slot[slot_id].detect_pin);
 		if (err) {
-			if (err != -ENOENT)
+			if (err != -ENOENT) {
+				of_node_put(cnp);
 				return ERR_PTR(err);
+			}
 			pdata->slot[slot_id].detect_pin = NULL;
 		}
 
@@ -687,8 +691,10 @@
 					      "wp", GPIOD_IN, "wp-gpios");
 		err = PTR_ERR_OR_ZERO(pdata->slot[slot_id].wp_pin);
 		if (err) {
-			if (err != -ENOENT)
+			if (err != -ENOENT) {
+				of_node_put(cnp);
 				return ERR_PTR(err);
+			}
 			pdata->slot[slot_id].wp_pin = NULL;
 		}
 	}
@@ -2335,8 +2341,10 @@
 
 	host->slot[id] = slot;
 	mmc_regulator_get_supply(mmc);
+	mmc_pwrseq_alloc(mmc);
 	ret = mmc_add_host(mmc);
 	if (ret) {
+		mmc_pwrseq_free(mmc);
 		mmc_free_host(mmc);
 		return ret;
 	}
--- linux-6.6.51/drivers/mmc/host/mmc_hsq.c	2024-12-05 13:07:48.760309200 +0900
+++ linux4microchip-fpga-2024.09/drivers/mmc/host/mmc_hsq.c	2024-12-04 16:41:28.932560100 +0900
@@ -21,6 +21,25 @@
 	mmc->ops->request(mmc, hsq->mrq);
 }
 
+static void mmc_hsq_modify_threshold(struct mmc_hsq *hsq)
+{
+	struct mmc_host *mmc = hsq->mmc;
+	struct mmc_request *mrq;
+	unsigned int tag, need_change = 0;
+
+	mmc->hsq_depth = HSQ_NORMAL_DEPTH;
+	for (tag = 0; tag < HSQ_NUM_SLOTS; tag++) {
+		mrq = hsq->slot[tag].mrq;
+		if (mrq && mrq->data &&
+		   (mrq->data->blksz * mrq->data->blocks == 4096) &&
+		   (mrq->data->flags & MMC_DATA_WRITE) &&
+		   (++need_change == 2)) {
+			mmc->hsq_depth = HSQ_PERFORMANCE_DEPTH;
+			break;
+		}
+	}
+}
+
 static void mmc_hsq_pump_requests(struct mmc_hsq *hsq)
 {
 	struct mmc_host *mmc = hsq->mmc;
@@ -42,6 +61,8 @@
 		return;
 	}
 
+	mmc_hsq_modify_threshold(hsq);
+
 	slot = &hsq->slot[hsq->next_tag];
 	hsq->mrq = slot->mrq;
 	hsq->qcnt--;
@@ -337,6 +358,7 @@
 	hsq->mmc = mmc;
 	hsq->mmc->cqe_private = hsq;
 	mmc->cqe_ops = &mmc_hsq_ops;
+	mmc->hsq_depth = HSQ_NORMAL_DEPTH;
 
 	for (i = 0; i < HSQ_NUM_SLOTS; i++)
 		hsq->tag_slot[i] = HSQ_INVALID_TAG;
--- linux-6.6.51/drivers/mmc/host/mmc_hsq.h	2024-12-05 13:07:48.760309200 +0900
+++ linux4microchip-fpga-2024.09/drivers/mmc/host/mmc_hsq.h	2024-12-04 16:41:28.932560100 +0900
@@ -5,6 +5,17 @@
 #define HSQ_NUM_SLOTS	64
 #define HSQ_INVALID_TAG	HSQ_NUM_SLOTS
 
+/*
+ * For MMC host software queue, we only allow 2 requests in
+ * flight to avoid a long latency.
+ */
+#define HSQ_NORMAL_DEPTH	2
+/*
+ * For 4k random writes, we allow hsq_depth to increase to 5
+ * for better performance.
+ */
+#define HSQ_PERFORMANCE_DEPTH	5
+
 struct hsq_slot {
 	struct mmc_request *mrq;
 };
--- linux-6.6.51/drivers/mmc/host/mmc_spi.c	2024-12-05 13:07:48.760309200 +0900
+++ linux4microchip-fpga-2024.09/drivers/mmc/host/mmc_spi.c	2024-12-04 16:41:28.932560100 +0900
@@ -1210,7 +1210,10 @@
 	 * that's the only reason not to use a few MHz for f_min (until
 	 * the upper layer reads the target frequency from the CSD).
 	 */
-	mmc->f_min = 400000;
+	if (spi->controller->min_speed_hz > 400000)
+		dev_warn(&spi->dev,"Controller unable to reduce bus clock to 400 KHz\n");
+
+	mmc->f_min = max(spi->controller->min_speed_hz, 400000);
 	mmc->f_max = spi->max_speed_hz;
 
 	host = mmc_priv(mmc);
--- linux-6.6.51/drivers/mmc/host/sdhci-of-at91.c	2024-12-05 13:07:48.777263500 +0900
+++ linux4microchip-fpga-2024.09/drivers/mmc/host/sdhci-of-at91.c	2024-12-04 16:41:28.949514700 +0900
@@ -25,7 +25,11 @@
 
 #define SDMMC_MC1R	0x204
 #define		SDMMC_MC1R_DDR		BIT(3)
+#define		SDMMC_MC1R_RSTN		BIT(6)
 #define		SDMMC_MC1R_FCD		BIT(7)
+#define SDMMC_MC3R	0x206
+#define		SDMMC_MC3R_HS400EN	BIT(0)
+#define		SDMMC_MC3R_ESMEN	BIT(1)
 #define SDMMC_CACR	0x230
 #define		SDMMC_CACR_CAPWREN	BIT(0)
 #define		SDMMC_CACR_KEY		(0x46 << 8)
@@ -35,10 +39,16 @@
 
 #define SDHCI_AT91_PRESET_COMMON_CONF	0x400 /* drv type B, programmable clock mode */
 
+/* drv type A, programmable clock mode */
+#define SDHCI_AT91_PRESET_DRVA_CONF	(SDHCI_AT91_PRESET_COMMON_CONF \
+					 | 0x4000)
 struct sdhci_at91_soc_data {
 	const struct sdhci_pltfm_data *pdata;
 	bool baseclk_is_generated_internally;
 	unsigned int divider_for_baseclk;
+	unsigned int max_sdr104_clk;
+	bool pm_runtime_disable_clks;
+	u32 quirks2;
 };
 
 struct sdhci_at91_priv {
@@ -100,14 +110,39 @@
 static void sdhci_at91_set_uhs_signaling(struct sdhci_host *host,
 					 unsigned int timing)
 {
-	u8 mc1r;
+	u16 clk;
+	u8 mc3r, mc1r;
 
-	if (timing == MMC_TIMING_MMC_DDR52) {
-		mc1r = sdhci_readb(host, SDMMC_MC1R);
+	mc1r = readb(host->ioaddr + SDMMC_MC1R);
+	mc3r = readb(host->ioaddr + SDMMC_MC3R);
+	clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+
+	/* SDCLK must be disabled while changing the mode */
+	if (clk & SDHCI_CLOCK_CARD_EN)
+		sdhci_writew(host, clk & ~SDHCI_CLOCK_CARD_EN,
+			     SDHCI_CLOCK_CONTROL);
+
+	if (timing == MMC_TIMING_MMC_DDR52 || timing == MMC_TIMING_MMC_HS400)
 		mc1r |= SDMMC_MC1R_DDR;
-		sdhci_writeb(host, mc1r, SDMMC_MC1R);
-	}
+	else
+		mc1r &= ~SDMMC_MC1R_DDR;
+
+	sdhci_writeb(host, mc1r, SDMMC_MC1R);
+
+	if (timing == MMC_TIMING_MMC_HS400)
+		mc3r |= SDMMC_MC3R_HS400EN;
+	else
+		mc3r &= ~SDMMC_MC3R_HS400EN;
+
+	writeb(mc3r, host->ioaddr + SDMMC_MC3R);
+
 	sdhci_set_uhs_signaling(host, timing);
+
+	/* reenable SDCLK */
+	if (clk & SDHCI_CLOCK_CARD_EN) {
+		clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+		sdhci_writew(host, clk | SDHCI_CLOCK_CARD_EN, SDHCI_CLOCK_CONTROL);
+	}
 }
 
 static void sdhci_at91_reset(struct sdhci_host *host, u8 mask)
@@ -115,9 +150,21 @@
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_at91_priv *priv = sdhci_pltfm_priv(pltfm_host);
 	unsigned int tmp;
+	u16 clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+
+	/* SDCLK must be disabled while resetting the HW block */
+	if (clk & SDHCI_CLOCK_CARD_EN)
+		sdhci_writew(host, clk & ~SDHCI_CLOCK_CARD_EN,
+			     SDHCI_CLOCK_CONTROL);
 
 	sdhci_reset(host, mask);
 
+	/* reenable SDCLK */
+	if (clk & SDHCI_CLOCK_CARD_EN) {
+		clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+		sdhci_writew(host, clk | SDHCI_CLOCK_CARD_EN, SDHCI_CLOCK_CONTROL);
+	}
+
 	if ((host->mmc->caps & MMC_CAP_NONREMOVABLE)
 	    || mmc_gpio_get_cd(host->mmc) >= 0)
 		sdhci_at91_set_force_card_detect(host);
@@ -134,12 +181,31 @@
 	}
 }
 
+static void sdhci_at91_hw_reset(struct sdhci_host *host)
+{
+	u8 mc1r;
+
+	mc1r = readb(host->ioaddr + SDMMC_MC1R);
+
+	mc1r |= SDMMC_MC1R_RSTN;
+	writeb(mc1r, host->ioaddr + SDMMC_MC1R);
+
+	udelay(10);
+
+	mc1r &= ~SDMMC_MC1R_RSTN;
+	writeb(mc1r, host->ioaddr + SDMMC_MC1R);
+
+	/* JEDEC specifies a minimum of 200us for tRSCA (reset to command) */
+	usleep_range(200, 500);
+}
+
 static const struct sdhci_ops sdhci_at91_sama5d2_ops = {
 	.set_clock		= sdhci_at91_set_clock,
 	.set_bus_width		= sdhci_set_bus_width,
 	.reset			= sdhci_at91_reset,
 	.set_uhs_signaling	= sdhci_at91_set_uhs_signaling,
 	.set_power		= sdhci_set_power_and_bus_voltage,
+	.hw_reset		= sdhci_at91_hw_reset,
 };
 
 static const struct sdhci_pltfm_data sdhci_sama5d2_pdata = {
@@ -149,17 +215,30 @@
 static const struct sdhci_at91_soc_data soc_data_sama5d2 = {
 	.pdata = &sdhci_sama5d2_pdata,
 	.baseclk_is_generated_internally = false,
+	.max_sdr104_clk = 120000000,
+	.pm_runtime_disable_clks = true,
+	.quirks2 = SDHCI_QUIRK2_BROKEN_HS200,
 };
 
 static const struct sdhci_at91_soc_data soc_data_sam9x60 = {
 	.pdata = &sdhci_sama5d2_pdata,
 	.baseclk_is_generated_internally = true,
 	.divider_for_baseclk = 2,
+	.pm_runtime_disable_clks = true,
+};
+
+static const struct sdhci_at91_soc_data soc_data_sama7g5 = {
+	.pdata = &sdhci_sama5d2_pdata,
+	.baseclk_is_generated_internally = true,
+	.divider_for_baseclk = 2,
+	.max_sdr104_clk = 200000000,
+	.quirks2 = SDHCI_QUIRK2_AT91_HS400_PRESET,
 };
 
 static const struct of_device_id sdhci_at91_dt_match[] = {
 	{ .compatible = "atmel,sama5d2-sdhci", .data = &soc_data_sama5d2 },
 	{ .compatible = "microchip,sam9x60-sdhci", .data = &soc_data_sam9x60 },
+	{ .compatible = "microchip,sama7g5-sdhci", .data = &soc_data_sama7g5 },
 	{}
 };
 MODULE_DEVICE_TABLE(of, sdhci_at91_dt_match);
@@ -178,6 +257,18 @@
 	caps0 = readl(host->ioaddr + SDHCI_CAPABILITIES);
 	caps1 = readl(host->ioaddr + SDHCI_CAPABILITIES_1);
 
+	/*
+	* We experience some issues with SDR104. If the SD clock is higher
+	* than 100 MHz, we can get data corruption. With a 100 MHz clock,
+	* the tuning procedure may fail. For those reasons, it is useless to
+	* advertise that we can use SDR104 mode, so remove it from
+	* the capabilities.
+	*/
+	writel(SDMMC_CACR_KEY | SDMMC_CACR_CAPWREN, host->ioaddr + SDMMC_CACR);
+	caps1 &= (~SDHCI_SUPPORT_SDR104);
+	writel(caps1, host->ioaddr + SDHCI_CAPABILITIES_1);
+	writel(0, host->ioaddr + SDMMC_CACR);
+
 	gck_rate = clk_get_rate(priv->gck);
 	if (priv->soc_data->baseclk_is_generated_internally)
 		clk_base_rate = gck_rate / priv->soc_data->divider_for_baseclk;
@@ -216,12 +307,21 @@
 	preset_div = DIV_ROUND_UP(gck_rate, 100000000) - 1;
 	writew(SDHCI_AT91_PRESET_COMMON_CONF | preset_div,
 	       host->ioaddr + SDHCI_PRESET_FOR_SDR50);
-	preset_div = DIV_ROUND_UP(gck_rate, 120000000) - 1;
-	writew(SDHCI_AT91_PRESET_COMMON_CONF | preset_div,
-	       host->ioaddr + SDHCI_PRESET_FOR_SDR104);
+	if (priv->soc_data->max_sdr104_clk) {
+		preset_div = DIV_ROUND_UP(gck_rate,
+					  priv->soc_data->max_sdr104_clk) - 1;
+		writew(SDHCI_AT91_PRESET_COMMON_CONF | preset_div,
+		       host->ioaddr + SDHCI_PRESET_FOR_SDR104);
+	}
 	preset_div = DIV_ROUND_UP(gck_rate, 50000000) - 1;
 	writew(SDHCI_AT91_PRESET_COMMON_CONF | preset_div,
 	       host->ioaddr + SDHCI_PRESET_FOR_DDR50);
+	if (priv->soc_data->max_sdr104_clk) {
+		preset_div = DIV_ROUND_UP(gck_rate,
+					  priv->soc_data->max_sdr104_clk) - 1;
+		writew(SDHCI_AT91_PRESET_DRVA_CONF | preset_div,
+		       host->ioaddr + SDHCI_PRESET_FOR_HS400);
+	}
 
 	clk_prepare_enable(priv->mainck);
 	clk_prepare_enable(priv->gck);
@@ -258,9 +358,11 @@
 	if (host->tuning_mode != SDHCI_TUNING_MODE_3)
 		mmc_retune_needed(host->mmc);
 
-	clk_disable_unprepare(priv->gck);
-	clk_disable_unprepare(priv->hclock);
-	clk_disable_unprepare(priv->mainck);
+	if (priv->soc_data->pm_runtime_disable_clks) {
+		clk_disable_unprepare(priv->gck);
+		clk_disable_unprepare(priv->hclock);
+		clk_disable_unprepare(priv->mainck);
+	}
 
 	return ret;
 }
@@ -281,6 +383,9 @@
 		goto out;
 	}
 
+	if (!priv->soc_data->pm_runtime_disable_clks)
+		goto out;
+
 	ret = clk_prepare_enable(priv->mainck);
 	if (ret) {
 		dev_err(dev, "can't enable mainck\n");
@@ -311,6 +416,20 @@
 			   NULL)
 };
 
+static void at91_sdhci_hs400_enhanced_strobe(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct sdhci_host *host = mmc_priv(mmc);
+	u8 mc3r;
+
+	mc3r = readb(host->ioaddr + SDMMC_MC3R);
+	if (ios->enhanced_strobe)
+		mc3r |= SDMMC_MC3R_ESMEN;
+	else
+		mc3r &= ~SDMMC_MC3R_ESMEN;
+
+	writeb(mc3r, host->ioaddr + SDMMC_MC3R);
+}
+
 static int sdhci_at91_probe(struct platform_device *pdev)
 {
 	const struct sdhci_at91_soc_data	*soc_data;
@@ -331,6 +450,11 @@
 	priv = sdhci_pltfm_priv(pltfm_host);
 	priv->soc_data = soc_data;
 
+	/* Perform a software reset before using the IP */
+	sdhci_at91_reset(host, SDHCI_RESET_ALL);
+	/* Perform a hardware reset before using the IP */
+	sdhci_at91_hw_reset(host);
+
 	priv->mainck = devm_clk_get(&pdev->dev, "baseclk");
 	if (IS_ERR(priv->mainck)) {
 		if (soc_data->baseclk_is_generated_internally) {
@@ -382,13 +506,14 @@
 	pm_runtime_set_autosuspend_delay(&pdev->dev, 50);
 	pm_runtime_use_autosuspend(&pdev->dev);
 
-	/* HS200 is broken at this moment */
-	host->quirks2 |= SDHCI_QUIRK2_BROKEN_HS200;
+	host->quirks2 |= priv->soc_data->quirks2;
 
 	ret = sdhci_add_host(host);
 	if (ret)
 		goto pm_runtime_disable;
 
+	host->mmc_host_ops.hs400_enhanced_strobe = at91_sdhci_hs400_enhanced_strobe;
+
 	/*
 	 * When calling sdhci_runtime_suspend_host(), the sdhci layer makes
 	 * the assumption that all the clocks of the controller are disabled.
--- linux-6.6.51/drivers/mmc/host/sdhci.c	2024-12-05 13:07:48.788234000 +0900
+++ linux4microchip-fpga-2024.09/drivers/mmc/host/sdhci.c	2024-12-04 16:41:28.959488000 +0900
@@ -2293,6 +2293,9 @@
 	case MMC_TIMING_UHS_SDR104:
 	case MMC_TIMING_UHS_DDR50:
 	case MMC_TIMING_MMC_DDR52:
+#ifdef SDHCI_QUIRK2_AT91_HS400_PRESET
+	case MMC_TIMING_MMC_HS400:
+#endif
 		return true;
 	}
 	return false;
@@ -2844,7 +2847,7 @@
 }
 EXPORT_SYMBOL_GPL(sdhci_send_tuning);
 
-static int __sdhci_execute_tuning(struct sdhci_host *host, u32 opcode)
+int __sdhci_execute_tuning(struct sdhci_host *host, u32 opcode)
 {
 	int i;
 
@@ -2882,6 +2885,7 @@
 	sdhci_reset_tuning(host);
 	return -EAGAIN;
 }
+EXPORT_SYMBOL_GPL(__sdhci_execute_tuning);
 
 int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 {
--- linux-6.6.51/drivers/mmc/host/sdhci.h	2024-12-05 13:07:48.788234000 +0900
+++ linux4microchip-fpga-2024.09/drivers/mmc/host/sdhci.h	2024-12-04 16:41:28.960485300 +0900
@@ -270,6 +270,7 @@
 #define SDHCI_PRESET_FOR_SDR104        0x6C
 #define SDHCI_PRESET_FOR_DDR50 0x6E
 #define SDHCI_PRESET_FOR_HS400 0x74 /* Non-standard */
+#define SDHCI_PRESET_FOR_HS400_AT91	0x244 /* AT91 specific */
 #define SDHCI_PRESET_DRV_MASK		GENMASK(15, 14)
 #define SDHCI_PRESET_CLKGEN_SEL		BIT(10)
 #define SDHCI_PRESET_SDCLK_FREQ_MASK	GENMASK(9, 0)
@@ -486,6 +487,10 @@
 #define SDHCI_QUIRK2_USE_32BIT_BLK_CNT			(1<<18)
 /* Issue CMD and DATA reset together */
 #define SDHCI_QUIRK2_ISSUE_CMD_DAT_RESET_TOGETHER	(1<<19)
+/*
+ * AT91 specific HS400 preset register
+ */
+#define SDHCI_QUIRK2_AT91_HS400_PRESET			(1<<20)
 
 	int irq;		/* Device IRQ */
 	void __iomem *ioaddr;	/* Mapped address */
@@ -794,6 +799,7 @@
 void sdhci_reset(struct sdhci_host *host, u8 mask);
 void sdhci_set_uhs_signaling(struct sdhci_host *host, unsigned timing);
 int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode);
+int __sdhci_execute_tuning(struct sdhci_host *host, u32 opcode);
 void sdhci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios);
 int sdhci_start_signal_voltage_switch(struct mmc_host *mmc,
 				      struct mmc_ios *ios);
