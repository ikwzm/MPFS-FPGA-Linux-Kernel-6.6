--- linux-6.6.51/Documentation/devicetree/bindings/mtd/atmel-nand.txt	2024-12-05 13:07:31.171853700 +0900
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/mtd/atmel-nand.txt	2024-12-04 16:41:10.406861600 +0900
@@ -53,6 +53,7 @@
 Required properties:
 - compatible: should be one of the following
 	"atmel,at91sam9g45-pmecc"
+	"microchip,sam9x7-pmecc"
 	"atmel,sama5d4-pmecc"
 	"atmel,sama5d2-pmecc"
 	"microchip,sam9x60-pmecc"
--- linux-6.6.51/drivers/mtd/nand/raw/atmel/pmecc.c	2024-12-05 13:07:48.851096900 +0900
+++ linux4microchip-fpga-2024.09/drivers/mtd/nand/raw/atmel/pmecc.c	2024-12-04 16:41:29.024314600 +0900
@@ -41,6 +41,7 @@
  * to expose the needed lib/bch.c helpers/functions and re-use them here.
  */
 
+#include <linux/clk.h>
 #include <linux/genalloc.h>
 #include <linux/iopoll.h>
 #include <linux/module.h>
@@ -143,11 +144,13 @@
 	int nstrengths;
 	int el_offset;
 	bool correct_erased_chunks;
+	bool pmc_clk_ctrl;
 };
 
 struct atmel_pmecc {
 	struct device *dev;
 	const struct atmel_pmecc_caps *caps;
+	struct clk *clk;
 
 	struct {
 		void __iomem *base;
@@ -834,28 +837,55 @@
 {
 	struct device *dev = &pdev->dev;
 	struct atmel_pmecc *pmecc;
+	void *err;
+	int ret;
 
 	pmecc = devm_kzalloc(dev, sizeof(*pmecc), GFP_KERNEL);
 	if (!pmecc)
 		return ERR_PTR(-ENOMEM);
 
+	/* Enable clk if controlled by pmc */
+	if (caps->pmc_clk_ctrl) {
+		pmecc->clk = devm_clk_get(dev, NULL);
+		if (IS_ERR(pmecc->clk)) {
+			dev_err(dev, "failed to get pmecc clk\n");
+			return ERR_CAST(pmecc->clk);
+		}
+
+		ret = clk_prepare_enable(pmecc->clk);
+		if (ret) {
+			dev_err(dev, "failed to enable pmecc clk, ret = %d\n", ret);
+			return ERR_PTR(ret);
+		}
+	}
+
 	pmecc->caps = caps;
 	pmecc->dev = dev;
 	mutex_init(&pmecc->lock);
 
 	pmecc->regs.base = devm_platform_ioremap_resource(pdev, pmecc_res_idx);
-	if (IS_ERR(pmecc->regs.base))
-		return ERR_CAST(pmecc->regs.base);
+	if (IS_ERR(pmecc->regs.base)) {
+		err = ERR_CAST(pmecc->regs.base);
+		goto clk_disable;
+	}
 
 	pmecc->regs.errloc = devm_platform_ioremap_resource(pdev, errloc_res_idx);
-	if (IS_ERR(pmecc->regs.errloc))
-		return ERR_CAST(pmecc->regs.errloc);
+	if (IS_ERR(pmecc->regs.errloc)) {
+		err = ERR_CAST(pmecc->regs.errloc);
+		goto clk_disable;
+	}
 
 	/* Disable all interrupts before registering the PMECC handler. */
 	writel(0xffffffff, pmecc->regs.base + ATMEL_PMECC_IDR);
 	atmel_pmecc_reset(pmecc);
 
 	return pmecc;
+
+clk_disable:
+	if (caps->pmc_clk_ctrl)
+		clk_disable_unprepare(pmecc->clk);
+
+	return err;
 }
 
 static void devm_atmel_pmecc_put(struct device *dev, void *res)
@@ -906,6 +936,13 @@
 	.el_offset = 0x8c,
 };
 
+static struct atmel_pmecc_caps sam9x7_caps = {
+	.strengths = atmel_pmecc_strengths,
+	.nstrengths = 5,
+	.el_offset = 0x8c,
+	.pmc_clk_ctrl = true,
+};
+
 static struct atmel_pmecc_caps sama5d4_caps = {
 	.strengths = atmel_pmecc_strengths,
 	.nstrengths = 5,
@@ -975,6 +1012,7 @@
 	{ .compatible = "atmel,at91sam9g45-pmecc", &at91sam9g45_caps },
 	{ .compatible = "atmel,sama5d4-pmecc", &sama5d4_caps },
 	{ .compatible = "atmel,sama5d2-pmecc", &sama5d2_caps },
+	{ .compatible = "microchip,sam9x7-pmecc", &sam9x7_caps },
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, atmel_pmecc_match);
@@ -1000,12 +1038,23 @@
 	return 0;
 }
 
+static int atmel_pmecc_remove(struct platform_device *pdev)
+{
+	struct atmel_pmecc *pmecc = platform_get_drvdata(pdev);
+
+	if (pmecc->caps->pmc_clk_ctrl)
+		clk_disable_unprepare(pmecc->clk);
+
+	return 0;
+}
+
 static struct platform_driver atmel_pmecc_driver = {
 	.driver = {
 		.name = "atmel-pmecc",
 		.of_match_table = atmel_pmecc_match,
 	},
 	.probe = atmel_pmecc_probe,
+	.remove = atmel_pmecc_remove,
 };
 module_platform_driver(atmel_pmecc_driver);
 
