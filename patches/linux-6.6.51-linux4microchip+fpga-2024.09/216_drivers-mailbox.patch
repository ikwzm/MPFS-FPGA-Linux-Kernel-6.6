--- /dev/null
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/mailbox/microchip,miv-ihc.yaml	2024-12-04 16:41:10.196424600 +0900
@@ -0,0 +1,59 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/mailbox/microchip,miv-ihc.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Microchip PolarFire Mi-V Inter-hart communication (IHC) driver
+
+maintainers:
+  - Valentina Fernandez <valentina.fernandezalanis@microchip.com>
+  - Conor Dooley <Conor Dooley <conor.dooley@microchip.com>>
+
+description: |
+  The Mi-V Inter-hart Communication (IHC) subsystem is used to exchange
+  data between harts in PolarFire SoC. It provides the ability to
+  send messages (ie. data, status and control) and coordinate between
+  harts through a non-blocking interrupt signaling mechanism.
+
+properties:
+  compatible:
+    const: microchip,miv-ihc
+
+  interrupts:
+    description: |
+      Should contain the IHC interrupt associated with the lowest
+      hart ID in the local software context.
+    maxItems: 1
+
+  microchip,miv-ihc-remote-context-id:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    enum: [5, 6]
+    default: 6
+    description: |
+      ID of the software context where data should be sent to.
+      Should be either a value of 5 (Context A) or 6 (Context B).
+      A default value of 6 should be used to match default IHC configuration
+      (Linux on context A and RTOS/BM on context B).
+
+  "#mbox-cells":
+    const: 1
+
+required:
+  - compatible
+  - interrupts
+  - "#mbox-cells"
+  - microchip,miv-ihc-remote-context-id
+
+additionalProperties: false
+
+examples:
+  - |
+    #include "dt-bindings/mailbox/miv-ihc.h"
+    ihc: mailbox {
+      compatible = "microchip,miv-ihc";
+      interrupt-parent = <&plic>;
+      interrupts = <IHC_HART1_INT>;
+      microchip,miv-ihc-remote-context-id = <IHC_CONTEXT_B>;
+      #mbox-cells = <1>;
+    };
--- linux-6.6.51/Documentation/devicetree/bindings/mailbox/microchip,mpfs-mailbox.yaml	2024-12-05 13:07:30.995325900 +0900
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/mailbox/microchip,mpfs-mailbox.yaml	2024-12-04 16:41:10.196424600 +0900
@@ -11,11 +11,17 @@
 
 properties:
   compatible:
-    const: microchip,mpfs-mailbox
+    oneOf:
+      - items:
+          - const: microchip,pic64gx-mailbox
+          - const: microchip,mpfs-mailbox
+      - const: microchip,mpfs-mailbox
 
   reg:
     oneOf:
       - items:
+          - description: mailbox data registers
+      - items:
           - description: mailbox control & data registers
           - description: mailbox interrupt registers
         deprecated: true
@@ -23,6 +29,7 @@
           - description: mailbox control registers
           - description: mailbox interrupt registers
           - description: mailbox data registers
+        deprecated: true
 
   interrupts:
     maxItems: 1
@@ -41,12 +48,12 @@
 examples:
   - |
     soc {
-      #address-cells = <2>;
-      #size-cells = <2>;
-      mbox: mailbox@37020000 {
+      #address-cells = <1>;
+      #size-cells = <1>;
+
+      mailbox@37020800 {
         compatible = "microchip,mpfs-mailbox";
-        reg = <0x0 0x37020000 0x0 0x58>, <0x0 0x2000318C 0x0 0x40>,
-              <0x0 0x37020800 0x0 0x100>;
+        reg = <0x37020800 0x100>;
         interrupt-parent = <&L1>;
         interrupts = <96>;
         #mbox-cells = <1>;
--- /dev/null
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/mailbox/microchip,sbi-ipc.yaml	2024-12-04 16:41:10.197421900 +0900
@@ -0,0 +1,114 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/mailbox/microchip,sbi-ipc.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Microchip Inter-processor communication (IPC) mailbox controller
+
+maintainers:
+  - Valentina Fernandez <valentina.fernandezalanis@microchip.com>
+
+description:
+  The Microchip Inter-processor Communication (IPC) is used to exchange
+  data between processors. It provides the ability to send and receive
+  messages through a non-blocking interrupt signaling mechanism.
+  This SBI interface is compatible with the Mi-V Inter-hart
+  Communication (IHC) IP.
+  The microchip,sbi-ipc compatible string is inteded for use by software
+  running in s-mode. The SoC-specific compatibles are inteded for use
+  by the SBI implementation (m-mode).
+
+properties:
+  compatible:
+    enum:
+      - microchip,sbi-ipc
+      - microchip,miv-ihc-rtl-v2
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    minItems: 1
+    maxItems: 5
+
+  interrupt-names:
+    minItems: 1
+    maxItems: 5
+
+  "#mbox-cells":
+    description:
+      For the SBI "device", the cell represents the global "logical" channel IDs.
+      The meaning of channel IDs are platform firmware dependent. The
+      SoC-specific compatibles are intended for use by the SBI implementation,
+      rather than s-mode software. There the cell would represent the physical
+      channel and do not vary depending on platform firmware.
+    const: 1
+
+  microchip,ihc-chan-disabled-mask:
+    description:
+      Represents the enable/disable state of the bi-directional IHC channels
+      within the MIV-IHC IP configuration. The mask is a 16-bit value, but only
+      the first 15 bits are utilized.Each of the bits corresponds to
+      one of the 15 IHC channels.
+      A bit set to '1' indicates that the corresponding channel is disabled,
+      and any read or write operations to that channel will return zero.
+      A bit set to '0' indicates that the corresponding channel is enabled
+      and will be accessible through its dedicated address range registers.
+      The remaining bit of the 16-bit mask is reserved and should be ignored.
+      The actual enable/disable state of each channel is determined by the
+      IP blockâ€™s configuration.
+    $ref: /schemas/types.yaml#/definitions/uint16
+    default: 0
+
+required:
+  - compatible
+  - interrupts
+  - interrupt-names
+  - "#mbox-cells"
+
+additionalProperties: false
+
+allOf:
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: microchip,sbi-ipc
+    then:
+      properties:
+        reg: false
+    else:
+      required:
+        - reg
+
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: microchip,miv-ihc-rtl-v2
+    then:
+      properties:
+        interrupt-names:
+          items:
+            pattern: "^hart-[0-5]+$"
+
+examples:
+  - |
+    mailbox {
+      compatible = "microchip,sbi-ipc";
+      interrupt-parent = <&plic>;
+      interrupts = <180>, <179>, <178>;
+      interrupt-names = "hart-1", "hart-2", "hart-3";
+      #mbox-cells = <1>;
+    };
+  - |
+    mailbox@50000000 {
+      compatible = "microchip,miv-ihc-rtl-v2";
+      microchip,ihc-chan-disabled-mask=  /bits/ 16 <0>;
+      reg = <0x50000000 0x1C000>;
+      interrupt-parent = <&plic>;
+      interrupts = <180>, <179>, <178>;
+      interrupt-names = "hart-1", "hart-2", "hart-3";
+      #mbox-cells = <1>;
+    };
--- linux-6.6.51/drivers/mailbox/Kconfig	2024-12-05 13:07:47.201479300 +0900
+++ linux4microchip-fpga-2024.09/drivers/mailbox/Kconfig	2024-12-04 16:41:27.377719700 +0900
@@ -177,6 +177,7 @@
 	tristate "PolarFire SoC (MPFS) Mailbox"
 	depends on HAS_IOMEM
 	depends on ARCH_MICROCHIP_POLARFIRE || COMPILE_TEST
+	depends on MFD_SYSCON
 	help
 	  This driver adds support for the PolarFire SoC (MPFS) mailbox controller.
 
@@ -185,6 +186,31 @@
 
 	  If unsure, say N.
 
+config MIV_IHC
+	tristate "Mi-V Inter-hart Communication (IHC) driver"
+	depends on RISCV_SBI
+	depends on SOC_MICROCHIP_POLARFIRE || COMPILE_TEST
+	help
+	  This driver adds support for the inter-hart
+	  communication mailbox controller driver.
+
+	  To compile this driver as a module, choose M here. the
+	  module will be called mailbox-miv-ihc.
+
+	  If unsure, say N.
+
+config MCHP_SBI_IPC_MBOX
+	tristate "Microchip Inter-processor Communication (IPC) SBI driver"
+	depends on RISCV_SBI
+	help
+	  Mailbox implementation for Microchip devices with an
+	  Inter-process communication (IPC) controller.
+
+	  To compile this driver as a module, choose M here. the
+	  module will be called mailbox-mchp-ipc-sbi.
+
+	  If unsure, say N.
+
 config QCOM_APCS_IPC
 	tristate "Qualcomm APCS IPC driver"
 	depends on ARCH_QCOM || COMPILE_TEST
--- linux-6.6.51/drivers/mailbox/Makefile	2024-12-05 13:07:47.201479300 +0900
+++ linux4microchip-fpga-2024.09/drivers/mailbox/Makefile	2024-12-04 16:41:27.377719700 +0900
@@ -43,6 +43,10 @@
 
 obj-$(CONFIG_POLARFIRE_SOC_MAILBOX)	+= mailbox-mpfs.o
 
+obj-$(CONFIG_MIV_IHC)		+= mailbox-miv-ihc.o
+
+obj-$(CONFIG_MCHP_SBI_IPC_MBOX)		+= mailbox-mchp-ipc-sbi.o
+
 obj-$(CONFIG_QCOM_APCS_IPC)	+= qcom-apcs-ipc-mailbox.o
 
 obj-$(CONFIG_TEGRA_HSP_MBOX)	+= tegra-hsp.o
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/mailbox/mailbox-mchp-ipc-sbi.c	2024-12-04 16:41:27.382706400 +0900
@@ -0,0 +1,664 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Microchip Inter-Processor communication (IPC) driver
+ *
+ * Copyright (c) 2021 - 2024 Microchip Technology Inc. All rights reserved.
+ *
+ * Author: Valentina Fernandez <valentina.fernandezalanis@microchip.com>
+ *
+ */
+
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/of_device.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/mailbox/mchp-ipc.h>
+#include <asm/sbi.h>
+#include <asm/smp.h>
+#include <asm/vendorid_list.h>
+
+#define IRQ_STATUS_BITS			12
+#define NUM_CHANS_PER_CLUSTER		5
+#define IPC_DMA_BIT_MASK		32
+#define SBI_EXT_MICROCHIP_TECHNOLOGY	(SBI_EXT_VENDOR_START | \
+					 MICROCHIP_VENDOR_ID)
+
+enum {
+	SBI_EXT_IPC_PROBE = 0x100,
+	SBI_EXT_IPC_CH_INIT,
+	SBI_EXT_IPC_SEND,
+	SBI_EXT_IPC_RECEIVE,
+	SBI_EXT_IPC_STATUS,
+};
+
+enum ipc_hw {
+	MIV_IHC,
+	RESERVED1,
+	RESERVED2,
+};
+
+enum ipc_irq_type {
+	IPC_OPS_NOT_SUPPORTED	= 1,
+	IPC_MP_IRQ		= 2,
+	IPC_MC_IRQ		= 4,
+};
+
+/**
+ * struct mchp_ipc_probe - IPC probe message format
+ *
+ * @hw_type:		IPC implementation available in the hardware
+ * @num_channels:	number of IPC channels available in the hardware
+ *
+ * Used to retrieve information on the IPC implementation
+ * using the SBI_EXT_IPC_PROBE SBI function id.
+ */
+struct mchp_ipc_probe {
+	enum ipc_hw hw_type;
+	u8 num_channels;
+};
+
+/**
+ * struct mchp_ipc_init - IPC channel init message format
+ *
+ * @max_msg_size:	maxmimum message size in bytes of a given channel
+ *
+ * struct used by the SBI_EXT_IPC_CH_INIT SBI function id to get
+ * the max message size in bytes of the initialized channel.
+ */
+struct mchp_ipc_init {
+	u16 max_msg_size;
+};
+
+/**
+ * struct mchp_ipc_status - IPC status message format
+ *
+ * @status:	interrupt status for all channels associated to a cluster
+ * @cluster:	specifies the cluster instance that originated an irq
+ *
+ * struct used by the SBI_EXT_IPC_STATUS SBI function id to get
+ * the message present and message clear interrupt status for all the
+ * channels associated to a cluster.
+ */
+struct mchp_ipc_status {
+	u32 status;
+	u8 cluster;
+};
+
+/**
+ * struct mchp_ipc_sbi_msg - IPC SBI payload message
+ *
+ * @buf_addr:	physical address where the received data should be copied to
+ * @size:	maximum size(in bytes) that can be stored in the buffer pointed to by `buf`
+ * @irq_type:	mask representing the irq types that triggered an irq
+ *
+ * struct used by the SBI_EXT_IPC_SEND/SBI_EXT_IPC_RECEIVE SBI function
+ * ids to send/receive a message from an associated processor using
+ * the IPC.
+ */
+struct mchp_ipc_sbi_msg {
+	u64 buf_addr;
+	u16 size;
+	u8 irq_type;
+};
+
+struct mchp_ipc_cluster_cfg {
+	void *buf_base;
+	dma_addr_t dma_addr;
+	int irq;
+};
+
+struct ipc_chan_info {
+	void *buf_base_tx;
+	void *buf_base_rx;
+	void *msg_buf_tx;
+	void *msg_buf_rx;
+	dma_addr_t dma_addr_tx;
+	dma_addr_t dma_addr_rx;
+	dma_addr_t msg_buf_dma_tx;
+	dma_addr_t msg_buf_dma_rx;
+	int chan_aggregated_irq;
+	int mp_irq;
+	int mc_irq;
+	u32 id;
+	u32 max_msg_size;
+};
+
+struct microchip_ipc {
+	struct device *dev;
+	struct mbox_chan *chans;
+	struct mchp_ipc_cluster_cfg *cluster_cfg;
+	struct ipc_chan_info *priv;
+	void *buf_base;
+	dma_addr_t dma_addr;
+	struct mbox_controller controller;
+	u8 num_channels;
+	enum ipc_hw hw_type;
+};
+
+static int mchp_ipc_sbi_chan_send(u32 command, u32 channel, dma_addr_t address)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_MICROCHIP_TECHNOLOGY, command, channel,
+			address, 0, 0, 0, 0);
+
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+	else
+		return ret.value;
+}
+
+static int mchp_ipc_sbi_send(u32 command, dma_addr_t address)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_MICROCHIP_TECHNOLOGY, command, address,
+			0, 0, 0, 0, 0);
+
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+	else
+		return ret.value;
+}
+
+static struct microchip_ipc *to_mchp_ipc_mbox(struct mbox_controller *mbox)
+{
+	return container_of(mbox, struct microchip_ipc, controller);
+}
+
+u32 mchp_ipc_get_chan_id(struct mbox_chan *chan)
+{
+	struct ipc_chan_info *chan_info = (struct ipc_chan_info *)chan->con_priv;
+
+	return chan_info->id;
+}
+EXPORT_SYMBOL(mchp_ipc_get_chan_id);
+
+static inline void mchp_ipc_prepare_receive_req(struct mbox_chan *chan)
+{
+	struct ipc_chan_info *chan_info = (struct ipc_chan_info *)chan->con_priv;
+	struct mchp_ipc_sbi_msg request;
+
+	request.buf_addr = chan_info->msg_buf_dma_rx;
+	request.size = chan_info->max_msg_size;
+	memcpy(chan_info->buf_base_rx, &request, sizeof(struct mchp_ipc_sbi_msg));
+}
+
+static inline void mchp_ipc_process_received_data(struct mbox_chan *chan,
+						  struct mchp_ipc_msg *ipc_msg)
+{
+	struct ipc_chan_info *chan_info = (struct ipc_chan_info *)chan->con_priv;
+	struct mchp_ipc_sbi_msg sbi_msg;
+
+	memcpy(&sbi_msg, chan_info->buf_base_rx, sizeof(struct mchp_ipc_sbi_msg));
+	ipc_msg->buf = (u32 *)chan_info->msg_buf_rx;
+	ipc_msg->size = sbi_msg.size;
+}
+
+static irqreturn_t mchp_ipc_cluster_aggr_isr(int irq, void *data)
+{
+	struct mbox_chan *chan;
+	struct ipc_chan_info *chan_info;
+	struct microchip_ipc *ipc = (struct microchip_ipc *)data;
+	struct mchp_ipc_msg ipc_msg;
+	struct mchp_ipc_status status_msg;
+	int ret;
+	unsigned long hartid;
+	u32 i, chan_index, chan_id;
+
+	/* Find out the hart that originated the irq */
+	for_each_online_cpu(i) {
+		hartid = cpuid_to_hartid_map(i);
+		if (irq == ipc->cluster_cfg[hartid].irq)
+			break;
+	}
+
+	status_msg.cluster = hartid;
+	memcpy(ipc->cluster_cfg[hartid].buf_base, &status_msg, sizeof(struct mchp_ipc_status));
+
+	ret = mchp_ipc_sbi_send(SBI_EXT_IPC_STATUS, ipc->cluster_cfg[hartid].dma_addr);
+	if (ret < 0) {
+		dev_err_ratelimited(ipc->dev, "could not get IHC irq status ret=%d\n", ret);
+		return IRQ_HANDLED;
+	}
+
+	memcpy(&status_msg, ipc->cluster_cfg[hartid].buf_base, sizeof(struct mchp_ipc_status));
+
+	/*
+	 * Iterate over each bit set in the IHC interrupt status register (IRQ_STATUS) to identify
+	 * the channel(s) that have a message to be processed/acknowledged.
+	 * The bits are organized in alternating format, where each pair of bits represents
+	 * the status of the message present and message clear interrupts for each cluster/hart
+	 * (from hart 0 to hart 5). Each cluster can have up to 5 fixed channels associated.
+	 */
+
+	for_each_set_bit(i, (unsigned long *)&status_msg.status, IRQ_STATUS_BITS) {
+		/* Find out the destination hart that triggered the interrupt */
+		chan_index = i / 2;
+
+		/*
+		 * The IP has no loopback channels, so we need to decrement the index when
+		 * the target hart has a greater index than our own
+		 */
+		if (chan_index >= status_msg.cluster)
+			chan_index--;
+
+		/*
+		 * Calculate the channel id given the hart and channel index. Channel IDs
+		 * are unique across all clusters of an IPC, and iterate contiguously
+		 * across all clusters.
+		 */
+		chan_id = status_msg.cluster * (NUM_CHANS_PER_CLUSTER + chan_index);
+
+		chan = &ipc->chans[chan_id];
+		chan_info = (struct ipc_chan_info *)chan->con_priv;
+
+		if (i % 2 == 0) {
+			mchp_ipc_prepare_receive_req(chan);
+			ret = mchp_ipc_sbi_chan_send(SBI_EXT_IPC_RECEIVE, chan_id,
+						     chan_info->dma_addr_rx);
+			if (ret < 0)
+				continue;
+
+			mchp_ipc_process_received_data(chan, &ipc_msg);
+			mbox_chan_received_data(&ipc->chans[chan_id], (void *)&ipc_msg);
+
+		} else {
+			ret = mchp_ipc_sbi_chan_send(SBI_EXT_IPC_RECEIVE, chan_id,
+						     chan_info->dma_addr_rx);
+			mbox_chan_txdone(&ipc->chans[chan_id], ret);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mchp_ipc_isr(int irq, void *data)
+{
+	struct mbox_chan *chan = (struct mbox_chan *)data;
+	struct ipc_chan_info *chan_info = (struct ipc_chan_info *)chan->con_priv;
+	struct microchip_ipc *ipc = to_mchp_ipc_mbox(chan->mbox);
+	struct mchp_ipc_msg ipc_msg;
+	int ret;
+
+	mchp_ipc_prepare_receive_req(chan);
+
+	ret = mchp_ipc_sbi_chan_send(SBI_EXT_IPC_RECEIVE, chan_info->id, chan_info->dma_addr_rx);
+	if (ret < 0) {
+		dev_err_ratelimited(ipc->dev,
+				    "failed to receive message on channel %d, ret = %d\n",
+				    chan_info->id,
+				    ret);
+		return IRQ_HANDLED;
+	}
+
+	if (irq == chan_info->mp_irq) {
+		mchp_ipc_process_received_data(chan, &ipc_msg);
+		mbox_chan_received_data(&ipc->chans[chan_info->id], (void *)&ipc_msg);
+	}
+
+	if (irq == chan_info->mc_irq)
+		mbox_chan_txdone(&ipc->chans[chan_info->id], ret);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mchp_ipc_chan_aggr_isr(int irq, void *data)
+{
+	struct mbox_chan *chan = (struct mbox_chan *)data;
+	struct ipc_chan_info *chan_info = (struct ipc_chan_info *)chan->con_priv;
+	struct microchip_ipc *ipc = to_mchp_ipc_mbox(chan->mbox);
+	struct mchp_ipc_sbi_msg sbi_msg;
+	struct mchp_ipc_msg ipc_msg;
+	int ret;
+
+	mchp_ipc_prepare_receive_req(chan);
+
+	ret = mchp_ipc_sbi_chan_send(SBI_EXT_IPC_RECEIVE, chan_info->id, chan_info->dma_addr_rx);
+	if (ret < 0) {
+		dev_err_ratelimited(ipc->dev,
+				    "failed to receive message on channel %d, ret = %d\n",
+				    chan_info->id,
+				    ret);
+		return IRQ_HANDLED;
+	}
+
+	memcpy(&sbi_msg, chan_info->buf_base_rx, sizeof(struct mchp_ipc_sbi_msg));
+
+	if (sbi_msg.irq_type & IPC_MP_IRQ) {
+		ipc_msg.buf = (u32 *)chan_info->msg_buf_rx;
+		ipc_msg.size = sbi_msg.size;
+		mbox_chan_received_data(&ipc->chans[chan_info->id], (void *)&ipc_msg);
+	}
+
+	if (sbi_msg.irq_type & IPC_MC_IRQ)
+		mbox_chan_txdone(&ipc->chans[chan_info->id], ret);
+
+	return IRQ_HANDLED;
+}
+
+static int mchp_ipc_get_irq(struct microchip_ipc *ipc, u32 id, const char *name)
+{
+	struct platform_device *pdev = to_platform_device(ipc->dev);
+	char *irq_name;
+
+	irq_name = devm_kasprintf(ipc->dev, GFP_KERNEL, "ch%u-%s", id, name);
+	if (!irq_name)
+		return -ENOMEM;
+
+	return platform_get_irq_byname_optional(pdev, irq_name);
+}
+
+static int mchp_ipc_get_cluster_aggr_irq(struct microchip_ipc *ipc)
+{
+	struct platform_device *pdev = to_platform_device(ipc->dev);
+	char *irq_name;
+	int cpuid, ret;
+	unsigned long hartid;
+	bool irq_found = false;
+
+	for_each_online_cpu(cpuid) {
+		hartid = cpuid_to_hartid_map(cpuid);
+		irq_name = devm_kasprintf(ipc->dev, GFP_KERNEL, "hart-%lu", hartid);
+		ret = platform_get_irq_byname_optional(pdev, irq_name);
+		if (ret <= 0)
+			continue;
+
+		ipc->cluster_cfg[hartid].irq = ret;
+		ret = devm_request_irq(ipc->dev, ipc->cluster_cfg[hartid].irq,
+				       mchp_ipc_cluster_aggr_isr, IRQF_SHARED,
+				       "miv-ihc-irq", ipc);
+		if (ret)
+			return ret;
+
+		ipc->cluster_cfg[hartid].buf_base = dmam_alloc_coherent(ipc->dev,
+									sizeof(struct mchp_ipc_status),
+									&ipc->cluster_cfg[hartid].dma_addr,
+									GFP_KERNEL);
+
+		if (!ipc->cluster_cfg[hartid].buf_base)
+			return -ENOMEM;
+
+		irq_found = true;
+	}
+
+	return irq_found;
+}
+
+static int mchp_ipc_get_chan_aggr_irq(struct microchip_ipc *ipc, u32 channel)
+{
+	struct platform_device *pdev = to_platform_device(ipc->dev);
+	char *irq_name;
+
+	irq_name = devm_kasprintf(ipc->dev, GFP_KERNEL, "ch%u", channel);
+	return platform_get_irq_byname_optional(pdev, irq_name);
+}
+
+static int mchp_ipc_send_data(struct mbox_chan *chan, void *data)
+{
+	struct ipc_chan_info *chan_info = (struct ipc_chan_info *)chan->con_priv;
+	const struct mchp_ipc_msg *msg = data;
+	struct mchp_ipc_sbi_msg sbi_payload;
+
+	memcpy(chan_info->msg_buf_tx, msg->buf, msg->size);
+	sbi_payload.buf_addr = chan_info->msg_buf_dma_tx;
+	sbi_payload.size = msg->size;
+	memcpy(chan_info->buf_base_tx, &sbi_payload, sizeof(sbi_payload));
+
+	return mchp_ipc_sbi_chan_send(SBI_EXT_IPC_SEND, chan_info->id, chan_info->dma_addr_tx);
+}
+
+static int mchp_ipc_startup(struct mbox_chan *chan)
+{
+	struct ipc_chan_info *chan_info = (struct ipc_chan_info *)chan->con_priv;
+	struct microchip_ipc *ipc = to_mchp_ipc_mbox(chan->mbox);
+	struct mchp_ipc_init ch_init_msg;
+	int ret;
+
+	chan_info->buf_base_tx = dma_alloc_coherent(ipc->dev, sizeof(struct mchp_ipc_sbi_msg),
+						    &chan_info->dma_addr_tx, GFP_KERNEL);
+	if (!chan_info->buf_base_tx) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	chan_info->buf_base_rx = dma_alloc_coherent(ipc->dev, sizeof(struct mchp_ipc_sbi_msg),
+						    &chan_info->dma_addr_rx, GFP_KERNEL);
+	if (!chan_info->buf_base_rx) {
+		ret = -ENOMEM;
+		goto fail_free_buf_base_tx;
+	}
+
+	ret = mchp_ipc_sbi_chan_send(SBI_EXT_IPC_CH_INIT, chan_info->id, chan_info->dma_addr_tx);
+	if (ret < 0) {
+		dev_err(ipc->dev, "channel %u init failed\n", chan_info->id);
+		goto fail_free_buf_base_rx;
+	}
+
+	memcpy(&ch_init_msg, chan_info->buf_base_tx, sizeof(struct mchp_ipc_init));
+	chan_info->max_msg_size = ch_init_msg.max_msg_size;
+
+	chan_info->msg_buf_tx = dma_alloc_coherent(ipc->dev, chan_info->max_msg_size,
+						   &chan_info->msg_buf_dma_tx, GFP_KERNEL);
+	if (!chan_info->msg_buf_tx) {
+		ret = -ENOMEM;
+		goto fail_free_buf_base_rx;
+	}
+
+	chan_info->msg_buf_rx = dma_alloc_coherent(ipc->dev, chan_info->max_msg_size,
+						   &chan_info->msg_buf_dma_rx, GFP_KERNEL);
+	if (!chan_info->msg_buf_rx) {
+		ret = -ENOMEM;
+		goto fail_free_buf_msg_tx;
+	}
+
+	switch (ipc->hw_type) {
+	case MIV_IHC:
+		return 0;
+	case RESERVED1:
+		ret = devm_request_irq(ipc->dev, chan_info->mp_irq, mchp_ipc_isr, IRQF_SHARED,
+				       "ipc-irq-mp", &ipc->chans[chan_info->id]);
+		if (ret)
+			goto fail_free_buf_msg_rx;
+		ret = devm_request_irq(ipc->dev, chan_info->mc_irq, mchp_ipc_isr, IRQF_SHARED,
+				       "ipc-irq-mc", &ipc->chans[chan_info->id]);
+		break;
+	case RESERVED2:
+		ret = devm_request_irq(ipc->dev, chan_info->chan_aggregated_irq,
+				       mchp_ipc_chan_aggr_isr, IRQF_SHARED, "ipc-irq",
+				       &ipc->chans[chan_info->id]);
+		break;
+	default:
+		goto fail_free_buf_msg_rx;
+	}
+
+	if (ret) {
+		dev_err(ipc->dev, "failed to register interrupt(s)\n");
+		goto fail_free_buf_msg_rx;
+	}
+
+	return ret;
+
+fail_free_buf_msg_rx:
+	dma_free_coherent(ipc->dev, chan_info->max_msg_size,
+			  chan_info->msg_buf_rx, chan_info->msg_buf_dma_rx);
+fail_free_buf_msg_tx:
+	dma_free_coherent(ipc->dev, chan_info->max_msg_size,
+			  chan_info->msg_buf_tx, chan_info->msg_buf_dma_tx);
+fail_free_buf_base_rx:
+	dma_free_coherent(ipc->dev, sizeof(struct mchp_ipc_sbi_msg),
+			  chan_info->buf_base_rx, chan_info->dma_addr_rx);
+fail_free_buf_base_tx:
+	dma_free_coherent(ipc->dev, sizeof(struct mchp_ipc_sbi_msg),
+			  chan_info->buf_base_tx, chan_info->dma_addr_tx);
+fail:
+	return ret;
+}
+
+static void mchp_ipc_shutdown(struct mbox_chan *chan)
+{
+	struct ipc_chan_info *chan_info = (struct ipc_chan_info *)chan->con_priv;
+	struct microchip_ipc *ipc = to_mchp_ipc_mbox(chan->mbox);
+
+	switch (ipc->hw_type) {
+	case RESERVED1:
+		devm_free_irq(ipc->dev, chan_info->mp_irq, chan);
+		devm_free_irq(ipc->dev, chan_info->mc_irq, chan);
+		break;
+	case RESERVED2:
+		devm_free_irq(ipc->dev, chan_info->chan_aggregated_irq, chan);
+		break;
+	default:
+		break;
+	}
+	dma_free_coherent(ipc->dev, chan_info->max_msg_size,
+			  chan_info->msg_buf_tx, chan_info->msg_buf_dma_tx);
+
+	dma_free_coherent(ipc->dev, chan_info->max_msg_size,
+			  chan_info->msg_buf_rx, chan_info->msg_buf_dma_rx);
+
+	dma_free_coherent(ipc->dev, sizeof(struct mchp_ipc_sbi_msg),
+			  chan_info->buf_base_tx, chan_info->dma_addr_tx);
+
+	dma_free_coherent(ipc->dev, sizeof(struct mchp_ipc_sbi_msg),
+			  chan_info->buf_base_rx, chan_info->dma_addr_rx);
+}
+
+static const struct mbox_chan_ops mchp_ipc_ops = {
+	.startup = mchp_ipc_startup,
+	.send_data = mchp_ipc_send_data,
+	.shutdown = mchp_ipc_shutdown,
+};
+
+static struct mbox_chan *mchp_ipc_mbox_xlate(struct mbox_controller *controller,
+					     const struct of_phandle_args *spec)
+{
+	struct microchip_ipc *ipc = to_mchp_ipc_mbox(controller);
+	unsigned int chan_id = spec->args[0];
+
+	if (chan_id >= ipc->num_channels) {
+		dev_err(ipc->dev, "invalid channel id %d\n", chan_id);
+		return ERR_PTR(-EINVAL);
+	}
+
+	return &ipc->chans[chan_id];
+}
+
+static const struct of_device_id mchp_ipc_of_match[] = {
+	{.compatible = "microchip,sbi-ipc", },
+	{}
+};
+
+static int mchp_ipc_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mchp_ipc_probe ipc_info;
+	struct microchip_ipc *ipc;
+	struct ipc_chan_info *priv;
+	bool irq_avail = false;
+	int ret;
+	u32 chan_id;
+
+	ret = sbi_probe_extension(SBI_EXT_MICROCHIP_TECHNOLOGY);
+	if (ret <= 0)
+		return dev_err_probe(dev, ret, "Microchip SBI extension not detected\n");
+
+	ipc = devm_kzalloc(dev, sizeof(*ipc), GFP_KERNEL);
+	if (!ipc)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, ipc);
+
+	ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(IPC_DMA_BIT_MASK));
+	if (ret)
+		return dev_err_probe(dev, ret, "dma_set_mask_and_coherent failed\n");
+
+	ipc->buf_base = dmam_alloc_coherent(dev, sizeof(u32), &ipc->dma_addr, GFP_KERNEL);
+
+	if (!ipc->buf_base)
+		return -ENOMEM;
+
+	ret = mchp_ipc_sbi_send(SBI_EXT_IPC_PROBE, ipc->dma_addr);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "could not probe IPC SBI service\n");
+
+	memcpy(&ipc_info, ipc->buf_base, sizeof(struct mchp_ipc_probe));
+	ipc->num_channels = ipc_info.num_channels;
+	ipc->hw_type = ipc_info.hw_type;
+
+	ipc->chans = devm_kcalloc(dev, ipc->num_channels, sizeof(*ipc->chans), GFP_KERNEL);
+	if (!ipc->chans)
+		return -ENOMEM;
+
+	ipc->dev = dev;
+	ipc->controller.txdone_irq = true;
+	ipc->controller.dev = ipc->dev;
+	ipc->controller.ops = &mchp_ipc_ops;
+	ipc->controller.chans = ipc->chans;
+	ipc->controller.num_chans = ipc->num_channels;
+	ipc->controller.of_xlate = mchp_ipc_mbox_xlate;
+
+	for (chan_id = 0; chan_id < ipc->num_channels; chan_id++) {
+		priv = devm_kmalloc(dev, sizeof(*priv), GFP_KERNEL);
+		if (!priv)
+			return -ENOMEM;
+
+		ipc->chans[chan_id].con_priv = priv;
+		priv->id = chan_id;
+
+		if (ipc->hw_type == RESERVED1) {
+			priv->mp_irq = mchp_ipc_get_irq(ipc, chan_id, "mp");
+			priv->mc_irq = mchp_ipc_get_irq(ipc, chan_id, "mc");
+
+			if (priv->mp_irq > 0 && priv->mc_irq > 0)
+				irq_avail = true;
+		}
+
+		if (ipc->hw_type == RESERVED2) {
+			priv->chan_aggregated_irq = mchp_ipc_get_chan_aggr_irq(ipc, chan_id);
+			if (priv->chan_aggregated_irq > 0)
+				irq_avail = true;
+		}
+	}
+
+	if (ipc->hw_type == MIV_IHC) {
+		ipc->cluster_cfg = devm_kcalloc(dev, num_online_cpus(),
+						sizeof(struct mchp_ipc_cluster_cfg),
+						GFP_KERNEL);
+		if (!ipc->cluster_cfg)
+			return -ENOMEM;
+
+		if (mchp_ipc_get_cluster_aggr_irq(ipc))
+			irq_avail = true;
+	}
+
+	if (!irq_avail)
+		return dev_err_probe(dev, -ENODEV, "missing interrupt property\n");
+
+	ret = devm_mbox_controller_register(dev, &ipc->controller);
+	if (ret)
+		return dev_err_probe(dev, ret,
+					 "Inter-Processor communication (IPC) registration failed\n");
+
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(of, mchp_ipc_of_match);
+
+static struct platform_driver mchp_ipc_driver = {
+	.driver = {
+		.name = "microchip_ipc",
+		.of_match_table = of_match_ptr(mchp_ipc_of_match),
+	},
+	.probe = mchp_ipc_probe,
+};
+
+module_platform_driver(mchp_ipc_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Valentina Fernandez <valentina.fernandezalanis@microchip.com>");
+MODULE_DESCRIPTION("Microchip Inter-Processor Communication (IPC) driver");
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/mailbox/mailbox-miv-ihc.c	2024-12-04 16:41:27.383703800 +0900
@@ -0,0 +1,233 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Mi-V Inter-hart communication (IHC) driver
+ *
+ * Copyright (c) 2021 - 2022 Microchip Technology Inc. All rights reserved.
+ *
+ * Author: Valentina Fernandez <valentina.fernandezalanis@microchip.com>
+ *
+ */
+
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/dmapool.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/mailbox/miv_ihc.h>
+#include <asm/sbi.h>
+
+#define SBI_EXT_VENDOR_START			0x09000000
+#define MICROCHIP_TECHNOLOGY_MVENDOR_ID		0x029
+
+#define SBI_EXT_MICROCHIP_TECHNOLOGY	(SBI_EXT_VENDOR_START | \
+					MICROCHIP_TECHNOLOGY_MVENDOR_ID)
+
+enum {
+	IHC_MP_IRQ,
+	IHC_ACK_IRQ,
+};
+
+struct ihc_sbi_msg {
+	struct miv_ihc_msg ihc_msg;
+	u8 irq_type;
+};
+
+static int ihc_sbi_send(u32 command, u32 remote_context_id, dma_addr_t address)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_MICROCHIP_TECHNOLOGY, command, remote_context_id,
+			address, 0, 0, 0, 0);
+
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+	else
+		return ret.value;
+}
+
+static int ihc_sbi_init(u32 remote_context_id)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_MICROCHIP_TECHNOLOGY, SBI_EXT_IHC_INIT, remote_context_id,
+			0, 0, 0, 0, 0);
+
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+	else
+		return ret.value;
+}
+
+static struct miv_ihc *mbox_chan_to_ihc(struct mbox_chan *chan)
+{
+	if (!chan || !chan->con_priv)
+		return NULL;
+
+	return (struct miv_ihc *)chan->con_priv;
+}
+
+static irqreturn_t ihc_isr(int irq, void *data)
+{
+	struct ihc_sbi_msg sbi_rx_msg;
+	struct mbox_chan *chan = (struct mbox_chan *)data;
+	struct miv_ihc *ihc = mbox_chan_to_ihc(chan);
+	int ret;
+
+	ret = ihc_sbi_send(SBI_EXT_IHC_RX, ihc->remote_context_id, ihc->dma_addr);
+
+	if (unlikely(ret < 0)) {
+		dev_warn_ratelimited(ihc->dev, "incorrect remote context ID\n");
+		return IRQ_NONE;
+	}
+
+	memcpy(&sbi_rx_msg, ihc->buf_base, sizeof(sbi_rx_msg));
+
+	if (sbi_rx_msg.irq_type == IHC_MP_IRQ)
+		mbox_chan_received_data(&ihc->channel, &sbi_rx_msg.ihc_msg);
+	else
+		mbox_chan_txdone(&ihc->channel, 0);
+
+	return IRQ_HANDLED;
+}
+
+static int ihc_send_data(struct mbox_chan *chan, void *data)
+{
+	struct miv_ihc *ihc = mbox_chan_to_ihc(chan);
+	struct miv_ihc_msg *message = data;
+	int ret;
+
+	memcpy(ihc->buf_base, message, sizeof(*message));
+
+	ret = ihc_sbi_send(SBI_EXT_IHC_TX, ihc->remote_context_id, ihc->dma_addr);
+
+	return ret;
+}
+
+static int ihc_startup(struct mbox_chan *chan)
+{
+	struct miv_ihc *ihc = mbox_chan_to_ihc(chan);
+	int ret;
+
+	ret = devm_request_irq(ihc->dev, ihc->irq, ihc_isr, IRQF_SHARED,
+			       "miv-ihc-irq", &ihc->channel);
+
+	if (ret)
+		dev_err(ihc->dev, "failed to register interrupt:%d\n", ret);
+
+	return ret;
+}
+
+static void ihc_shutdown(struct mbox_chan *chan)
+{
+	struct miv_ihc *ihc = mbox_chan_to_ihc(chan);
+
+	devm_free_irq(ihc->dev, ihc->irq, chan);
+}
+
+static const struct mbox_chan_ops miv_ihc_ops = {
+	.startup = ihc_startup,
+	.send_data = ihc_send_data,
+	.shutdown = ihc_shutdown,
+};
+
+static int ihc_probe(struct platform_device *pdev)
+{
+	struct miv_ihc *ihc;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	int ret;
+
+	ret = sbi_probe_extension(SBI_EXT_MICROCHIP_TECHNOLOGY);
+	if (ret <= 0)
+		return dev_err_probe(dev, ret, "SBI IHC extension not detected\n");
+
+	ihc = devm_kzalloc(dev, sizeof(*ihc), GFP_KERNEL);
+	if (!ihc)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, ihc);
+
+	ret = of_property_read_u32(np, "microchip,miv-ihc-remote-context-id",
+				   &ihc->remote_context_id);
+	if (ret) {
+		return dev_err_probe(dev, ret,
+				     "missing microchip,miv-ihc-remote-context-id property\n");
+	}
+
+	ret = ihc_sbi_init(ihc->remote_context_id);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Context init failed\n");
+
+	ihc->channel.con_priv = ihc;
+	ihc->dev = dev;
+
+	ihc->controller.txdone_irq = true;
+	ihc->controller.dev = ihc->dev;
+	ihc->controller.ops = &miv_ihc_ops;
+	ihc->controller.chans = &ihc->channel;
+	ihc->controller.num_chans = 1;
+
+	ihc->irq = platform_get_irq(pdev, 0);
+	if (ihc->irq < 0)
+		return dev_err_probe(dev, ihc->irq, "unable to get IRQ\n");
+
+	ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(39));
+	if (ret)
+		return dev_err_probe(dev, ret, "dma_set_mask_and_coherent failed\n");
+
+	ihc->pool = dma_pool_create("ihc", dev, IHC_MAX_MESSAGE_SIZE, 0, 0);
+	if (!ihc->pool)
+		return dev_err_probe(dev, PTR_ERR(ihc->pool), "failed to create dma pool\n");
+
+	ihc->buf_base = dma_pool_alloc(ihc->pool, GFP_KERNEL, &ihc->dma_addr);
+	if (!ihc->buf_base) {
+		dma_pool_destroy(ihc->pool);
+		return dev_err_probe(dev, PTR_ERR(ihc->buf_base),
+				     "failed to allocate memory for dma pool\n");
+	}
+
+	ret = devm_mbox_controller_register(dev, &ihc->controller);
+	if (ret) {
+		dma_pool_free(ihc->pool, ihc->buf_base, ihc->dma_addr);
+		dma_pool_destroy(ihc->pool);
+		return dev_err_probe(dev, ret,
+				     "Mi-V inter-hart communication (IHC) registration failed\n");
+	}
+
+	dev_info(&pdev->dev, "Mi-V inter-hart communication (IHC) registered\n");
+	return 0;
+}
+
+static int ihc_remove(struct platform_device *pdev)
+{
+	struct miv_ihc *ihc = platform_get_drvdata(pdev);
+
+	dma_pool_free(ihc->pool, ihc->buf_base, ihc->dma_addr);
+	dma_pool_destroy(ihc->pool);
+
+	return 0;
+}
+
+static const struct of_device_id ihc_of_match[] = {
+	{ .compatible = "microchip,miv-ihc", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, ihc_of_match);
+
+static struct platform_driver miv_ihc_driver = {
+	.driver = {
+		.name = "miv_ihc",
+		.of_match_table = ihc_of_match
+	},
+	.probe = ihc_probe,
+	.remove = ihc_remove,
+};
+
+module_platform_driver(miv_ihc_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Valentina Fernandez <valentina.fernandezalanis@microchip.com>");
+MODULE_DESCRIPTION("Mi-V Inter-Hart Communication (IHC) driver");
--- linux-6.6.51/drivers/mailbox/mailbox-mpfs.c	2024-12-05 13:07:47.206465700 +0900
+++ linux4microchip-fpga-2024.09/drivers/mailbox/mailbox-mpfs.c	2024-12-04 16:41:27.383703800 +0900
@@ -13,12 +13,15 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
+#include <linux/regmap.h>
 #include <linux/interrupt.h>
+#include <linux/mfd/syscon.h>
 #include <linux/mod_devicetable.h>
 #include <linux/platform_device.h>
 #include <linux/mailbox_controller.h>
 #include <soc/microchip/mpfs.h>
 
+#define MESSAGE_INT_OFFSET		0x18cu
 #define SERVICES_CR_OFFSET		0x50u
 #define SERVICES_SR_OFFSET		0x54u
 #define MAILBOX_REG_OFFSET		0x800u
@@ -68,6 +71,7 @@
 	void __iomem *int_reg;
 	struct mbox_chan chans[1];
 	struct mpfs_mss_response *response;
+	struct regmap *sysreg_scb, *control_scb;
 	u16 resp_offset;
 };
 
@@ -75,7 +79,10 @@
 {
 	u32 status;
 
-	status = readl_relaxed(mbox->ctrl_base + SERVICES_SR_OFFSET);
+	if (mbox->control_scb)
+		regmap_read(mbox->control_scb, SERVICES_SR_OFFSET, &status);
+	else
+		status = readl_relaxed(mbox->ctrl_base + SERVICES_SR_OFFSET);
 
 	return status & SCB_STATUS_BUSY_MASK;
 }
@@ -95,7 +102,11 @@
 	 * Failed services are intended to generated interrupts, but in reality
 	 * this does not happen, so the status must be checked here.
 	 */
-	val = readl_relaxed(mbox->ctrl_base + SERVICES_SR_OFFSET);
+	if (mbox->control_scb)
+		regmap_read(mbox->control_scb, SERVICES_SR_OFFSET, &val);
+	else
+		val = readl_relaxed(mbox->ctrl_base + SERVICES_SR_OFFSET);
+
 	response->resp_status = (val & SCB_STATUS_MASK) >> SCB_STATUS_POS;
 
 	return true;
@@ -143,7 +154,12 @@
 
 	tx_trigger = (opt_sel << SCB_CTRL_POS) & SCB_CTRL_MASK;
 	tx_trigger |= SCB_CTRL_REQ_MASK | SCB_STATUS_NOTIFY_MASK;
-	writel_relaxed(tx_trigger, mbox->ctrl_base + SERVICES_CR_OFFSET);
+
+	if (mbox->control_scb)
+		regmap_write(mbox->control_scb, SERVICES_CR_OFFSET, tx_trigger);
+	else
+		writel_relaxed(tx_trigger, mbox->ctrl_base + SERVICES_CR_OFFSET);
+
 
 	return 0;
 }
@@ -185,7 +201,10 @@
 	struct mbox_chan *chan = data;
 	struct mpfs_mbox *mbox = (struct mpfs_mbox *)chan->con_priv;
 
-	writel_relaxed(0, mbox->int_reg);
+	if (mbox->control_scb)
+		regmap_write(mbox->sysreg_scb, MESSAGE_INT_OFFSET, 0);
+	else
+		writel_relaxed(0, mbox->int_reg);
 
 	mpfs_mbox_rx_data(chan);
 
@@ -231,6 +250,23 @@
 	if (!mbox)
 		return -ENOMEM;
 
+	mbox->control_scb = syscon_regmap_lookup_by_compatible("microchip,mpfs-control-scb");
+	if (IS_ERR(mbox->control_scb)) {
+		mbox->control_scb = NULL;
+		goto old_format;
+	}
+
+	mbox->sysreg_scb = syscon_regmap_lookup_by_compatible("microchip,mpfs-sysreg-scb");
+	if (IS_ERR(mbox->sysreg_scb))
+		return PTR_ERR(mbox->sysreg_scb);
+
+	mbox->mbox_base = devm_platform_get_and_ioremap_resource(pdev, 0, &regs);
+	if (IS_ERR(mbox->ctrl_base))
+		return PTR_ERR(mbox->mbox_base);
+
+	goto done;
+
+old_format:
 	mbox->ctrl_base = devm_platform_get_and_ioremap_resource(pdev, 0, &regs);
 	if (IS_ERR(mbox->ctrl_base))
 		return PTR_ERR(mbox->ctrl_base);
@@ -243,6 +279,7 @@
 	if (IS_ERR(mbox->mbox_base)) // account for the old dt-binding w/ 2 regs
 		mbox->mbox_base = mbox->ctrl_base + MAILBOX_REG_OFFSET;
 
+done:
 	mbox->irq = platform_get_irq(pdev, 0);
 	if (mbox->irq < 0)
 		return mbox->irq;
@@ -262,6 +299,7 @@
 		dev_err(&pdev->dev, "Registering MPFS mailbox controller failed\n");
 		return ret;
 	}
+
 	dev_info(&pdev->dev, "Registered MPFS mailbox controller driver\n");
 
 	return 0;
--- /dev/null
+++ linux4microchip-fpga-2024.09/include/dt-bindings/mailbox/miv-ihc.h	2024-12-04 16:41:37.014936400 +0900
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause */
+/*
+ * Copyright (c) 2021 Microchip Technology Inc. All rights reserved.
+ */
+
+#ifndef __DT_BINDINGS_MIV_IHC_H
+#define __DT_BINDINGS_MIV_IHC_H
+
+#define IHC_CONTEXT_A	5
+#define IHC_CONTEXT_B	6
+
+#define IHC_HART1_INT	180
+#define IHC_HART2_INT	179
+#define IHC_HART3_INT	178
+#define IHC_HART4_INT	177
+
+#endif
--- /dev/null
+++ linux4microchip-fpga-2024.09/include/linux/mailbox/mchp-ipc.h	2024-12-04 16:41:37.556487600 +0900
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ *Copyright (c) 2024 Microchip Technology Inc. All rights reserved.
+ */
+
+#ifndef _LINUX_MCHP_IPC_H_
+#define _LINUX_MCHP_IPC_H_
+
+#include <linux/mailbox_controller.h>
+#include <linux/types.h>
+
+struct mchp_ipc_msg {
+	u32 *buf;
+	u16 size;
+};
+
+#if IS_ENABLED(CONFIG_MCHP_SBI_IPC_MBOX)
+u32 mchp_ipc_get_chan_id(struct mbox_chan *chan);
+#else
+u32 mchp_ipc_get_chan_id(struct mbox_chan *chan) { return 0; }
+#endif
+
+#endif /* _LINUX_MCHP_IPC_H_ */
--- /dev/null
+++ linux4microchip-fpga-2024.09/include/linux/mailbox/miv_ihc.h	2024-12-04 16:41:37.557485200 +0900
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ *Copyright (c) 2021 Microchip Technology Inc. All rights reserved.
+ */
+
+#ifndef _LINUX_MIV_IHC_H_
+#define _LINUX_MIV_IHC_H_
+
+#include <linux/mailbox_controller.h>
+#include <linux/types.h>
+
+/* Data structure for data-transfer protocol */
+#define IHC_MAX_MESSAGE_SIZE 4U
+
+enum {
+	SBI_EXT_IHC_INIT,
+	SBI_EXT_IHC_TX,
+	SBI_EXT_IHC_RX,
+	SBI_EXT_RPROC_STATE,
+	SBI_EXT_RPROC_START,
+	SBI_EXT_RPROC_STOP,
+};
+
+struct miv_ihc_msg {
+	u32 msg[IHC_MAX_MESSAGE_SIZE];
+};
+
+struct miv_ihc {
+	struct device *dev;
+	void *buf_base;
+	struct dma_pool *pool;
+	struct mbox_controller controller;
+	struct mbox_chan channel;
+	int irq;
+	dma_addr_t dma_addr;
+	u32 remote_context_id;
+};
+
+#endif /* _LINUX_MIV_IHC_H_ */
