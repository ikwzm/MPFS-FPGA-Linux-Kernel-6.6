--- linux-6.6.51/Documentation/devicetree/bindings/clock/microchip,mpfs-ccc.yaml	2024-12-05 13:07:30.423854900 +0900
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/clock/microchip,mpfs-ccc.yaml	2024-12-04 16:41:09.519236400 +0900
@@ -17,7 +17,11 @@
 
 properties:
   compatible:
-    const: microchip,mpfs-ccc
+    oneOf:
+      - items:
+          - const: microchip,pic64gx-ccc
+          - const: microchip,mpfs-ccc
+      - const: microchip,mpfs-ccc
 
   reg:
     items:
--- linux-6.6.51/Documentation/devicetree/bindings/clock/microchip,mpfs-clkcfg.yaml	2024-12-05 13:07:30.423854900 +0900
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/clock/microchip,mpfs-clkcfg.yaml	2024-12-04 16:41:09.520233700 +0900
@@ -19,19 +19,30 @@
 
 properties:
   compatible:
-    const: microchip,mpfs-clkcfg
+    oneOf:
+      - items:
+          - const: microchip,pic64gx-clkcfg
+          - const: microchip,mpfs-clkcfg
+      - const: microchip,mpfs-clkcfg
 
   reg:
-    items:
-      - description: |
-          clock config registers:
-          These registers contain enable, reset & divider tables for the, cpu,
-          axi, ahb and rtc/mtimer reference clocks as well as enable and reset
-          for the peripheral clocks.
-      - description: |
-          mss pll dri registers:
-          Block of registers responsible for dynamic reconfiguration of the mss
-          pll
+    oneOf:
+      - items:
+          - description: |
+              clock config registers:
+              These registers contain enable, reset & divider tables for the, cpu,
+              axi, ahb and rtc/mtimer reference clocks as well as enable and reset
+              for the peripheral clocks.
+          - description: |
+              mss pll dri registers:
+              Block of registers responsible for dynamic reconfiguration of the mss
+              pll
+      - items:
+          - description: |
+              mss pll dri registers:
+              Block of registers responsible for dynamic reconfiguration of the mss
+              pll
+
 
   clocks:
     maxItems: 1
@@ -69,11 +80,12 @@
   - |
     #include <dt-bindings/clock/microchip,mpfs-clock.h>
     soc {
-            #address-cells = <2>;
-            #size-cells = <2>;
-            clkcfg: clock-controller@20002000 {
+            #address-cells = <1>;
+            #size-cells = <1>;
+
+            clkcfg: clock-controller@3E001000 {
                 compatible = "microchip,mpfs-clkcfg";
-                reg = <0x0 0x20002000 0x0 0x1000>, <0x0 0x3E001000 0x0 0x1000>;
+                reg = <0x3E001000 0x1000>;
                 clocks = <&ref>;
                 #clock-cells = <1>;
         };
--- /dev/null
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/display/bridge/microchip,sam9x7-lvds.yaml	2024-12-04 16:41:09.656868300 +0900
@@ -0,0 +1,59 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/bridge/microchip,sam9x7-lvds.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Microchip SAM9X7 LVDS Controller
+
+maintainers:
+  - Dharma Balasubiramani <dharma.b@microchip.com>
+
+description: |
+  The Low Voltage Differential Signaling Controller (LVDSC) manages data
+  format conversion from the LCD Controller internal DPI bus to OpenLDI
+  LVDS output signals. LVDSC functions include bit mapping, balanced mode
+  management, and serializer.
+
+properties:
+  compatible:
+    const: microchip,sam9x7-lvds
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    items:
+      - description: Peripheral Bus Clock
+
+  clock-names:
+    items:
+      - const: pclk
+      - const: gclk
+    minItems: 1
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - clocks
+  - clock-names
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/at91.h>
+    #include <dt-bindings/dma/at91.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+
+    lvds-controller@f8060000 {
+      compatible = "microchip,sam9x7-lvds";
+      reg = <0xf8060000 0x100>;
+      interrupts = <56 IRQ_TYPE_LEVEL_HIGH 0>;
+      clocks = <&pmc PMC_TYPE_PERIPHERAL 56>;
+      clock-names = "pclk";
+    };
--- /dev/null
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/display/bridge/microchip,sam9x75-mipi-dsi.yaml	2024-12-04 16:41:09.657865500 +0900
@@ -0,0 +1,136 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/bridge/microchip,sam9x75-mipi-dsi.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Microchip SAM9X75 MIPI DSI Controller
+
+maintainers:
+  - Manikandan Muralidharan <manikandan.m@microchip.com>
+
+description:
+  Microchip specific extensions or wrapper to the Synopsys Designware MIPI DSI.
+  The MIPI Display Serial Interface (DSI) Host Controller implements all
+  protocol functions defined in the MIPI DSI Specification. The DSI Host
+  provides an interface between the LCD Controller (LCDC) and the MIPI D-PHY,
+  allowing communication with a DSI-compliant display.
+
+allOf:
+  - $ref: /schemas/display/dsi-controller.yaml#
+
+properties:
+  compatible:
+    const: microchip,sam9x75-mipi-dsi
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    description:
+      MIPI DSI must have two clocks to function correctly.Peripheral clock
+      'pclk' for the hardware block functionality and Generic clock 'refclk' to
+      drive the D-PHY PLL block.
+    minItems: 2
+
+  clock-names:
+    items:
+      - const: pclk
+      - const: refclk
+
+  microchip,sfr:
+    $ref: /schemas/types.yaml#/definitions/phandle
+    description:
+      phandle to Special Function Register (SFR) node.To enable the DSI/CSI
+      selection bit in SFR's ISS Configuration Register.
+
+  ports:
+    $ref: /schemas/graph.yaml#/properties/ports
+
+    properties:
+      port@0:
+        $ref: /schemas/graph.yaml#/$defs/port-base
+        unevaluatedProperties: false
+        description:
+          DSI Input port node, connected to the LCDC RGB output port.
+
+        properties:
+          endpoint:
+            $ref: /schemas/media/video-interfaces.yaml#
+            unevaluatedProperties: false
+            properties:
+              remote-endpoint: true
+
+      port@1:
+        $ref: /schemas/graph.yaml#/$defs/port-base
+        unevaluatedProperties: false
+        description:
+          DSI Output port node, connected to a panel or a bridge input port.
+
+        properties:
+          endpoint:
+            $ref: /schemas/media/video-interfaces.yaml#
+            unevaluatedProperties: false
+            properties:
+              remote-endpoint: true
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - clock-names
+  - ports
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/at91.h>
+    #include <dt-bindings/gpio/gpio.h>
+
+    dsi: dsi@f8054000 {
+         compatible = "microchip,sam9x75-mipi-dsi";
+         reg = <0xf8054000 0x200>;
+         clocks = <&pmc PMC_TYPE_PERIPHERAL 54>, <&pmc PMC_TYPE_GCK 55>;
+         clock-names = "pclk", "refclk";
+         microchip,sfr = <&sfr>;
+
+         #address-cells = <1>;
+         #size-cells = <0>;
+
+         ports {
+                #address-cells = <1>;
+                #size-cells = <0>;
+
+                port@0 {
+                        reg = <0>;
+                        dsi_in: endpoint {
+                            remote-endpoint = <&hlcdc_panel_output>;
+                        };
+                };
+
+                port@1 {
+                        reg = <1>;
+                        dsi_out: endpoint {
+                            remote-endpoint = <&mipi_in_panel>;
+                        };
+                };
+         };
+
+         panel@0 {
+              compatible = "hannstar,hsd060bhw4", "himax,hx8394";
+              reg = <0>;
+              vcc-supply = <&mic23150_reg>;
+              iovcc-supply = <&mic23150_reg>;
+              reset-gpios = <&pioC 24 GPIO_ACTIVE_LOW>;
+              backlight = <&backlight>;
+
+              port {
+                   mipi_in_panel: endpoint {
+                        remote-endpoint = <&dsi_out>;
+                   };
+              };
+         };
+    };
+
+...
--- linux-6.6.51/Documentation/devicetree/bindings/rtc/microchip,mfps-rtc.yaml	2024-12-05 13:07:31.630626300 +0900
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/rtc/microchip,mfps-rtc.yaml	2024-12-04 16:41:10.946418100 +0900
@@ -16,8 +16,11 @@
 
 properties:
   compatible:
-    enum:
-      - microchip,mpfs-rtc
+    oneOf:
+      - items:
+          - const: microchip,pic64gx-rtc
+          - const: microchip,mpfs-rtc
+      - const: microchip,mpfs-rtc
 
   reg:
     maxItems: 1
--- linux-6.6.51/drivers/clk/Kconfig	2024-12-05 13:07:40.519846800 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/Kconfig	2024-12-04 16:41:19.900462500 +0900
@@ -33,6 +33,10 @@
 
 if COMMON_CLK
 
+config COMMON_CLK_REGMAP
+	bool
+	select REGMAP
+
 config COMMON_CLK_WM831X
 	tristate "Clock driver for WM831x/2x PMICs"
 	depends on MFD_WM831X
--- linux-6.6.51/drivers/clk/Makefile	2024-12-05 13:07:40.519846800 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/Makefile	2024-12-04 16:41:19.900462500 +0900
@@ -10,6 +10,7 @@
 obj-$(CONFIG_CLK_GATE_KUNIT_TEST) += clk-gate_test.o
 obj-$(CONFIG_COMMON_CLK)	+= clk-multiplier.o
 obj-$(CONFIG_COMMON_CLK)	+= clk-mux.o
+obj-$(CONFIG_COMMON_CLK_REGMAP)	+= clk-regmap.o
 obj-$(CONFIG_COMMON_CLK)	+= clk-composite.o
 obj-$(CONFIG_COMMON_CLK)	+= clk-fractional-divider.o
 obj-$(CONFIG_COMMON_CLK)	+= clk-gpio.o
--- linux-6.6.51/drivers/clk/at91/Makefile	2024-12-05 13:07:40.528822900 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/at91/Makefile	2024-12-04 16:41:19.909438500 +0900
@@ -20,6 +20,7 @@
 obj-$(CONFIG_SOC_AT91SAM9) += at91sam9g45.o dt-compat.o
 obj-$(CONFIG_SOC_AT91SAM9) += at91sam9n12.o at91sam9x5.o dt-compat.o
 obj-$(CONFIG_SOC_SAM9X60) += sam9x60.o
+obj-$(CONFIG_SOC_SAM9X7) += sam9x7.o
 obj-$(CONFIG_SOC_SAMA5D3) += sama5d3.o dt-compat.o
 obj-$(CONFIG_SOC_SAMA5D4) += sama5d4.o dt-compat.o
 obj-$(CONFIG_SOC_SAMA5D2) += sama5d2.o dt-compat.o
--- linux-6.6.51/drivers/clk/at91/clk-master.c	2024-12-05 13:07:40.532812100 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/at91/clk-master.c	2024-12-04 16:41:19.913427900 +0900
@@ -580,6 +580,9 @@
 {
 	struct clk_master *master = to_clk_master(hw);
 
+	if (master->div == MASTER_PRES_MAX)
+		return DIV_ROUND_CLOSEST_ULL(parent_rate, 3);
+
 	return DIV_ROUND_CLOSEST_ULL(parent_rate, (1 << master->div));
 }
 
--- linux-6.6.51/drivers/clk/at91/clk-sam9x60-pll.c	2024-12-05 13:07:40.534806700 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/at91/clk-sam9x60-pll.c	2024-12-04 16:41:19.921406500 +0900
@@ -23,9 +23,6 @@
 #define UPLL_DIV		2
 #define PLL_MUL_MAX		(FIELD_GET(PMC_PLL_CTRL1_MUL_MSK, UINT_MAX) + 1)
 
-#define FCORE_MIN		(600000000)
-#define FCORE_MAX		(1200000000)
-
 #define PLL_MAX_ID		7
 
 struct sam9x60_pll_core {
@@ -76,9 +73,15 @@
 {
 	struct sam9x60_pll_core *core = to_sam9x60_pll_core(hw);
 	struct sam9x60_frac *frac = to_sam9x60_frac(core);
+	unsigned long freq;
 
-	return parent_rate * (frac->mul + 1) +
+	freq = parent_rate * (frac->mul + 1) +
 		DIV_ROUND_CLOSEST_ULL((u64)parent_rate * frac->frac, (1 << 22));
+
+	if (core->layout->div2)
+		freq >>= 1;
+
+	return freq;
 }
 
 static int sam9x60_frac_pll_set(struct sam9x60_pll_core *core)
@@ -194,7 +197,8 @@
 	unsigned long nmul = 0;
 	unsigned long nfrac = 0;
 
-	if (rate < FCORE_MIN || rate > FCORE_MAX)
+	if (rate < core->characteristics->core_output[0].min ||
+	    rate > core->characteristics->core_output[0].max)
 		return -ERANGE;
 
 	/*
@@ -214,7 +218,8 @@
 	}
 
 	/* Check if resulted rate is a valid.  */
-	if (tmprate < FCORE_MIN || tmprate > FCORE_MAX)
+	if (tmprate < core->characteristics->core_output[0].min ||
+	    tmprate > core->characteristics->core_output[0].max)
 		return -ERANGE;
 
 	if (update) {
@@ -433,6 +438,12 @@
 	return DIV_ROUND_CLOSEST_ULL(parent_rate, (div->div + 1));
 }
 
+static unsigned long sam9x60_fixed_div_pll_recalc_rate(struct clk_hw *hw,
+						       unsigned long parent_rate)
+{
+	return parent_rate >> 1;
+}
+
 static long sam9x60_div_pll_compute_div(struct sam9x60_pll_core *core,
 					unsigned long *parent_rate,
 					unsigned long rate)
@@ -607,6 +618,16 @@
 	.restore_context = sam9x60_div_pll_restore_context,
 };
 
+static const struct clk_ops sam9x60_fixed_div_pll_ops = {
+	.prepare = sam9x60_div_pll_prepare,
+	.unprepare = sam9x60_div_pll_unprepare,
+	.is_prepared = sam9x60_div_pll_is_prepared,
+	.recalc_rate = sam9x60_fixed_div_pll_recalc_rate,
+	.round_rate = sam9x60_div_pll_round_rate,
+	.save_context = sam9x60_div_pll_save_context,
+	.restore_context = sam9x60_div_pll_restore_context,
+};
+
 struct clk_hw * __init
 sam9x60_clk_register_frac_pll(struct regmap *regmap, spinlock_t *lock,
 			      const char *name, const char *parent_name,
@@ -669,7 +690,8 @@
 			goto free;
 		}
 
-		ret = sam9x60_frac_pll_compute_mul_frac(&frac->core, FCORE_MIN,
+		ret = sam9x60_frac_pll_compute_mul_frac(&frac->core,
+							characteristics->core_output[0].min,
 							parent_rate, true);
 		if (ret < 0) {
 			hw = ERR_PTR(ret);
@@ -725,10 +747,16 @@
 	else
 		init.parent_names = &parent_name;
 	init.num_parents = 1;
-	if (flags & CLK_SET_RATE_GATE)
-		init.ops = &sam9x60_div_pll_ops;
-	else
-		init.ops = &sam9x60_div_pll_ops_chg;
+
+	if (layout->div2) {
+		init.ops = &sam9x60_fixed_div_pll_ops;
+	} else {
+		if (flags & CLK_SET_RATE_GATE)
+			init.ops = &sam9x60_div_pll_ops;
+		else
+			init.ops = &sam9x60_div_pll_ops_chg;
+	}
+
 	init.flags = flags;
 
 	div->core.id = id;
--- linux-6.6.51/drivers/clk/at91/pmc.h	2024-12-05 13:07:40.539793400 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/at91/pmc.h	2024-12-04 16:41:19.923401100 +0900
@@ -64,6 +64,7 @@
 	u8 frac_shift;
 	u8 div_shift;
 	u8 endiv_shift;
+	u8 div2;
 };
 
 extern const struct clk_pll_layout at91rm9200_pll_layout;
@@ -75,6 +76,7 @@
 	struct clk_range input;
 	int num_output;
 	const struct clk_range *output;
+	const struct clk_range *core_output;
 	u16 *icpll;
 	u8 *out;
 	u8 upll : 1;
--- linux-6.6.51/drivers/clk/at91/sam9x60.c	2024-12-05 13:07:40.539793400 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/at91/sam9x60.c	2024-12-04 16:41:19.924398400 +0900
@@ -26,10 +26,16 @@
 	{ .min = 2343750, .max = 1200000000 },
 };
 
+/* Fractional PLL core output range. */
+static const struct clk_range core_outputs[] = {
+	{ .min = 600000000, .max = 1200000000 },
+};
+
 static const struct clk_pll_characteristics plla_characteristics = {
 	.input = { .min = 12000000, .max = 48000000 },
 	.num_output = ARRAY_SIZE(plla_outputs),
 	.output = plla_outputs,
+	.core_output = core_outputs,
 };
 
 static const struct clk_range upll_outputs[] = {
@@ -40,6 +46,7 @@
 	.input = { .min = 12000000, .max = 48000000 },
 	.num_output = ARRAY_SIZE(upll_outputs),
 	.output = upll_outputs,
+	.core_output = core_outputs,
 	.upll = true,
 };
 
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/clk/at91/sam9x7.c	2024-12-04 16:41:19.925395800 +0900
@@ -0,0 +1,962 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * SAM9X7 PMC code.
+ *
+ * Copyright (C) 2022 Microchip Technology Inc. and its subsidiaries
+ *
+ * Author: Varshini Rajendran <varshini.rajendran@microchip.com>
+ *
+ */
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/mfd/syscon.h>
+#include <linux/slab.h>
+
+#include <dt-bindings/clock/at91.h>
+
+#include "pmc.h"
+
+#define SAM9X7_INIT_TABLE(_table, _count)		\
+	do {						\
+		u8 _i;					\
+		for (_i = 0; _i < (_count); _i++)	\
+			(_table)[_i] = _i;		\
+	} while (0)
+
+#define SAM9X7_FILL_TABLE(_to, _from, _count)		\
+	do {						\
+		u8 _i;					\
+		for (_i = 0; _i < (_count); _i++) {	\
+			(_to)[_i] = (_from)[_i];	\
+		}					\
+	} while (0)
+
+static DEFINE_SPINLOCK(pmc_pll_lock);
+static DEFINE_SPINLOCK(mck_lock);
+
+/**
+ * enum pll_ids - PLL clocks identifiers
+ * @PLL_ID_PLLA:	PLLA identifier
+ * @PLL_ID_UPLL:	UPLL identifier
+ * @PLL_ID_AUDIO:	Audio PLL identifier
+ * @PLL_ID_LVDS:	LVDS PLL identifier
+ * @PLL_ID_PLLA_DIV2:	PLLA DIV2 identifier
+ * @PLL_ID_MAX:		Max PLL Identifier
+ */
+enum pll_ids {
+	PLL_ID_PLLA,
+	PLL_ID_UPLL,
+	PLL_ID_AUDIO,
+	PLL_ID_LVDS,
+	PLL_ID_PLLA_DIV2,
+	PLL_ID_MAX,
+};
+
+/**
+ * enum pll_type - PLL type identifiers
+ * @PLL_TYPE_FRAC:	fractional PLL identifier
+ * @PLL_TYPE_DIV:	divider PLL identifier
+ */
+enum pll_type {
+	PLL_TYPE_FRAC,
+	PLL_TYPE_DIV,
+};
+
+static const struct clk_master_characteristics mck_characteristics = {
+	.output = { .min = 32000000, .max = 266666667 },
+	.divisors = { 1, 2, 4, 3, 5},
+	.have_div3_pres = 1,
+};
+
+static const struct clk_master_layout sam9x7_master_layout = {
+	.mask = 0x373,
+	.pres_shift = 4,
+	.offset = 0x28,
+};
+
+/* Fractional PLL core output range. */
+static const struct clk_range plla_core_outputs[] = {
+	{ .min = 375000000, .max = 1600000000 },
+};
+
+static const struct clk_range upll_core_outputs[] = {
+	{ .min = 600000000, .max = 1200000000 },
+};
+
+static const struct clk_range lvdspll_core_outputs[] = {
+	{ .min = 400000000, .max = 800000000 },
+};
+
+static const struct clk_range audiopll_core_outputs[] = {
+	{ .min = 400000000, .max = 800000000 },
+};
+
+static const struct clk_range plladiv2_core_outputs[] = {
+	{ .min = 375000000, .max = 1600000000 },
+};
+
+/* Fractional PLL output range. */
+static const struct clk_range plla_outputs[] = {
+	{ .min = 732421, .max = 800000000 },
+};
+
+static const struct clk_range upll_outputs[] = {
+	{ .min = 300000000, .max = 600000000 },
+};
+
+static const struct clk_range lvdspll_outputs[] = {
+	{ .min = 10000000, .max = 800000000 },
+};
+
+static const struct clk_range audiopll_outputs[] = {
+	{ .min = 10000000, .max = 800000000 },
+};
+
+static const struct clk_range plladiv2_outputs[] = {
+	{ .min = 366210, .max = 400000000 },
+};
+
+/* PLL characteristics. */
+static const struct clk_pll_characteristics plla_characteristics = {
+	.input = { .min = 20000000, .max = 50000000 },
+	.num_output = ARRAY_SIZE(plla_outputs),
+	.output = plla_outputs,
+	.core_output = plla_core_outputs,
+};
+
+static const struct clk_pll_characteristics upll_characteristics = {
+	.input = { .min = 20000000, .max = 50000000 },
+	.num_output = ARRAY_SIZE(upll_outputs),
+	.output = upll_outputs,
+	.core_output = upll_core_outputs,
+	.upll = true,
+};
+
+static const struct clk_pll_characteristics lvdspll_characteristics = {
+	.input = { .min = 20000000, .max = 50000000 },
+	.num_output = ARRAY_SIZE(lvdspll_outputs),
+	.output = lvdspll_outputs,
+	.core_output = lvdspll_core_outputs,
+};
+
+static const struct clk_pll_characteristics audiopll_characteristics = {
+	.input = { .min = 20000000, .max = 50000000 },
+	.num_output = ARRAY_SIZE(audiopll_outputs),
+	.output = audiopll_outputs,
+	.core_output = audiopll_core_outputs,
+};
+
+static const struct clk_pll_characteristics plladiv2_characteristics = {
+	.input = { .min = 20000000, .max = 50000000 },
+	.num_output = ARRAY_SIZE(plladiv2_outputs),
+	.output = plladiv2_outputs,
+	.core_output = plladiv2_core_outputs,
+};
+
+/* Layout for fractional PLL ID PLLA. */
+static const struct clk_pll_layout plla_frac_layout = {
+	.mul_mask = GENMASK(31, 24),
+	.frac_mask = GENMASK(21, 0),
+	.mul_shift = 24,
+	.frac_shift = 0,
+	.div2 = 1,
+};
+
+/* Layout for fractional PLLs. */
+static const struct clk_pll_layout pll_frac_layout = {
+	.mul_mask = GENMASK(31, 24),
+	.frac_mask = GENMASK(21, 0),
+	.mul_shift = 24,
+	.frac_shift = 0,
+};
+
+/* Layout for DIV PLLs. */
+static const struct clk_pll_layout pll_divpmc_layout = {
+	.div_mask = GENMASK(7, 0),
+	.endiv_mask = BIT(29),
+	.div_shift = 0,
+	.endiv_shift = 29,
+};
+
+/* Layout for DIV PLL ID PLLADIV2. */
+static const struct clk_pll_layout plladiv2_divpmc_layout = {
+	.div_mask = GENMASK(7, 0),
+	.endiv_mask = BIT(29),
+	.div_shift = 0,
+	.endiv_shift = 29,
+	.div2 = 1,
+};
+
+/* Layout for DIVIO dividers. */
+static const struct clk_pll_layout pll_divio_layout = {
+	.div_mask	= GENMASK(19, 12),
+	.endiv_mask	= BIT(30),
+	.div_shift	= 12,
+	.endiv_shift	= 30,
+};
+
+/*
+ * PLL clocks description
+ * @n:		clock name
+ * @p:		clock parent
+ * @l:		clock layout
+ * @t:		clock type
+ * @c:		pll characteristics
+ * @f:		true if clock is critical and cannot be disabled
+ * @eid:	export index in sam9x7->chws[] array
+ */
+static const struct {
+	const char *n;
+	const char *p;
+	const struct clk_pll_layout *l;
+	u8 t;
+	const struct clk_pll_characteristics *c;
+	unsigned long f;
+	u8 eid;
+} sam9x7_plls[][PLL_ID_MAX] = {
+	[PLL_ID_PLLA] = {
+		{
+			.n = "plla_fracck",
+			.p = "mainck",
+			.l = &plla_frac_layout,
+			.t = PLL_TYPE_FRAC,
+			/*
+			 * This feeds plla_divpmcck which feeds CPU. It should
+			 * not be disabled.
+			 */
+			.f = CLK_IS_CRITICAL | CLK_SET_RATE_GATE,
+			.c = &plla_characteristics,
+		},
+
+		{
+			.n = "plla_divpmcck",
+			.p = "plla_fracck",
+			.l = &pll_divpmc_layout,
+			.t = PLL_TYPE_DIV,
+			/* This feeds CPU. It should not be disabled */
+			.f = CLK_IS_CRITICAL | CLK_SET_RATE_GATE,
+			.eid = PMC_PLLACK,
+			.c = &plla_characteristics,
+		},
+	},
+
+	[PLL_ID_UPLL] = {
+		{
+			.n = "upll_fracck",
+			.p = "main_osc",
+			.l = &pll_frac_layout,
+			.t = PLL_TYPE_FRAC,
+			.f = CLK_SET_RATE_GATE,
+			.c = &upll_characteristics,
+		},
+
+		{
+			.n = "upll_divpmcck",
+			.p = "upll_fracck",
+			.l = &pll_divpmc_layout,
+			.t = PLL_TYPE_DIV,
+			.f = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE |
+			     CLK_SET_RATE_PARENT,
+			.eid = PMC_UTMI,
+			.c = &upll_characteristics,
+		},
+	},
+
+	[PLL_ID_AUDIO] = {
+		{
+			.n = "audiopll_fracck",
+			.p = "main_osc",
+			.l = &pll_frac_layout,
+			.f = CLK_SET_RATE_GATE,
+			.c = &audiopll_characteristics,
+			.t = PLL_TYPE_FRAC,
+		},
+
+		{
+			.n = "audiopll_divpmcck",
+			.p = "audiopll_fracck",
+			.l = &pll_divpmc_layout,
+			.f = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE |
+			     CLK_SET_RATE_PARENT,
+			.c = &audiopll_characteristics,
+			.eid = PMC_AUDIOPMCPLL,
+			.t = PLL_TYPE_DIV,
+		},
+
+		{
+			.n = "audiopll_diviock",
+			.p = "audiopll_fracck",
+			.l = &pll_divio_layout,
+			.f = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE |
+			     CLK_SET_RATE_PARENT,
+			.c = &audiopll_characteristics,
+			.eid = PMC_AUDIOIOPLL,
+			.t = PLL_TYPE_DIV,
+		},
+	},
+
+	[PLL_ID_LVDS] = {
+		{
+			.n = "lvdspll_fracck",
+			.p = "main_osc",
+			.l = &pll_frac_layout,
+			.f = CLK_SET_RATE_GATE,
+			.c = &lvdspll_characteristics,
+			.t = PLL_TYPE_FRAC,
+		},
+
+		{
+			.n = "lvdspll_divpmcck",
+			.p = "lvdspll_fracck",
+			.l = &pll_divpmc_layout,
+			.f = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE |
+			     CLK_SET_RATE_PARENT,
+			.c = &lvdspll_characteristics,
+			.eid = PMC_LVDSPLL,
+			.t = PLL_TYPE_DIV,
+		},
+	},
+
+	[PLL_ID_PLLA_DIV2] = {
+		{
+			.n = "plla_div2pmcck",
+			.p = "plla_fracck",
+			.l = &plladiv2_divpmc_layout,
+			/*
+			 * This may feed critical parts of the system like timers.
+			 * It should not be disabled.
+			 */
+			.f = CLK_IS_CRITICAL | CLK_SET_RATE_GATE,
+			.c = &plladiv2_characteristics,
+			.eid = PMC_PLLADIV2,
+			.t = PLL_TYPE_DIV,
+		},
+	},
+};
+
+static const struct clk_programmable_layout sam9x7_programmable_layout = {
+	.pres_mask = 0xff,
+	.pres_shift = 8,
+	.css_mask = 0x1f,
+	.have_slck_mck = 0,
+	.is_pres_direct = 1,
+};
+
+static const struct clk_pcr_layout sam9x7_pcr_layout = {
+	.offset = 0x88,
+	.cmd = BIT(31),
+	.gckcss_mask = GENMASK(12, 8),
+	.pid_mask = GENMASK(6, 0),
+};
+
+static const struct {
+	char *n;
+	char *p;
+	u8 id;
+	unsigned long flags;
+} sam9x7_systemck[] = {
+	/*
+	 * ddrck feeds DDR controller and is enabled by bootloader thus we need
+	 * to keep it enabled in case there is no Linux consumer for it.
+	 */
+	{ .n = "ddrck",		.p = "masterck_div",	.id = 2,	.flags = CLK_IS_CRITICAL },
+	{ .n = "uhpck",		.p = "usbck",		.id = 6 },
+	{ .n = "pck0",		.p = "prog0",		.id = 8 },
+	{ .n = "pck1",		.p = "prog1",		.id = 9 },
+};
+
+/*
+ * Peripheral clocks description
+ * @n:		clock name
+ * @f:		true if clock is critical and cannot be disabled
+ * @id:		peripheral id
+ */
+static const struct {
+	char *n;
+	unsigned long f;
+	u8 id;
+} sam9x7_periphck[] = {
+	{ .n = "pioA_clk",	.id = 2, },
+	{ .n = "pioB_clk",	.id = 3, },
+	{ .n = "pioC_clk",	.id = 4, },
+	{ .n = "flex0_clk",	.id = 5, },
+	{ .n = "flex1_clk",	.id = 6, },
+	{ .n = "flex2_clk",	.id = 7, },
+	{ .n = "flex3_clk",	.id = 8, },
+	{ .n = "flex6_clk",	.id = 9, },
+	{ .n = "flex7_clk",	.id = 10, },
+	{ .n = "flex8_clk",	.id = 11, },
+	{ .n = "sdmmc0_clk",	.id = 12, },
+	{ .n = "flex4_clk",	.id = 13, },
+	{ .n = "flex5_clk",	.id = 14, },
+	{ .n = "flex9_clk",	.id = 15, },
+	{ .n = "flex10_clk",	.id = 16, },
+	{ .n = "tcb0_clk",	.id = 17, },
+	{ .n = "pwm_clk",	.id = 18, },
+	{ .n = "adc_clk",	.id = 19, },
+	{ .n = "dma0_clk",	.id = 20, },
+	{ .n = "uhphs_clk",	.id = 22, },
+	{ .n = "udphs_clk",	.id = 23, },
+	{ .n = "macb0_clk",	.id = 24, },
+	{ .n = "lcd_clk",	.id = 25, },
+	{ .n = "sdmmc1_clk",	.id = 26, },
+	{ .n = "ssc_clk",	.id = 28, },
+	{ .n = "can0_clk",	.id = 29, },
+	{ .n = "can1_clk",	.id = 30, },
+	{ .n = "flex11_clk",	.id = 32, },
+	{ .n = "flex12_clk",	.id = 33, },
+	{ .n = "i2s_clk",	.id = 34, },
+	{ .n = "qspi_clk",	.id = 35, },
+	{ .n = "gfx2d_clk",	.id = 36, },
+	{ .n = "pit64b0_clk",	.id = 37, },
+	{ .n = "trng_clk",	.id = 38, },
+	{ .n = "aes_clk",	.id = 39, },
+	{ .n = "tdes_clk",	.id = 40, },
+	{ .n = "sha_clk",	.id = 41, },
+	{ .n = "classd_clk",	.id = 42, },
+	{ .n = "isi_clk",	.id = 43, },
+	{ .n = "pioD_clk",	.id = 44, },
+	{ .n = "tcb1_clk",	.id = 45, },
+	{ .n = "dbgu_clk",	.id = 47, },
+	{ .n = "pmecc_clk",     .id = 48, },
+	/*
+	 * mpddr_clk feeds DDR controller and is enabled by bootloader thus we
+	 * need to keep it enabled in case there is no Linux consumer for it.
+	 */
+	{ .n = "mpddr_clk",	.id = 49,	.f = CLK_IS_CRITICAL },
+	{ .n = "csi2dc_clk",	.id = 52, },
+	{ .n = "csi4l_clk",	.id = 53, },
+	{ .n = "dsi4l_clk",	.id = 54, },
+	{ .n = "lvdsc_clk",	.id = 56, },
+	{ .n = "pit64b1_clk",	.id = 58, },
+	{ .n = "puf_clk",	.id = 59, },
+	{ .n = "gmactsu_clk",	.id = 67, },
+};
+
+/*
+ * Generic clock description
+ * @n:			clock name
+ * @pp:			PLL parents
+ * @pp_mux_table:	PLL parents mux table
+ * @r:			clock output range
+ * @pp_chg_id:		id in parent array of changeable PLL parent
+ * @pp_count:		PLL parents count
+ * @id:			clock id
+ */
+static const struct {
+	const char *n;
+	const char *pp[8];
+	const char pp_mux_table[8];
+	struct clk_range r;
+	int pp_chg_id;
+	u8 pp_count;
+	u8 id;
+} sam9x7_gck[] = {
+	{
+		.n = "flex0_gclk",
+		.id = 5,
+		.pp = { "plla_div2pmcck", },
+		.pp_mux_table = { 8, },
+		.pp_count = 1,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "flex1_gclk",
+		.id = 6,
+		.pp = { "plla_div2pmcck", },
+		.pp_mux_table = { 8, },
+		.pp_count = 1,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "flex2_gclk",
+		.id = 7,
+		.pp = { "plla_div2pmcck", },
+		.pp_mux_table = { 8, },
+		.pp_count = 1,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "flex3_gclk",
+		.id = 8,
+		.pp = { "plla_div2pmcck", },
+		.pp_mux_table = { 8, },
+		.pp_count = 1,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "flex6_gclk",
+		.id = 9,
+		.pp = { "plla_div2pmcck", },
+		.pp_mux_table = { 8, },
+		.pp_count = 1,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "flex7_gclk",
+		.id = 10,
+		.pp = { "plla_div2pmcck", },
+		.pp_mux_table = { 8, },
+		.pp_count = 1,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "flex8_gclk",
+		.id = 11,
+		.pp = { "plla_div2pmcck", },
+		.pp_mux_table = { 8, },
+		.pp_count = 1,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "sdmmc0_gclk",
+		.id = 12,
+		.r = { .max = 105000000 },
+		.pp = { "audiopll_divpmcck", "plla_div2pmcck", },
+		.pp_mux_table = { 6, 8, },
+		.pp_count = 2,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "flex4_gclk",
+		.id = 13,
+		.pp = { "plla_div2pmcck", },
+		.pp_mux_table = { 8, },
+		.pp_count = 1,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "flex5_gclk",
+		.id = 14,
+		.pp = { "plla_div2pmcck", },
+		.pp_mux_table = { 8, },
+		.pp_count = 1,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "flex9_gclk",
+		.id = 15,
+		.pp = { "plla_div2pmcck", },
+		.pp_mux_table = { 8, },
+		.pp_count = 1,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "flex10_gclk",
+		.id = 16,
+		.pp = { "plla_div2pmcck", },
+		.pp_mux_table = { 8, },
+		.pp_count = 1,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "tcb0_gclk",
+		.id = 17,
+		.pp = { "audiopll_divpmcck", "plla_div2pmcck", },
+		.pp_mux_table = { 6, 8, },
+		.pp_count = 2,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "adc_gclk",
+		.id = 19,
+		.pp = { "upll_divpmcck", "plla_div2pmcck", },
+		.pp_mux_table = { 5, 8, },
+		.pp_count = 2,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "lcd_gclk",
+		.id = 25,
+		.r = { .max = 75000000 },
+		.pp = { "audiopll_divpmcck", "plla_div2pmcck", },
+		.pp_mux_table = { 6, 8, },
+		.pp_count = 2,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "sdmmc1_gclk",
+		.id = 26,
+		.r = { .max = 105000000 },
+		.pp = { "audiopll_divpmcck", "plla_div2pmcck", },
+		.pp_mux_table = { 6, 8, },
+		.pp_count = 2,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "mcan0_gclk",
+		.id = 29,
+		.r = { .max = 80000000 },
+		.pp = { "upll_divpmcck", "plla_div2pmcck", },
+		.pp_mux_table = { 5, 8, },
+		.pp_count = 2,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "mcan1_gclk",
+		.id = 30,
+		.r = { .max = 80000000 },
+		.pp = { "upll_divpmcck", "plla_div2pmcck", },
+		.pp_mux_table = { 5, 8, },
+		.pp_count = 2,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "flex11_gclk",
+		.id = 32,
+		.pp = { "plla_div2pmcck", },
+		.pp_mux_table = { 8, },
+		.pp_count = 1,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "flex12_gclk",
+		.id = 33,
+		.pp = { "plla_div2pmcck", },
+		.pp_mux_table = { 8, },
+		.pp_count = 1,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "i2s_gclk",
+		.id = 34,
+		.r = { .max = 100000000 },
+		.pp = { "audiopll_divpmcck", "plla_div2pmcck", },
+		.pp_mux_table = { 6, 8, },
+		.pp_count = 2,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "qspi_gclk",
+		.id = 35,
+		.r = { .max = 200000000 },
+		.pp = { "audiopll_divpmcck", "plla_div2pmcck", },
+		.pp_mux_table = { 6, 8, },
+		.pp_count = 2,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "pit64b0_gclk",
+		.id = 37,
+		.pp = { "plla_div2pmcck", },
+		.pp_mux_table = { 8, },
+		.pp_count = 1,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "classd_gclk",
+		.id = 42,
+		.r = { .max = 100000000 },
+		.pp = { "audiopll_divpmcck", "plla_div2pmcck", },
+		.pp_mux_table = { 6, 8, },
+		.pp_count = 2,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "tcb1_gclk",
+		.id = 45,
+		.pp = { "audiopll_divpmcck", "plla_div2pmcck", },
+		.pp_mux_table = { 6, 8, },
+		.pp_count = 2,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "dbgu_gclk",
+		.id = 47,
+		.pp = { "plla_div2pmcck", },
+		.pp_mux_table = { 8, },
+		.pp_count = 1,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "mipiphy_gclk",
+		.id = 55,
+		.r = { .max = 27000000 },
+		.pp = { "plla_div2pmcck", },
+		.pp_mux_table = { 8, },
+		.pp_count = 1,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "pit64b1_gclk",
+		.id = 58,
+		.pp = { "plla_div2pmcck", },
+		.pp_mux_table = { 8, },
+		.pp_count = 1,
+		.pp_chg_id = INT_MIN,
+	},
+
+	{
+		.n = "gmac_gclk",
+		.id = 67,
+		.pp = { "audiopll_divpmcck", "plla_div2pmcck", },
+		.pp_mux_table = { 6, 8, },
+		.pp_count = 2,
+		.pp_chg_id = INT_MIN,
+	},
+};
+
+static void __init sam9x7_pmc_setup(struct device_node *np)
+{
+	struct clk_range range = CLK_RANGE(0, 0);
+	const char *td_slck_name, *md_slck_name, *mainxtal_name;
+	struct pmc_data *sam9x7_pmc;
+	const char *parent_names[9];
+	void **clk_mux_buffer = NULL;
+	int clk_mux_buffer_size = 0;
+	struct clk_hw *main_osc_hw;
+	struct regmap *regmap;
+	struct clk_hw *hw;
+	int i, j;
+
+	i = of_property_match_string(np, "clock-names", "td_slck");
+	if (i < 0)
+		return;
+
+	td_slck_name = of_clk_get_parent_name(np, i);
+
+	i = of_property_match_string(np, "clock-names", "md_slck");
+	if (i < 0)
+		return;
+
+	md_slck_name = of_clk_get_parent_name(np, i);
+
+	i = of_property_match_string(np, "clock-names", "main_xtal");
+	if (i < 0)
+		return;
+	mainxtal_name = of_clk_get_parent_name(np, i);
+
+	regmap = device_node_to_regmap(np);
+	if (IS_ERR(regmap))
+		return;
+
+	sam9x7_pmc = pmc_data_allocate(PMC_LVDSPLL + 1,
+				       nck(sam9x7_systemck),
+				       nck(sam9x7_periphck),
+				       nck(sam9x7_gck), 8);
+	if (!sam9x7_pmc)
+		return;
+
+	clk_mux_buffer = kmalloc(sizeof(void *) *
+				 (ARRAY_SIZE(sam9x7_gck)),
+				 GFP_KERNEL);
+	if (!clk_mux_buffer)
+		goto err_free;
+
+	hw = at91_clk_register_main_rc_osc(regmap, "main_rc_osc", 12000000,
+					   50000000);
+	if (IS_ERR(hw))
+		goto err_free;
+
+	hw = at91_clk_register_main_osc(regmap, "main_osc", mainxtal_name, NULL, 0);
+	if (IS_ERR(hw))
+		goto err_free;
+	main_osc_hw = hw;
+
+	parent_names[0] = "main_rc_osc";
+	parent_names[1] = "main_osc";
+	hw = at91_clk_register_sam9x5_main(regmap, "mainck", parent_names, NULL, 2);
+	if (IS_ERR(hw))
+		goto err_free;
+
+	sam9x7_pmc->chws[PMC_MAIN] = hw;
+
+	for (i = 0; i < PLL_ID_MAX; i++) {
+		for (j = 0; j < 3; j++) {
+			struct clk_hw *parent_hw;
+
+			if (!sam9x7_plls[i][j].n)
+				continue;
+
+			switch (sam9x7_plls[i][j].t) {
+			case PLL_TYPE_FRAC:
+				if (!strcmp(sam9x7_plls[i][j].p, "mainck"))
+					parent_hw = sam9x7_pmc->chws[PMC_MAIN];
+				else if (!strcmp(sam9x7_plls[i][j].p, "main_osc"))
+					parent_hw = main_osc_hw;
+				else
+					parent_hw = __clk_get_hw(of_clk_get_by_name
+								 (np, sam9x7_plls[i][j].p));
+
+				hw = sam9x60_clk_register_frac_pll(regmap,
+								   &pmc_pll_lock,
+								   sam9x7_plls[i][j].n,
+								   sam9x7_plls[i][j].p,
+								   parent_hw, i,
+								   sam9x7_plls[i][j].c,
+								   sam9x7_plls[i][j].l,
+								   sam9x7_plls[i][j].f);
+				break;
+
+			case PLL_TYPE_DIV:
+				hw = sam9x60_clk_register_div_pll(regmap,
+								  &pmc_pll_lock,
+								  sam9x7_plls[i][j].n,
+								  sam9x7_plls[i][j].p, NULL, i,
+								  sam9x7_plls[i][j].c,
+								  sam9x7_plls[i][j].l,
+								  sam9x7_plls[i][j].f, 0);
+				break;
+
+			default:
+				continue;
+			}
+
+			if (IS_ERR(hw))
+				goto err_free;
+
+			if (sam9x7_plls[i][j].eid)
+				sam9x7_pmc->chws[sam9x7_plls[i][j].eid] = hw;
+		}
+	}
+
+	parent_names[0] = md_slck_name;
+	parent_names[1] = "mainck";
+	parent_names[2] = "plla_divpmcck";
+	parent_names[3] = "upll_divpmcck";
+	hw = at91_clk_register_master_pres(regmap, "masterck_pres", 4,
+					   parent_names, NULL, &sam9x7_master_layout,
+					   &mck_characteristics, &mck_lock);
+	if (IS_ERR(hw))
+		goto err_free;
+
+	hw = at91_clk_register_master_div(regmap, "masterck_div",
+					  "masterck_pres", NULL, &sam9x7_master_layout,
+					  &mck_characteristics, &mck_lock,
+					  CLK_SET_RATE_GATE, 0);
+	if (IS_ERR(hw))
+		goto err_free;
+
+	sam9x7_pmc->chws[PMC_MCK] = hw;
+
+	parent_names[0] = "plla_divpmcck";
+	parent_names[1] = "upll_divpmcck";
+	parent_names[2] = "main_osc";
+	hw = sam9x60_clk_register_usb(regmap, "usbck", parent_names, 3);
+	if (IS_ERR(hw))
+		goto err_free;
+
+	parent_names[0] = md_slck_name;
+	parent_names[1] = td_slck_name;
+	parent_names[2] = "mainck";
+	parent_names[3] = "masterck_div";
+	parent_names[4] = "plla_divpmcck";
+	parent_names[5] = "upll_divpmcck";
+	parent_names[6] = "audiopll_divpmcck";
+	for (i = 0; i < 2; i++) {
+		char name[6];
+
+		snprintf(name, sizeof(name), "prog%d", i);
+
+		hw = at91_clk_register_programmable(regmap, name,
+						    parent_names, NULL, 7, i,
+						    &sam9x7_programmable_layout,
+						    NULL);
+		if (IS_ERR(hw))
+			goto err_free;
+
+		sam9x7_pmc->pchws[i] = hw;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(sam9x7_systemck); i++) {
+		hw = at91_clk_register_system(regmap, sam9x7_systemck[i].n,
+					      sam9x7_systemck[i].p, NULL,
+					      sam9x7_systemck[i].id,
+					      sam9x7_systemck[i].flags);
+		if (IS_ERR(hw))
+			goto err_free;
+
+		sam9x7_pmc->shws[sam9x7_systemck[i].id] = hw;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(sam9x7_periphck); i++) {
+		hw = at91_clk_register_sam9x5_peripheral(regmap, &pmc_pcr_lock,
+							 &sam9x7_pcr_layout,
+							 sam9x7_periphck[i].n,
+							 "masterck_div", NULL,
+							 sam9x7_periphck[i].id,
+							 &range, INT_MIN,
+							 sam9x7_periphck[i].f);
+		if (IS_ERR(hw))
+			goto err_free;
+
+		sam9x7_pmc->phws[sam9x7_periphck[i].id] = hw;
+	}
+
+	parent_names[0] = md_slck_name;
+	parent_names[1] = td_slck_name;
+	parent_names[2] = "mainck";
+	parent_names[3] = "masterck_div";
+	for (i = 0; i < ARRAY_SIZE(sam9x7_gck); i++) {
+		u8 num_parents = 4 + sam9x7_gck[i].pp_count;
+		u32 *mux_table;
+
+		mux_table = kmalloc_array(num_parents, sizeof(*mux_table),
+					  GFP_KERNEL);
+		if (!mux_table)
+			goto err_free;
+
+		SAM9X7_INIT_TABLE(mux_table, 4);
+		SAM9X7_FILL_TABLE(&mux_table[4], sam9x7_gck[i].pp_mux_table,
+				  sam9x7_gck[i].pp_count);
+		SAM9X7_FILL_TABLE(&parent_names[4], sam9x7_gck[i].pp,
+				  sam9x7_gck[i].pp_count);
+
+		hw = at91_clk_register_generated(regmap, &pmc_pcr_lock,
+						 &sam9x7_pcr_layout,
+						 sam9x7_gck[i].n,
+						 parent_names, NULL, mux_table,
+						 num_parents,
+						 sam9x7_gck[i].id,
+						 &sam9x7_gck[i].r,
+						 sam9x7_gck[i].pp_chg_id);
+		if (IS_ERR(hw))
+			goto err_free;
+
+		sam9x7_pmc->ghws[sam9x7_gck[i].id] = hw;
+		clk_mux_buffer[clk_mux_buffer_size++] = mux_table;
+	}
+
+	of_clk_add_hw_provider(np, of_clk_hw_pmc_get, sam9x7_pmc);
+	kfree(clk_mux_buffer);
+
+	return;
+
+err_free:
+	if (clk_mux_buffer) {
+		for (i = 0; i < clk_mux_buffer_size; i++)
+			kfree(clk_mux_buffer[i]);
+		kfree(clk_mux_buffer);
+	}
+	kfree(sam9x7_pmc);
+}
+
+/* Some clks are used for a clocksource */
+CLK_OF_DECLARE(sam9x7_pmc, "microchip,sam9x7-pmc", sam9x7_pmc_setup);
--- linux-6.6.51/drivers/clk/at91/sama7g5.c	2024-12-05 13:07:40.541788100 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/at91/sama7g5.c	2024-12-04 16:41:19.926393100 +0900
@@ -116,11 +116,17 @@
 	{ .min = 2343750, .max = 1200000000 },
 };
 
+/* Fractional PLL core output range. */
+static const struct clk_range core_outputs[] = {
+	{ .min = 600000000, .max = 1200000000 },
+};
+
 /* CPU PLL characteristics. */
 static const struct clk_pll_characteristics cpu_pll_characteristics = {
 	.input = { .min = 12000000, .max = 50000000 },
 	.num_output = ARRAY_SIZE(cpu_pll_outputs),
 	.output = cpu_pll_outputs,
+	.core_output = core_outputs,
 };
 
 /* PLL characteristics. */
@@ -128,6 +134,7 @@
 	.input = { .min = 12000000, .max = 50000000 },
 	.num_output = ARRAY_SIZE(pll_outputs),
 	.output = pll_outputs,
+	.core_output = core_outputs,
 };
 
 /*
@@ -581,7 +588,7 @@
 	  .pp = { PLL_IDS_TO_ARR_ENTRY(AUDIO, DIV0), },
 	  .pp_mux_table = { 9, },
 	  .pp_count = 1,
-	  .pp_chg_id = 3, },
+	  .pp_chg_id = INT_MIN, },
 
 	{ .n  = "csi_gclk",
 	  .id = 33,
@@ -725,7 +732,7 @@
 	  .pp = { PLL_IDS_TO_ARR_ENTRY(SYS, DIV0), PLL_IDS_TO_ARR_ENTRY(AUDIO, DIV0), },
 	  .pp_mux_table = { 5, 9, },
 	  .pp_count = 2,
-	  .pp_chg_id = 4, },
+	  .pp_chg_id = INT_MIN, },
 
 	{ .n  = "i2smcc1_gclk",
 	  .id = 58,
@@ -733,7 +740,7 @@
 	  .pp = { PLL_IDS_TO_ARR_ENTRY(SYS, DIV0), PLL_IDS_TO_ARR_ENTRY(AUDIO, DIV0), },
 	  .pp_mux_table = { 5, 9, },
 	  .pp_count = 2,
-	  .pp_chg_id = 4, },
+	  .pp_chg_id = INT_MIN, },
 
 	{ .n  = "mcan0_gclk",
 	  .id = 61,
@@ -905,7 +912,7 @@
 	  .pp = { PLL_IDS_TO_ARR_ENTRY(SYS, DIV0), PLL_IDS_TO_ARR_ENTRY(AUDIO, DIV0), },
 	  .pp_mux_table = { 5, 9, },
 	  .pp_count = 2,
-	  .pp_chg_id = 4, },
+	  .pp_chg_id = INT_MIN, },
 
 	{ .n = "spdiftx_gclk",
 	  .id = 85,
@@ -913,7 +920,7 @@
 	  .pp = { PLL_IDS_TO_ARR_ENTRY(SYS, DIV0), PLL_IDS_TO_ARR_ENTRY(AUDIO, DIV0), },
 	  .pp_mux_table = { 5, 9, },
 	  .pp_count = 2,
-	  .pp_chg_id = 4, },
+	  .pp_chg_id = INT_MIN, },
 
 	{ .n  = "tcb0_ch0_gclk",
 	  .id = 88,
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/clk/clk-regmap.c	2024-12-04 16:41:19.964291800 +0900
@@ -0,0 +1,186 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018 BayLibre, SAS.
+ * Author: Jerome Brunet <jbrunet@baylibre.com>
+ */
+
+#include <linux/module.h>
+#include <linux/clk/clk-regmap.h>
+
+static int clk_regmap_gate_endisable(struct clk_hw *hw, int enable)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_gate_data *gate = clk_get_regmap_gate_data(clk);
+	int set = gate->flags & CLK_GATE_SET_TO_DISABLE ? 1 : 0;
+
+	set ^= enable;
+
+	return regmap_update_bits(clk->map, gate->offset, BIT(gate->bit_idx),
+				  set ? BIT(gate->bit_idx) : 0);
+}
+
+static int clk_regmap_gate_enable(struct clk_hw *hw)
+{
+	return clk_regmap_gate_endisable(hw, 1);
+}
+
+static void clk_regmap_gate_disable(struct clk_hw *hw)
+{
+	clk_regmap_gate_endisable(hw, 0);
+}
+
+static int clk_regmap_gate_is_enabled(struct clk_hw *hw)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_gate_data *gate = clk_get_regmap_gate_data(clk);
+	unsigned int val;
+
+	regmap_read(clk->map, gate->offset, &val);
+	if (gate->flags & CLK_GATE_SET_TO_DISABLE)
+		val ^= BIT(gate->bit_idx);
+
+	val &= BIT(gate->bit_idx);
+
+	return val ? 1 : 0;
+}
+
+const struct clk_ops clk_regmap_gate_ops = {
+	.enable = clk_regmap_gate_enable,
+	.disable = clk_regmap_gate_disable,
+	.is_enabled = clk_regmap_gate_is_enabled,
+};
+EXPORT_SYMBOL_GPL(clk_regmap_gate_ops);
+
+const struct clk_ops clk_regmap_gate_ro_ops = {
+	.is_enabled = clk_regmap_gate_is_enabled,
+};
+EXPORT_SYMBOL_GPL(clk_regmap_gate_ro_ops);
+
+static unsigned long clk_regmap_div_recalc_rate(struct clk_hw *hw,
+						unsigned long prate)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_div_data *div = clk_get_regmap_div_data(clk);
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(clk->map, div->offset, &val);
+	if (ret)
+		/* Gives a hint that something is wrong */
+		return 0;
+
+	val >>= div->shift;
+	val &= clk_div_mask(div->width);
+	return divider_recalc_rate(hw, prate, val, div->table, div->flags,
+				   div->width);
+}
+
+static int clk_regmap_div_determine_rate(struct clk_hw *hw,
+					 struct clk_rate_request *req)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_div_data *div = clk_get_regmap_div_data(clk);
+	unsigned int val;
+	int ret;
+
+	/* if read only, just return current value */
+	if (div->flags & CLK_DIVIDER_READ_ONLY) {
+		ret = regmap_read(clk->map, div->offset, &val);
+		if (ret)
+			return ret;
+
+		val >>= div->shift;
+		val &= clk_div_mask(div->width);
+
+		return divider_ro_determine_rate(hw, req, div->table,
+						 div->width, div->flags, val);
+	}
+
+	return divider_determine_rate(hw, req, div->table, div->width,
+				      div->flags);
+}
+
+static int clk_regmap_div_set_rate(struct clk_hw *hw, unsigned long rate,
+				   unsigned long parent_rate)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_div_data *div = clk_get_regmap_div_data(clk);
+	unsigned int val;
+	int ret;
+
+	ret = divider_get_val(rate, parent_rate, div->table, div->width,
+			      div->flags);
+	if (ret < 0)
+		return ret;
+
+	val = (unsigned int)ret << div->shift;
+	return regmap_update_bits(clk->map, div->offset,
+				  clk_div_mask(div->width) << div->shift, val);
+};
+
+/* Would prefer clk_regmap_div_ro_ops but clashes with qcom */
+
+const struct clk_ops clk_regmap_divider_ops = {
+	.recalc_rate = clk_regmap_div_recalc_rate,
+	.determine_rate = clk_regmap_div_determine_rate,
+	.set_rate = clk_regmap_div_set_rate,
+};
+EXPORT_SYMBOL_GPL(clk_regmap_divider_ops);
+
+const struct clk_ops clk_regmap_divider_ro_ops = {
+	.recalc_rate = clk_regmap_div_recalc_rate,
+	.determine_rate = clk_regmap_div_determine_rate,
+};
+EXPORT_SYMBOL_GPL(clk_regmap_divider_ro_ops);
+
+static u8 clk_regmap_mux_get_parent(struct clk_hw *hw)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_mux_data *mux = clk_get_regmap_mux_data(clk);
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(clk->map, mux->offset, &val);
+	if (ret)
+		return ret;
+
+	val >>= mux->shift;
+	val &= mux->mask;
+	return clk_mux_val_to_index(hw, mux->table, mux->flags, val);
+}
+
+static int clk_regmap_mux_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_mux_data *mux = clk_get_regmap_mux_data(clk);
+	unsigned int val = clk_mux_index_to_val(mux->table, mux->flags, index);
+
+	return regmap_update_bits(clk->map, mux->offset,
+				  mux->mask << mux->shift,
+				  val << mux->shift);
+}
+
+static int clk_regmap_mux_determine_rate(struct clk_hw *hw,
+					 struct clk_rate_request *req)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_mux_data *mux = clk_get_regmap_mux_data(clk);
+
+	return clk_mux_determine_rate_flags(hw, req, mux->flags);
+}
+
+const struct clk_ops clk_regmap_mux_ops = {
+	.get_parent = clk_regmap_mux_get_parent,
+	.set_parent = clk_regmap_mux_set_parent,
+	.determine_rate = clk_regmap_mux_determine_rate,
+};
+EXPORT_SYMBOL_GPL(clk_regmap_mux_ops);
+
+const struct clk_ops clk_regmap_mux_ro_ops = {
+	.get_parent = clk_regmap_mux_get_parent,
+};
+EXPORT_SYMBOL_GPL(clk_regmap_mux_ro_ops);
+
+MODULE_DESCRIPTION("Amlogic regmap backed clock driver");
+MODULE_AUTHOR("Jerome Brunet <jbrunet@baylibre.com>");
+MODULE_LICENSE("GPL v2");
--- linux-6.6.51/drivers/clk/meson/Kconfig	2024-12-05 13:07:40.723343100 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/Kconfig	2024-12-04 16:41:20.088958300 +0900
@@ -2,57 +2,53 @@
 menu "Clock support for Amlogic platforms"
 	depends on ARCH_MESON || COMPILE_TEST
 
-config COMMON_CLK_MESON_REGMAP
-	tristate
-	select REGMAP
-
 config COMMON_CLK_MESON_DUALDIV
 	tristate
-	select COMMON_CLK_MESON_REGMAP
+	select COMMON_CLK_REGMAP
 
 config COMMON_CLK_MESON_MPLL
 	tristate
-	select COMMON_CLK_MESON_REGMAP
+	select COMMON_CLK_REGMAP
 
 config COMMON_CLK_MESON_PHASE
 	tristate
-	select COMMON_CLK_MESON_REGMAP
+	select COMMON_CLK_REGMAP
 
 config COMMON_CLK_MESON_PLL
 	tristate
-	select COMMON_CLK_MESON_REGMAP
+	select COMMON_CLK_REGMAP
 
 config COMMON_CLK_MESON_SCLK_DIV
 	tristate
-	select COMMON_CLK_MESON_REGMAP
+	select COMMON_CLK_REGMAP
 
 config COMMON_CLK_MESON_VID_PLL_DIV
 	tristate
-	select COMMON_CLK_MESON_REGMAP
+	select COMMON_CLK_REGMAP
 
 config COMMON_CLK_MESON_CLKC_UTILS
 	tristate
 
 config COMMON_CLK_MESON_AO_CLKC
 	tristate
-	select COMMON_CLK_MESON_REGMAP
+	select COMMON_CLK_REGMAP
 	select COMMON_CLK_MESON_CLKC_UTILS
 	select RESET_CONTROLLER
 
 config COMMON_CLK_MESON_EE_CLKC
 	tristate
-	select COMMON_CLK_MESON_REGMAP
+	select COMMON_CLK_REGMAP
 	select COMMON_CLK_MESON_CLKC_UTILS
 
 config COMMON_CLK_MESON_CPU_DYNDIV
 	tristate
-	select COMMON_CLK_MESON_REGMAP
+	select COMMON_CLK_REGMAP
 
 config COMMON_CLK_MESON8B
 	bool "Meson8 SoC Clock controller support"
 	depends on ARM
 	default y
-	select COMMON_CLK_MESON_REGMAP
+	select COMMON_CLK_REGMAP
 	select COMMON_CLK_MESON_CLKC_UTILS
 	select COMMON_CLK_MESON_MPLL
 	select COMMON_CLK_MESON_PLL
@@ -67,7 +63,7 @@
 	tristate "GXBB and GXL SoC clock controllers support"
 	depends on ARM64
 	default y
-	select COMMON_CLK_MESON_REGMAP
+	select COMMON_CLK_REGMAP
 	select COMMON_CLK_MESON_DUALDIV
 	select COMMON_CLK_MESON_VID_PLL_DIV
 	select COMMON_CLK_MESON_MPLL
@@ -83,7 +79,7 @@
 	tristate "AXG SoC clock controllers support"
 	depends on ARM64
 	default y
-	select COMMON_CLK_MESON_REGMAP
+	select COMMON_CLK_REGMAP
 	select COMMON_CLK_MESON_DUALDIV
 	select COMMON_CLK_MESON_MPLL
 	select COMMON_CLK_MESON_PLL
@@ -97,7 +93,7 @@
 config COMMON_CLK_AXG_AUDIO
 	tristate "Meson AXG Audio Clock Controller Driver"
 	depends on ARM64
-	select COMMON_CLK_MESON_REGMAP
+	select COMMON_CLK_REGMAP
 	select COMMON_CLK_MESON_PHASE
 	select COMMON_CLK_MESON_SCLK_DIV
 	select COMMON_CLK_MESON_CLKC_UTILS
@@ -109,7 +105,7 @@
 config COMMON_CLK_A1_PLL
 	tristate "Amlogic A1 SoC PLL controller support"
 	depends on ARM64
-	select COMMON_CLK_MESON_REGMAP
+	select COMMON_CLK_REGMAP
 	select COMMON_CLK_MESON_CLKC_UTILS
 	select COMMON_CLK_MESON_PLL
 	help
@@ -121,7 +117,7 @@
 	tristate "Amlogic A1 SoC Peripherals clock controller support"
 	depends on ARM64
 	select COMMON_CLK_MESON_DUALDIV
-	select COMMON_CLK_MESON_REGMAP
+	select COMMON_CLK_REGMAP
 	select COMMON_CLK_MESON_CLKC_UTILS
 	help
 	  Support for the Peripherals clock controller on Amlogic A113L based
@@ -132,7 +128,7 @@
 	tristate "G12 and SM1 SoC clock controllers support"
 	depends on ARM64
 	default y
-	select COMMON_CLK_MESON_REGMAP
+	select COMMON_CLK_REGMAP
 	select COMMON_CLK_MESON_DUALDIV
 	select COMMON_CLK_MESON_MPLL
 	select COMMON_CLK_MESON_PLL
--- linux-6.6.51/drivers/clk/meson/Makefile	2024-12-05 13:07:40.723343100 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/Makefile	2024-12-04 16:41:20.088958300 +0900
@@ -9,7 +9,6 @@
 obj-$(CONFIG_COMMON_CLK_MESON_MPLL) += clk-mpll.o
 obj-$(CONFIG_COMMON_CLK_MESON_PHASE) += clk-phase.o
 obj-$(CONFIG_COMMON_CLK_MESON_PLL) += clk-pll.o
-obj-$(CONFIG_COMMON_CLK_MESON_REGMAP) += clk-regmap.o
 obj-$(CONFIG_COMMON_CLK_MESON_SCLK_DIV) += sclk-div.o
 obj-$(CONFIG_COMMON_CLK_MESON_VID_PLL_DIV) += vid-pll-div.o
 
--- linux-6.6.51/drivers/clk/meson/a1-peripherals.c	2024-12-05 13:07:40.724328200 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/a1-peripherals.c	2024-12-04 16:41:20.089955700 +0900
@@ -12,7 +12,7 @@
 #include <linux/platform_device.h>
 #include "a1-peripherals.h"
 #include "clk-dualdiv.h"
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "meson-clkc-utils.h"
 
 #include <dt-bindings/clock/amlogic,a1-peripherals-clkc.h>
--- linux-6.6.51/drivers/clk/meson/a1-pll.c	2024-12-05 13:07:40.724328200 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/a1-pll.c	2024-12-04 16:41:20.090952800 +0900
@@ -11,7 +11,7 @@
 #include <linux/mod_devicetable.h>
 #include <linux/platform_device.h>
 #include "a1-pll.h"
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "meson-clkc-utils.h"
 
 #include <dt-bindings/clock/amlogic,a1-pll-clkc.h>
--- linux-6.6.51/drivers/clk/meson/axg-aoclk.c	2024-12-05 13:07:40.725327900 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/axg-aoclk.c	2024-12-04 16:41:20.091950200 +0900
@@ -15,7 +15,7 @@
 #include <linux/module.h>
 #include "meson-aoclk.h"
 
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "clk-dualdiv.h"
 
 #include <dt-bindings/clock/axg-aoclkc.h>
--- linux-6.6.51/drivers/clk/meson/axg-audio.c	2024-12-05 13:07:40.726294700 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/axg-audio.c	2024-12-04 16:41:20.092948500 +0900
@@ -17,7 +17,7 @@
 
 #include "meson-clkc-utils.h"
 #include "axg-audio.h"
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "clk-phase.h"
 #include "sclk-div.h"
 
--- linux-6.6.51/drivers/clk/meson/axg.c	2024-12-05 13:07:40.727291800 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/axg.c	2024-12-04 16:41:20.093960400 +0900
@@ -15,7 +15,7 @@
 #include <linux/platform_device.h>
 #include <linux/module.h>
 
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "clk-pll.h"
 #include "clk-mpll.h"
 #include "axg.h"
--- linux-6.6.51/drivers/clk/meson/clk-cpu-dyndiv.c	2024-12-05 13:07:40.727291800 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/clk-cpu-dyndiv.c	2024-12-04 16:41:20.094947600 +0900
@@ -7,7 +7,7 @@
 #include <linux/clk-provider.h>
 #include <linux/module.h>
 
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "clk-cpu-dyndiv.h"
 
 static inline struct meson_clk_cpu_dyndiv_data *
--- linux-6.6.51/drivers/clk/meson/clk-dualdiv.c	2024-12-05 13:07:40.728289100 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/clk-dualdiv.c	2024-12-04 16:41:20.094947600 +0900
@@ -24,7 +24,7 @@
 #include <linux/clk-provider.h>
 #include <linux/module.h>
 
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "clk-dualdiv.h"
 
 static inline struct meson_clk_dualdiv_data *
--- linux-6.6.51/drivers/clk/meson/clk-mpll.c	2024-12-05 13:07:40.728289100 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/clk-mpll.c	2024-12-04 16:41:20.095939500 +0900
@@ -15,7 +15,7 @@
 #include <linux/module.h>
 #include <linux/spinlock.h>
 
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "clk-mpll.h"
 
 #define SDM_DEN 16384
--- linux-6.6.51/drivers/clk/meson/clk-phase.c	2024-12-05 13:07:40.729286500 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/clk-phase.c	2024-12-04 16:41:20.096937300 +0900
@@ -7,7 +7,7 @@
 #include <linux/clk-provider.h>
 #include <linux/module.h>
 
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "clk-phase.h"
 
 #define phase_step(_width) (360 / (1 << (_width)))
--- linux-6.6.51/drivers/clk/meson/clk-pll.c	2024-12-05 13:07:40.730283800 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/clk-pll.c	2024-12-04 16:41:20.096937300 +0900
@@ -33,7 +33,7 @@
 #include <linux/math64.h>
 #include <linux/module.h>
 
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "clk-pll.h"
 
 static inline struct meson_clk_pll_data *
--- linux-6.6.51/drivers/clk/meson/clk-regmap.c	2024-12-05 13:07:40.730283800 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/clk-regmap.c	1970-01-01 09:00:00.000000000 +0900
@@ -1,186 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (c) 2018 BayLibre, SAS.
- * Author: Jerome Brunet <jbrunet@baylibre.com>
- */
-
-#include <linux/module.h>
-#include "clk-regmap.h"
-
-static int clk_regmap_gate_endisable(struct clk_hw *hw, int enable)
-{
-	struct clk_regmap *clk = to_clk_regmap(hw);
-	struct clk_regmap_gate_data *gate = clk_get_regmap_gate_data(clk);
-	int set = gate->flags & CLK_GATE_SET_TO_DISABLE ? 1 : 0;
-
-	set ^= enable;
-
-	return regmap_update_bits(clk->map, gate->offset, BIT(gate->bit_idx),
-				  set ? BIT(gate->bit_idx) : 0);
-}
-
-static int clk_regmap_gate_enable(struct clk_hw *hw)
-{
-	return clk_regmap_gate_endisable(hw, 1);
-}
-
-static void clk_regmap_gate_disable(struct clk_hw *hw)
-{
-	clk_regmap_gate_endisable(hw, 0);
-}
-
-static int clk_regmap_gate_is_enabled(struct clk_hw *hw)
-{
-	struct clk_regmap *clk = to_clk_regmap(hw);
-	struct clk_regmap_gate_data *gate = clk_get_regmap_gate_data(clk);
-	unsigned int val;
-
-	regmap_read(clk->map, gate->offset, &val);
-	if (gate->flags & CLK_GATE_SET_TO_DISABLE)
-		val ^= BIT(gate->bit_idx);
-
-	val &= BIT(gate->bit_idx);
-
-	return val ? 1 : 0;
-}
-
-const struct clk_ops clk_regmap_gate_ops = {
-	.enable = clk_regmap_gate_enable,
-	.disable = clk_regmap_gate_disable,
-	.is_enabled = clk_regmap_gate_is_enabled,
-};
-EXPORT_SYMBOL_GPL(clk_regmap_gate_ops);
-
-const struct clk_ops clk_regmap_gate_ro_ops = {
-	.is_enabled = clk_regmap_gate_is_enabled,
-};
-EXPORT_SYMBOL_GPL(clk_regmap_gate_ro_ops);
-
-static unsigned long clk_regmap_div_recalc_rate(struct clk_hw *hw,
-						unsigned long prate)
-{
-	struct clk_regmap *clk = to_clk_regmap(hw);
-	struct clk_regmap_div_data *div = clk_get_regmap_div_data(clk);
-	unsigned int val;
-	int ret;
-
-	ret = regmap_read(clk->map, div->offset, &val);
-	if (ret)
-		/* Gives a hint that something is wrong */
-		return 0;
-
-	val >>= div->shift;
-	val &= clk_div_mask(div->width);
-	return divider_recalc_rate(hw, prate, val, div->table, div->flags,
-				   div->width);
-}
-
-static int clk_regmap_div_determine_rate(struct clk_hw *hw,
-					 struct clk_rate_request *req)
-{
-	struct clk_regmap *clk = to_clk_regmap(hw);
-	struct clk_regmap_div_data *div = clk_get_regmap_div_data(clk);
-	unsigned int val;
-	int ret;
-
-	/* if read only, just return current value */
-	if (div->flags & CLK_DIVIDER_READ_ONLY) {
-		ret = regmap_read(clk->map, div->offset, &val);
-		if (ret)
-			return ret;
-
-		val >>= div->shift;
-		val &= clk_div_mask(div->width);
-
-		return divider_ro_determine_rate(hw, req, div->table,
-						 div->width, div->flags, val);
-	}
-
-	return divider_determine_rate(hw, req, div->table, div->width,
-				      div->flags);
-}
-
-static int clk_regmap_div_set_rate(struct clk_hw *hw, unsigned long rate,
-				   unsigned long parent_rate)
-{
-	struct clk_regmap *clk = to_clk_regmap(hw);
-	struct clk_regmap_div_data *div = clk_get_regmap_div_data(clk);
-	unsigned int val;
-	int ret;
-
-	ret = divider_get_val(rate, parent_rate, div->table, div->width,
-			      div->flags);
-	if (ret < 0)
-		return ret;
-
-	val = (unsigned int)ret << div->shift;
-	return regmap_update_bits(clk->map, div->offset,
-				  clk_div_mask(div->width) << div->shift, val);
-};
-
-/* Would prefer clk_regmap_div_ro_ops but clashes with qcom */
-
-const struct clk_ops clk_regmap_divider_ops = {
-	.recalc_rate = clk_regmap_div_recalc_rate,
-	.determine_rate = clk_regmap_div_determine_rate,
-	.set_rate = clk_regmap_div_set_rate,
-};
-EXPORT_SYMBOL_GPL(clk_regmap_divider_ops);
-
-const struct clk_ops clk_regmap_divider_ro_ops = {
-	.recalc_rate = clk_regmap_div_recalc_rate,
-	.determine_rate = clk_regmap_div_determine_rate,
-};
-EXPORT_SYMBOL_GPL(clk_regmap_divider_ro_ops);
-
-static u8 clk_regmap_mux_get_parent(struct clk_hw *hw)
-{
-	struct clk_regmap *clk = to_clk_regmap(hw);
-	struct clk_regmap_mux_data *mux = clk_get_regmap_mux_data(clk);
-	unsigned int val;
-	int ret;
-
-	ret = regmap_read(clk->map, mux->offset, &val);
-	if (ret)
-		return ret;
-
-	val >>= mux->shift;
-	val &= mux->mask;
-	return clk_mux_val_to_index(hw, mux->table, mux->flags, val);
-}
-
-static int clk_regmap_mux_set_parent(struct clk_hw *hw, u8 index)
-{
-	struct clk_regmap *clk = to_clk_regmap(hw);
-	struct clk_regmap_mux_data *mux = clk_get_regmap_mux_data(clk);
-	unsigned int val = clk_mux_index_to_val(mux->table, mux->flags, index);
-
-	return regmap_update_bits(clk->map, mux->offset,
-				  mux->mask << mux->shift,
-				  val << mux->shift);
-}
-
-static int clk_regmap_mux_determine_rate(struct clk_hw *hw,
-					 struct clk_rate_request *req)
-{
-	struct clk_regmap *clk = to_clk_regmap(hw);
-	struct clk_regmap_mux_data *mux = clk_get_regmap_mux_data(clk);
-
-	return clk_mux_determine_rate_flags(hw, req, mux->flags);
-}
-
-const struct clk_ops clk_regmap_mux_ops = {
-	.get_parent = clk_regmap_mux_get_parent,
-	.set_parent = clk_regmap_mux_set_parent,
-	.determine_rate = clk_regmap_mux_determine_rate,
-};
-EXPORT_SYMBOL_GPL(clk_regmap_mux_ops);
-
-const struct clk_ops clk_regmap_mux_ro_ops = {
-	.get_parent = clk_regmap_mux_get_parent,
-};
-EXPORT_SYMBOL_GPL(clk_regmap_mux_ro_ops);
-
-MODULE_DESCRIPTION("Amlogic regmap backed clock driver");
-MODULE_AUTHOR("Jerome Brunet <jbrunet@baylibre.com>");
-MODULE_LICENSE("GPL v2");
--- linux-6.6.51/drivers/clk/meson/clk-regmap.h	2024-12-05 13:07:40.731281200 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/clk-regmap.h	1970-01-01 09:00:00.000000000 +0900
@@ -1,137 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (c) 2018 BayLibre, SAS.
- * Author: Jerome Brunet <jbrunet@baylibre.com>
- */
-
-#ifndef __CLK_REGMAP_H
-#define __CLK_REGMAP_H
-
-#include <linux/clk-provider.h>
-#include <linux/regmap.h>
-
-/**
- * struct clk_regmap - regmap backed clock
- *
- * @hw:		handle between common and hardware-specific interfaces
- * @map:	pointer to the regmap structure controlling the clock
- * @data:	data specific to the clock type
- *
- * Clock which is controlled by regmap backed registers. The actual type of
- * of the clock is controlled by the clock_ops and data.
- */
-struct clk_regmap {
-	struct clk_hw	hw;
-	struct regmap	*map;
-	void		*data;
-};
-
-static inline struct clk_regmap *to_clk_regmap(struct clk_hw *hw)
-{
-	return container_of(hw, struct clk_regmap, hw);
-}
-
-/**
- * struct clk_regmap_gate_data - regmap backed gate specific data
- *
- * @offset:	offset of the register controlling gate
- * @bit_idx:	single bit controlling gate
- * @flags:	hardware-specific flags
- *
- * Flags:
- * Same as clk_gate except CLK_GATE_HIWORD_MASK which is ignored
- */
-struct clk_regmap_gate_data {
-	unsigned int	offset;
-	u8		bit_idx;
-	u8		flags;
-};
-
-static inline struct clk_regmap_gate_data *
-clk_get_regmap_gate_data(struct clk_regmap *clk)
-{
-	return (struct clk_regmap_gate_data *)clk->data;
-}
-
-extern const struct clk_ops clk_regmap_gate_ops;
-extern const struct clk_ops clk_regmap_gate_ro_ops;
-
-/**
- * struct clk_regmap_div_data - regmap backed adjustable divider specific data
- *
- * @offset:	offset of the register controlling the divider
- * @shift:	shift to the divider bit field
- * @width:	width of the divider bit field
- * @table:	array of value/divider pairs, last entry should have div = 0
- *
- * Flags:
- * Same as clk_divider except CLK_DIVIDER_HIWORD_MASK which is ignored
- */
-struct clk_regmap_div_data {
-	unsigned int	offset;
-	u8		shift;
-	u8		width;
-	u8		flags;
-	const struct clk_div_table	*table;
-};
-
-static inline struct clk_regmap_div_data *
-clk_get_regmap_div_data(struct clk_regmap *clk)
-{
-	return (struct clk_regmap_div_data *)clk->data;
-}
-
-extern const struct clk_ops clk_regmap_divider_ops;
-extern const struct clk_ops clk_regmap_divider_ro_ops;
-
-/**
- * struct clk_regmap_mux_data - regmap backed multiplexer clock specific data
- *
- * @hw:		handle between common and hardware-specific interfaces
- * @offset:	offset of theregister controlling multiplexer
- * @table:	array of parent indexed register values
- * @shift:	shift to multiplexer bit field
- * @mask:	mask of mutliplexer bit field
- * @flags:	hardware-specific flags
- *
- * Flags:
- * Same as clk_divider except CLK_MUX_HIWORD_MASK which is ignored
- */
-struct clk_regmap_mux_data {
-	unsigned int	offset;
-	u32		*table;
-	u32		mask;
-	u8		shift;
-	u8		flags;
-};
-
-static inline struct clk_regmap_mux_data *
-clk_get_regmap_mux_data(struct clk_regmap *clk)
-{
-	return (struct clk_regmap_mux_data *)clk->data;
-}
-
-extern const struct clk_ops clk_regmap_mux_ops;
-extern const struct clk_ops clk_regmap_mux_ro_ops;
-
-#define __MESON_PCLK(_name, _reg, _bit, _ops, _pname)			\
-struct clk_regmap _name = {						\
-	.data = &(struct clk_regmap_gate_data){				\
-		.offset = (_reg),					\
-		.bit_idx = (_bit),					\
-	},								\
-	.hw.init = &(struct clk_init_data) {				\
-		.name = #_name,						\
-		.ops = _ops,						\
-		.parent_hws = (const struct clk_hw *[]) { _pname },	\
-		.num_parents = 1,					\
-		.flags = (CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED),	\
-	},								\
-}
-
-#define MESON_PCLK(_name, _reg, _bit, _pname)	\
-	__MESON_PCLK(_name, _reg, _bit, &clk_regmap_gate_ops, _pname)
-
-#define MESON_PCLK_RO(_name, _reg, _bit, _pname)	\
-	__MESON_PCLK(_name, _reg, _bit, &clk_regmap_gate_ro_ops, _pname)
-#endif /* __CLK_REGMAP_H */
--- linux-6.6.51/drivers/clk/meson/g12a-aoclk.c	2024-12-05 13:07:40.731281200 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/g12a-aoclk.c	2024-12-04 16:41:20.097934200 +0900
@@ -15,7 +15,7 @@
 #include <linux/module.h>
 #include "meson-aoclk.h"
 
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "clk-dualdiv.h"
 
 #include <dt-bindings/clock/g12a-aoclkc.h>
--- linux-6.6.51/drivers/clk/meson/g12a.c	2024-12-05 13:07:40.732278500 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/g12a.c	2024-12-04 16:41:20.099929300 +0900
@@ -19,7 +19,7 @@
 
 #include "clk-mpll.h"
 #include "clk-pll.h"
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "clk-cpu-dyndiv.h"
 #include "vid-pll-div.h"
 #include "meson-eeclk.h"
--- linux-6.6.51/drivers/clk/meson/gxbb-aoclk.c	2024-12-05 13:07:40.732278500 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/gxbb-aoclk.c	2024-12-04 16:41:20.100926300 +0900
@@ -8,7 +8,7 @@
 #include <linux/module.h>
 #include "meson-aoclk.h"
 
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "clk-dualdiv.h"
 
 #include <dt-bindings/clock/gxbb-aoclkc.h>
--- linux-6.6.51/drivers/clk/meson/gxbb.c	2024-12-05 13:07:40.733276100 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/gxbb.c	2024-12-04 16:41:20.100926300 +0900
@@ -11,7 +11,7 @@
 #include <linux/module.h>
 
 #include "gxbb.h"
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "clk-pll.h"
 #include "clk-mpll.h"
 #include "meson-eeclk.h"
--- linux-6.6.51/drivers/clk/meson/meson-aoclk.h	2024-12-05 13:07:40.734273400 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/meson-aoclk.h	2024-12-04 16:41:20.102921900 +0900
@@ -16,7 +16,7 @@
 #include <linux/regmap.h>
 #include <linux/reset-controller.h>
 
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "meson-clkc-utils.h"
 
 struct meson_aoclk_data {
--- linux-6.6.51/drivers/clk/meson/meson-eeclk.c	2024-12-05 13:07:40.735271000 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/meson-eeclk.c	2024-12-04 16:41:20.103918400 +0900
@@ -11,7 +11,7 @@
 #include <linux/regmap.h>
 #include <linux/module.h>
 
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "meson-eeclk.h"
 
 int meson_eeclkc_probe(struct platform_device *pdev)
--- linux-6.6.51/drivers/clk/meson/meson-eeclk.h	2024-12-05 13:07:40.735271000 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/meson-eeclk.h	2024-12-04 16:41:20.103918400 +0900
@@ -8,7 +8,7 @@
 #define __MESON_CLKC_H
 
 #include <linux/clk-provider.h>
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "meson-clkc-utils.h"
 
 struct platform_device;
--- linux-6.6.51/drivers/clk/meson/meson8-ddr.c	2024-12-05 13:07:40.736267900 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/meson8-ddr.c	2024-12-04 16:41:20.103918400 +0900
@@ -10,7 +10,7 @@
 #include <linux/clk-provider.h>
 #include <linux/platform_device.h>
 
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "clk-pll.h"
 
 #define AM_DDR_PLL_CNTL			0x00
--- linux-6.6.51/drivers/clk/meson/meson8b.c	2024-12-05 13:07:40.736267900 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/meson8b.c	2024-12-04 16:41:20.104916000 +0900
@@ -17,7 +17,7 @@
 #include <linux/regmap.h>
 
 #include "meson8b.h"
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "meson-clkc-utils.h"
 #include "clk-pll.h"
 #include "clk-mpll.h"
--- linux-6.6.51/drivers/clk/meson/sclk-div.c	2024-12-05 13:07:40.737293500 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/sclk-div.c	2024-12-04 16:41:20.105912900 +0900
@@ -19,7 +19,7 @@
 #include <linux/clk-provider.h>
 #include <linux/module.h>
 
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "sclk-div.h"
 
 static inline struct meson_sclk_div_data *
--- linux-6.6.51/drivers/clk/meson/vid-pll-div.c	2024-12-05 13:07:40.738293600 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/meson/vid-pll-div.c	2024-12-04 16:41:20.106910200 +0900
@@ -7,7 +7,7 @@
 #include <linux/clk-provider.h>
 #include <linux/module.h>
 
-#include "clk-regmap.h"
+#include <linux/clk/clk-regmap.h>
 #include "vid-pll-div.h"
 
 static inline struct meson_vid_pll_div_data *
--- linux-6.6.51/drivers/clk/microchip/Kconfig	2024-12-05 13:07:40.739296700 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/microchip/Kconfig	2024-12-04 16:41:20.106910200 +0900
@@ -6,7 +6,10 @@
 config MCHP_CLK_MPFS
 	bool "Clk driver for PolarFire SoC"
 	depends on ARCH_MICROCHIP_POLARFIRE || COMPILE_TEST
+	depends on MFD_SYSCON
 	default ARCH_MICROCHIP_POLARFIRE
 	select AUXILIARY_BUS
+	select COMMON_CLK_REGMAP
+	select REGMAP_MMIO
 	help
 	  Supports Clock Configuration for PolarFire SoC
--- linux-6.6.51/drivers/clk/microchip/clk-mpfs.c	2024-12-05 13:07:40.740257500 +0900
+++ linux4microchip-fpga-2024.09/drivers/clk/microchip/clk-mpfs.c	2024-12-04 16:41:20.108904900 +0900
@@ -4,18 +4,20 @@
  *
  * Copyright (C) 2020-2022 Microchip Technology Inc. All rights reserved.
  */
-#include <linux/auxiliary_bus.h>
 #include <linux/clk-provider.h>
 #include <linux/io.h>
+#include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
-#include <linux/slab.h>
+#include <linux/regmap.h>
 #include <dt-bindings/clock/microchip,mpfs-clock.h>
 #include <soc/microchip/mpfs.h>
+#include <linux/clk/clk-regmap.h>
 
 /* address offset of control registers */
 #define REG_MSSPLL_REF_CR	0x08u
-#define REG_MSSPLL_POSTDIV_CR	0x10u
+#define REG_MSSPLL_POSTDIV01_CR	0x10u
+#define REG_MSSPLL_POSTDIV23_CR	0x14u
 #define REG_MSSPLL_SSCG_2_CR	0x2Cu
 #define REG_CLOCK_CONFIG_CR	0x08u
 #define REG_RTC_CLOCK_CR	0x0Cu
@@ -26,12 +28,29 @@
 #define MSSPLL_FBDIV_WIDTH	0x0Cu
 #define MSSPLL_REFDIV_SHIFT	0x08u
 #define MSSPLL_REFDIV_WIDTH	0x06u
-#define MSSPLL_POSTDIV_SHIFT	0x08u
+#define MSSPLL_POSTDIV02_SHIFT	0x08u
+#define MSSPLL_POSTDIV13_SHIFT	0x18u
 #define MSSPLL_POSTDIV_WIDTH	0x07u
 #define MSSPLL_FIXED_DIV	4u
 
+static const struct regmap_config clk_mpfs_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.val_format_endian = REGMAP_ENDIAN_LITTLE,
+	.max_register = REG_SUBBLK_CLOCK_CR,
+};
+
+/*
+ * This clock ID is defined here, rather than the binding headers, as it is an
+ * internal clock only, and therefore has no consumers in other peripheral
+ * blocks.
+ */
+#define CLK_MSSPLL_INTERNAL	38u
+
 struct mpfs_clock_data {
 	struct device *dev;
+	struct regmap *regmap;
 	void __iomem *base;
 	void __iomem *msspll_base;
 	struct clk_hw_onecell_data hw_data;
@@ -39,26 +58,36 @@
 
 struct mpfs_msspll_hw_clock {
 	void __iomem *base;
+	struct clk_hw hw;
+	struct clk_init_data init;
 	unsigned int id;
 	u32 reg_offset;
 	u32 shift;
 	u32 width;
 	u32 flags;
-	struct clk_hw hw;
-	struct clk_init_data init;
 };
 
 #define to_mpfs_msspll_clk(_hw) container_of(_hw, struct mpfs_msspll_hw_clock, hw)
 
-struct mpfs_cfg_hw_clock {
-	struct clk_divider cfg;
+struct mpfs_msspll_out_hw_clock {
+	void __iomem *base;
+	struct clk_divider output;
 	struct clk_init_data init;
 	unsigned int id;
 	u32 reg_offset;
 };
 
+#define to_mpfs_msspll_out_clk(_hw) container_of(_hw, struct mpfs_msspll_out_hw_clock, hw)
+
+struct mpfs_cfg_hw_clock {
+	struct clk_regmap sigh;
+	struct clk_regmap_div_data cfg;
+	unsigned int id;
+};
+
 struct mpfs_periph_hw_clock {
-	struct clk_gate periph;
+	struct clk_regmap sigh;
+	struct clk_regmap_gate_data periph;
 	unsigned int id;
 };
 
@@ -93,93 +122,40 @@
 	{ 0, 0 }
 };
 
-static unsigned long mpfs_clk_msspll_recalc_rate(struct clk_hw *hw, unsigned long prate)
-{
-	struct mpfs_msspll_hw_clock *msspll_hw = to_mpfs_msspll_clk(hw);
-	void __iomem *mult_addr = msspll_hw->base + msspll_hw->reg_offset;
-	void __iomem *ref_div_addr = msspll_hw->base + REG_MSSPLL_REF_CR;
-	void __iomem *postdiv_addr = msspll_hw->base + REG_MSSPLL_POSTDIV_CR;
-	u32 mult, ref_div, postdiv;
-
-	mult = readl_relaxed(mult_addr) >> MSSPLL_FBDIV_SHIFT;
-	mult &= clk_div_mask(MSSPLL_FBDIV_WIDTH);
-	ref_div = readl_relaxed(ref_div_addr) >> MSSPLL_REFDIV_SHIFT;
-	ref_div &= clk_div_mask(MSSPLL_REFDIV_WIDTH);
-	postdiv = readl_relaxed(postdiv_addr) >> MSSPLL_POSTDIV_SHIFT;
-	postdiv &= clk_div_mask(MSSPLL_POSTDIV_WIDTH);
-
-	return prate * mult / (ref_div * MSSPLL_FIXED_DIV * postdiv);
-}
+/*
+ * MSS PLL internal clock
+ */
 
-static long mpfs_clk_msspll_round_rate(struct clk_hw *hw, unsigned long rate, unsigned long *prate)
+static unsigned long mpfs_clk_msspll_recalc_rate(struct clk_hw *hw, unsigned long prate)
 {
 	struct mpfs_msspll_hw_clock *msspll_hw = to_mpfs_msspll_clk(hw);
 	void __iomem *mult_addr = msspll_hw->base + msspll_hw->reg_offset;
 	void __iomem *ref_div_addr = msspll_hw->base + REG_MSSPLL_REF_CR;
 	u32 mult, ref_div;
-	unsigned long rate_before_ctrl;
-
-	mult = readl_relaxed(mult_addr) >> MSSPLL_FBDIV_SHIFT;
-	mult &= clk_div_mask(MSSPLL_FBDIV_WIDTH);
-	ref_div = readl_relaxed(ref_div_addr) >> MSSPLL_REFDIV_SHIFT;
-	ref_div &= clk_div_mask(MSSPLL_REFDIV_WIDTH);
-
-	rate_before_ctrl = rate * (ref_div * MSSPLL_FIXED_DIV) / mult;
-
-	return divider_round_rate(hw, rate_before_ctrl, prate, NULL, MSSPLL_POSTDIV_WIDTH,
-				  msspll_hw->flags);
-}
-
-static int mpfs_clk_msspll_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long prate)
-{
-	struct mpfs_msspll_hw_clock *msspll_hw = to_mpfs_msspll_clk(hw);
-	void __iomem *mult_addr = msspll_hw->base + msspll_hw->reg_offset;
-	void __iomem *ref_div_addr = msspll_hw->base + REG_MSSPLL_REF_CR;
-	void __iomem *postdiv_addr = msspll_hw->base + REG_MSSPLL_POSTDIV_CR;
-	u32 mult, ref_div, postdiv;
-	int divider_setting;
-	unsigned long rate_before_ctrl, flags;
 
 	mult = readl_relaxed(mult_addr) >> MSSPLL_FBDIV_SHIFT;
 	mult &= clk_div_mask(MSSPLL_FBDIV_WIDTH);
 	ref_div = readl_relaxed(ref_div_addr) >> MSSPLL_REFDIV_SHIFT;
 	ref_div &= clk_div_mask(MSSPLL_REFDIV_WIDTH);
 
-	rate_before_ctrl = rate * (ref_div * MSSPLL_FIXED_DIV) / mult;
-	divider_setting = divider_get_val(rate_before_ctrl, prate, NULL, MSSPLL_POSTDIV_WIDTH,
-					  msspll_hw->flags);
-
-	if (divider_setting < 0)
-		return divider_setting;
-
-	spin_lock_irqsave(&mpfs_clk_lock, flags);
-
-	postdiv = readl_relaxed(postdiv_addr);
-	postdiv &= ~(clk_div_mask(MSSPLL_POSTDIV_WIDTH) << MSSPLL_POSTDIV_SHIFT);
-	writel_relaxed(postdiv, postdiv_addr);
-
-	spin_unlock_irqrestore(&mpfs_clk_lock, flags);
-
-	return 0;
+	return prate * mult / (ref_div * MSSPLL_FIXED_DIV);
 }
 
 static const struct clk_ops mpfs_clk_msspll_ops = {
 	.recalc_rate = mpfs_clk_msspll_recalc_rate,
-	.round_rate = mpfs_clk_msspll_round_rate,
-	.set_rate = mpfs_clk_msspll_set_rate,
 };
 
 #define CLK_PLL(_id, _name, _parent, _shift, _width, _flags, _offset) {			\
 	.id = _id,									\
+	.flags = _flags,								\
 	.shift = _shift,								\
 	.width = _width,								\
 	.reg_offset = _offset,								\
-	.flags = _flags,								\
 	.hw.init = CLK_HW_INIT_PARENTS_DATA(_name, _parent, &mpfs_clk_msspll_ops, 0),	\
 }
 
 static struct mpfs_msspll_hw_clock mpfs_msspll_clks[] = {
-	CLK_PLL(CLK_MSSPLL, "clk_msspll", mpfs_ext_ref, MSSPLL_FBDIV_SHIFT,
+	CLK_PLL(CLK_MSSPLL_INTERNAL, "clk_msspll_internal", mpfs_ext_ref, MSSPLL_FBDIV_SHIFT,
 		MSSPLL_FBDIV_WIDTH, 0, REG_MSSPLL_SSCG_2_CR),
 };
 
@@ -196,7 +172,7 @@
 		ret = devm_clk_hw_register(dev, &msspll_hw->hw);
 		if (ret)
 			return dev_err_probe(dev, ret, "failed to register msspll id: %d\n",
-					     CLK_MSSPLL);
+					     CLK_MSSPLL_INTERNAL);
 
 		data->hw_data.hws[msspll_hw->id] = &msspll_hw->hw;
 	}
@@ -205,6 +181,54 @@
 }
 
 /*
+ * MSS PLL output clocks
+ */
+
+#define CLK_PLL_OUT(_id, _name, _parent, _flags, _shift, _width, _offset) {	\
+	.id = _id,								\
+	.output.shift = _shift,							\
+	.output.width = _width,							\
+	.output.table = NULL,							\
+	.reg_offset = _offset,							\
+	.output.flags = _flags,							\
+	.output.hw.init = CLK_HW_INIT(_name, _parent, &clk_divider_ops, 0),	\
+	.output.lock = &mpfs_clk_lock,						\
+}
+
+static struct mpfs_msspll_out_hw_clock mpfs_msspll_out_clks[] = {
+	CLK_PLL_OUT(CLK_MSSPLL0, "clk_msspll", "clk_msspll_internal", CLK_DIVIDER_ONE_BASED,
+		    MSSPLL_POSTDIV02_SHIFT, MSSPLL_POSTDIV_WIDTH, REG_MSSPLL_POSTDIV01_CR),
+	CLK_PLL_OUT(CLK_MSSPLL1, "clk_msspll1", "clk_msspll_internal", CLK_DIVIDER_ONE_BASED,
+		    MSSPLL_POSTDIV13_SHIFT, MSSPLL_POSTDIV_WIDTH, REG_MSSPLL_POSTDIV01_CR),
+	CLK_PLL_OUT(CLK_MSSPLL2, "clk_msspll2", "clk_msspll_internal", CLK_DIVIDER_ONE_BASED,
+		    MSSPLL_POSTDIV02_SHIFT, MSSPLL_POSTDIV_WIDTH, REG_MSSPLL_POSTDIV23_CR),
+	CLK_PLL_OUT(CLK_MSSPLL3, "clk_msspll3", "clk_msspll_internal", CLK_DIVIDER_ONE_BASED,
+		    MSSPLL_POSTDIV13_SHIFT, MSSPLL_POSTDIV_WIDTH, REG_MSSPLL_POSTDIV23_CR),
+};
+
+static int mpfs_clk_register_msspll_outs(struct device *dev,
+					 struct mpfs_msspll_out_hw_clock *msspll_out_hws,
+					 unsigned int num_clks, struct mpfs_clock_data *data)
+{
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < num_clks; i++) {
+		struct mpfs_msspll_out_hw_clock *msspll_out_hw = &msspll_out_hws[i];
+
+		msspll_out_hw->output.reg = data->msspll_base + msspll_out_hw->reg_offset;
+		ret = devm_clk_hw_register(dev, &msspll_out_hw->output.hw);
+		if (ret)
+			return dev_err_probe(dev, ret, "failed to register msspll out id: %d\n",
+					     msspll_out_hw->id);
+
+		data->hw_data.hws[msspll_out_hw->id] = &msspll_out_hw->output.hw;
+	}
+
+	return 0;
+}
+
+/*
  * "CFG" clocks
  */
 
@@ -213,10 +237,9 @@
 	.cfg.shift = _shift,								\
 	.cfg.width = _width,								\
 	.cfg.table = _table,								\
-	.reg_offset = _offset,								\
+	.cfg.offset = _offset,								\
 	.cfg.flags = _flags,								\
-	.cfg.hw.init = CLK_HW_INIT(_name, _parent, &clk_divider_ops, 0),		\
-	.cfg.lock = &mpfs_clk_lock,							\
+	.sigh.hw.init = CLK_HW_INIT(_name, _parent, &clk_regmap_divider_ops, 0),	\
 }
 
 #define CLK_CPU_OFFSET		0u
@@ -236,10 +259,10 @@
 		.cfg.shift = 0,
 		.cfg.width = 12,
 		.cfg.table = mpfs_div_rtcref_table,
-		.reg_offset = REG_RTC_CLOCK_CR,
+		.cfg.offset = REG_RTC_CLOCK_CR,
 		.cfg.flags = CLK_DIVIDER_ONE_BASED,
-		.cfg.hw.init =
-			CLK_HW_INIT_PARENTS_DATA("clk_rtcref", mpfs_ext_ref, &clk_divider_ops, 0),
+		.sigh.hw.init =
+			CLK_HW_INIT_PARENTS_DATA("clk_rtcref", mpfs_ext_ref, &clk_regmap_divider_ops, 0),
 	}
 };
 
@@ -252,14 +275,16 @@
 	for (i = 0; i < num_clks; i++) {
 		struct mpfs_cfg_hw_clock *cfg_hw = &cfg_hws[i];
 
-		cfg_hw->cfg.reg = data->base + cfg_hw->reg_offset;
-		ret = devm_clk_hw_register(dev, &cfg_hw->cfg.hw);
+		cfg_hw->sigh.map = data->regmap;
+		cfg_hw->sigh.data = &cfg_hw->cfg;
+
+		ret = devm_clk_hw_register(dev, &cfg_hw->sigh.hw);
 		if (ret)
 			return dev_err_probe(dev, ret, "failed to register clock id: %d\n",
 					     cfg_hw->id);
 
 		id = cfg_hw->id;
-		data->hw_data.hws[id] = &cfg_hw->cfg.hw;
+		data->hw_data.hws[id] = &cfg_hw->sigh.hw;
 	}
 
 	return 0;
@@ -271,13 +296,13 @@
 
 #define CLK_PERIPH(_id, _name, _parent, _shift, _flags) {			\
 	.id = _id,								\
+	.periph.offset = REG_SUBBLK_CLOCK_CR,					\
 	.periph.bit_idx = _shift,						\
-	.periph.hw.init = CLK_HW_INIT_HW(_name, _parent, &clk_gate_ops,		\
-				  _flags),					\
-	.periph.lock = &mpfs_clk_lock,						\
+	.sigh.hw.init = CLK_HW_INIT_HW(_name, _parent, &clk_regmap_gate_ops,	\
+					 _flags),				\
 }
 
-#define PARENT_CLK(PARENT) (&mpfs_cfg_clks[CLK_##PARENT##_OFFSET].cfg.hw)
+#define PARENT_CLK(PARENT) (&mpfs_cfg_clks[CLK_##PARENT##_OFFSET].sigh.hw)
 
 /*
  * Critical clocks:
@@ -334,106 +359,20 @@
 	for (i = 0; i < num_clks; i++) {
 		struct mpfs_periph_hw_clock *periph_hw = &periph_hws[i];
 
-		periph_hw->periph.reg = data->base + REG_SUBBLK_CLOCK_CR;
-		ret = devm_clk_hw_register(dev, &periph_hw->periph.hw);
+		periph_hw->sigh.map = data->regmap;
+		periph_hw->sigh.data = &periph_hw->periph;
+		ret = devm_clk_hw_register(dev, &periph_hw->sigh.hw);
 		if (ret)
 			return dev_err_probe(dev, ret, "failed to register clock id: %d\n",
 					     periph_hw->id);
 
 		id = periph_hws[i].id;
-		data->hw_data.hws[id] = &periph_hw->periph.hw;
+		data->hw_data.hws[id] = &periph_hw->sigh.hw;
 	}
 
 	return 0;
 }
 
-/*
- * Peripheral clock resets
- */
-
-#if IS_ENABLED(CONFIG_RESET_CONTROLLER)
-
-u32 mpfs_reset_read(struct device *dev)
-{
-	struct mpfs_clock_data *clock_data = dev_get_drvdata(dev->parent);
-
-	return readl_relaxed(clock_data->base + REG_SUBBLK_RESET_CR);
-}
-EXPORT_SYMBOL_NS_GPL(mpfs_reset_read, MCHP_CLK_MPFS);
-
-void mpfs_reset_write(struct device *dev, u32 val)
-{
-	struct mpfs_clock_data *clock_data = dev_get_drvdata(dev->parent);
-
-	writel_relaxed(val, clock_data->base + REG_SUBBLK_RESET_CR);
-}
-EXPORT_SYMBOL_NS_GPL(mpfs_reset_write, MCHP_CLK_MPFS);
-
-static void mpfs_reset_unregister_adev(void *_adev)
-{
-	struct auxiliary_device *adev = _adev;
-
-	auxiliary_device_delete(adev);
-	auxiliary_device_uninit(adev);
-}
-
-static void mpfs_reset_adev_release(struct device *dev)
-{
-	struct auxiliary_device *adev = to_auxiliary_dev(dev);
-
-	kfree(adev);
-}
-
-static struct auxiliary_device *mpfs_reset_adev_alloc(struct mpfs_clock_data *clk_data)
-{
-	struct auxiliary_device *adev;
-	int ret;
-
-	adev = kzalloc(sizeof(*adev), GFP_KERNEL);
-	if (!adev)
-		return ERR_PTR(-ENOMEM);
-
-	adev->name = "reset-mpfs";
-	adev->dev.parent = clk_data->dev;
-	adev->dev.release = mpfs_reset_adev_release;
-	adev->id = 666u;
-
-	ret = auxiliary_device_init(adev);
-	if (ret) {
-		kfree(adev);
-		return ERR_PTR(ret);
-	}
-
-	return adev;
-}
-
-static int mpfs_reset_controller_register(struct mpfs_clock_data *clk_data)
-{
-	struct auxiliary_device *adev;
-	int ret;
-
-	adev = mpfs_reset_adev_alloc(clk_data);
-	if (IS_ERR(adev))
-		return PTR_ERR(adev);
-
-	ret = auxiliary_device_add(adev);
-	if (ret) {
-		auxiliary_device_uninit(adev);
-		return ret;
-	}
-
-	return devm_add_action_or_reset(clk_data->dev, mpfs_reset_unregister_adev, adev);
-}
-
-#else /* !CONFIG_RESET_CONTROLLER */
-
-static int mpfs_reset_controller_register(struct mpfs_clock_data *clk_data)
-{
-	return 0;
-}
-
-#endif /* !CONFIG_RESET_CONTROLLER */
-
 static int mpfs_clk_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -442,13 +381,26 @@
 	int ret;
 
 	/* CLK_RESERVED is not part of clock arrays, so add 1 */
-	num_clks = ARRAY_SIZE(mpfs_msspll_clks) + ARRAY_SIZE(mpfs_cfg_clks)
-		   + ARRAY_SIZE(mpfs_periph_clks) + 1;
+	num_clks = ARRAY_SIZE(mpfs_msspll_clks) + ARRAY_SIZE(mpfs_msspll_out_clks)
+		   + ARRAY_SIZE(mpfs_cfg_clks)  + ARRAY_SIZE(mpfs_periph_clks) + 1;
 
 	clk_data = devm_kzalloc(dev, struct_size(clk_data, hw_data.hws, num_clks), GFP_KERNEL);
 	if (!clk_data)
 		return -ENOMEM;
 
+	clk_data->regmap = syscon_regmap_lookup_by_compatible("microchip,mpfs-mss-top-sysreg");
+	if (IS_ERR(clk_data->regmap)) {
+		clk_data->regmap = NULL;
+		goto old_format;
+	}
+
+	clk_data->msspll_base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(clk_data->msspll_base))
+		return PTR_ERR(clk_data->msspll_base);
+
+	goto done;
+
+old_format:
 	clk_data->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(clk_data->base))
 		return PTR_ERR(clk_data->base);
@@ -457,6 +409,14 @@
 	if (IS_ERR(clk_data->msspll_base))
 		return PTR_ERR(clk_data->msspll_base);
 
+	clk_data->regmap = devm_regmap_init_mmio(dev, clk_data->base, &clk_mpfs_regmap_config);
+	if (IS_ERR(clk_data->regmap))
+		return PTR_ERR(clk_data->regmap);
+
+	ret = mpfs_reset_controller_register(dev, clk_data->base + REG_SUBBLK_RESET_CR);
+	if (ret)
+		return ret;
+done:
 	clk_data->hw_data.num = num_clks;
 	clk_data->dev = dev;
 	dev_set_drvdata(dev, clk_data);
@@ -466,20 +426,22 @@
 	if (ret)
 		return ret;
 
-	ret = mpfs_clk_register_cfgs(dev, mpfs_cfg_clks, ARRAY_SIZE(mpfs_cfg_clks), clk_data);
+	ret = mpfs_clk_register_msspll_outs(dev, mpfs_msspll_out_clks,
+					    ARRAY_SIZE(mpfs_msspll_out_clks),
+					    clk_data);
 	if (ret)
 		return ret;
 
-	ret = mpfs_clk_register_periphs(dev, mpfs_periph_clks, ARRAY_SIZE(mpfs_periph_clks),
-					clk_data);
+	ret = mpfs_clk_register_cfgs(dev, mpfs_cfg_clks, ARRAY_SIZE(mpfs_cfg_clks), clk_data);
 	if (ret)
 		return ret;
 
-	ret = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, &clk_data->hw_data);
+	ret = mpfs_clk_register_periphs(dev, mpfs_periph_clks, ARRAY_SIZE(mpfs_periph_clks),
+					clk_data);
 	if (ret)
 		return ret;
 
-	return mpfs_reset_controller_register(clk_data);
+	return devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, &clk_data->hw_data);
 }
 
 static const struct of_device_id mpfs_clk_of_match_table[] = {
@@ -512,3 +474,4 @@
 MODULE_AUTHOR("Padmarao Begari <padmarao.begari@microchip.com>");
 MODULE_AUTHOR("Daire McNamara <daire.mcnamara@microchip.com>");
 MODULE_AUTHOR("Conor Dooley <conor.dooley@microchip.com>");
+MODULE_IMPORT_NS(MCHP_CLK_MPFS);
--- linux-6.6.51/include/dt-bindings/clock/at91.h	2024-12-05 13:07:56.445747000 +0900
+++ linux4microchip-fpga-2024.09/include/dt-bindings/clock/at91.h	2024-12-04 16:41:36.838408700 +0900
@@ -37,6 +37,13 @@
 #define PMC_ETHPLL		(PMC_MAIN + 8)
 #define PMC_CPU			(PMC_MAIN + 9)
 #define PMC_MCK1		(PMC_MAIN + 10)
+#define UTMI1			0
+#define UTMI2			1
+#define UTMI3			2
+
+/* SAM9X7 */
+#define PMC_PLLADIV2		(PMC_MAIN + 11)
+#define PMC_LVDSPLL		(PMC_MAIN + 12)
 
 #ifndef AT91_PMC_MOSCS
 #define AT91_PMC_MOSCS		0		/* MOSCS Flag */
@@ -51,4 +58,149 @@
 #define AT91_PMC_GCKRDY		24		/* Generated Clocks */
 #endif
 
+#define AT91_SCMI_CLK_CORE_MCK		0
+#define AT91_SCMI_CLK_CORE_UTMI		1
+#define AT91_SCMI_CLK_CORE_MAIN		2
+#define AT91_SCMI_CLK_CORE_MCK2		3
+#define AT91_SCMI_CLK_CORE_I2S0_MUX	4
+#define AT91_SCMI_CLK_CORE_I2S1_MUX	5
+#define AT91_SCMI_CLK_CORE_PLLACK	6
+#define AT91_SCMI_CLK_CORE_PLLBCK	7
+#define AT91_SCMI_CLK_CORE_AUDIOPLLCK	8
+#define AT91_SCMI_CLK_CORE_MCK_PRES	9
+
+#define AT91_SCMI_CLK_SYSTEM_DDRCK	10
+#define AT91_SCMI_CLK_SYSTEM_LCDCK	11
+#define AT91_SCMI_CLK_SYSTEM_UHPCK	12
+#define AT91_SCMI_CLK_SYSTEM_UDPCK	13
+#define AT91_SCMI_CLK_SYSTEM_PCK0	14
+#define AT91_SCMI_CLK_SYSTEM_PCK1	15
+#define AT91_SCMI_CLK_SYSTEM_PCK2	16
+#define AT91_SCMI_CLK_SYSTEM_ISCCK	17
+
+#define AT91_SCMI_CLK_PERIPH_MACB0_CLK		18
+#define AT91_SCMI_CLK_PERIPH_TDES_CLK		19
+#define AT91_SCMI_CLK_PERIPH_MATRIX1_CLK	20
+#define AT91_SCMI_CLK_PERIPH_HSMC_CLK		21
+#define AT91_SCMI_CLK_PERIPH_PIOA_CLK		22
+#define AT91_SCMI_CLK_PERIPH_FLX0_CLK		23
+#define AT91_SCMI_CLK_PERIPH_FLX1_CLK		24
+#define AT91_SCMI_CLK_PERIPH_FLX2_CLK		25
+#define AT91_SCMI_CLK_PERIPH_FLX3_CLK		26
+#define AT91_SCMI_CLK_PERIPH_FLX4_CLK		27
+#define AT91_SCMI_CLK_PERIPH_UART0_CLK		28
+#define AT91_SCMI_CLK_PERIPH_UART1_CLK		29
+#define AT91_SCMI_CLK_PERIPH_UART2_CLK		30
+#define AT91_SCMI_CLK_PERIPH_UART3_CLK		31
+#define AT91_SCMI_CLK_PERIPH_UART4_CLK		32
+#define AT91_SCMI_CLK_PERIPH_TWI0_CLK		33
+#define AT91_SCMI_CLK_PERIPH_TWI1_CLK		34
+#define AT91_SCMI_CLK_PERIPH_SPI0_CLK		35
+#define AT91_SCMI_CLK_PERIPH_SPI1_CLK		36
+#define AT91_SCMI_CLK_PERIPH_TCB0_CLK		37
+#define AT91_SCMI_CLK_PERIPH_TCB1_CLK		38
+#define AT91_SCMI_CLK_PERIPH_PWM_CLK		39
+#define AT91_SCMI_CLK_PERIPH_ADC_CLK		40
+#define AT91_SCMI_CLK_PERIPH_UHPHS_CLK		41
+#define AT91_SCMI_CLK_PERIPH_UDPHS_CLK		42
+#define AT91_SCMI_CLK_PERIPH_SSC0_CLK		43
+#define AT91_SCMI_CLK_PERIPH_SSC1_CLK		44
+#define AT91_SCMI_CLK_PERIPH_TRNG_CLK		45
+#define AT91_SCMI_CLK_PERIPH_PDMIC_CLK		46
+#define AT91_SCMI_CLK_PERIPH_SECURAM_CLK	47
+#define AT91_SCMI_CLK_PERIPH_I2S0_CLK		48
+#define AT91_SCMI_CLK_PERIPH_I2S1_CLK		49
+#define AT91_SCMI_CLK_PERIPH_CAN0_CLK		50
+#define AT91_SCMI_CLK_PERIPH_CAN1_CLK		51
+#define AT91_SCMI_CLK_PERIPH_PTC_CLK		52
+#define AT91_SCMI_CLK_PERIPH_CLASSD_CLK		53
+#define AT91_SCMI_CLK_PERIPH_DMA0_CLK		54
+#define AT91_SCMI_CLK_PERIPH_DMA1_CLK		55
+#define AT91_SCMI_CLK_PERIPH_AES_CLK		56
+#define AT91_SCMI_CLK_PERIPH_AESB_CLK		57
+#define AT91_SCMI_CLK_PERIPH_SHA_CLK		58
+#define AT91_SCMI_CLK_PERIPH_MPDDR_CLK		59
+#define AT91_SCMI_CLK_PERIPH_MATRIX0_CLK	60
+#define AT91_SCMI_CLK_PERIPH_SDMMC0_HCLK	61
+#define AT91_SCMI_CLK_PERIPH_SDMMC1_HCLK	62
+#define AT91_SCMI_CLK_PERIPH_LCDC_CLK		63
+#define AT91_SCMI_CLK_PERIPH_ISC_CLK		64
+#define AT91_SCMI_CLK_PERIPH_QSPI0_CLK		65
+#define AT91_SCMI_CLK_PERIPH_QSPI1_CLK		66
+
+#define AT91_SCMI_CLK_GCK_SDMMC0_GCLK	67
+#define AT91_SCMI_CLK_GCK_SDMMC1_GCLK	68
+#define AT91_SCMI_CLK_GCK_TCB0_GCLK	69
+#define AT91_SCMI_CLK_GCK_TCB1_GCLK	70
+#define AT91_SCMI_CLK_GCK_PWM_GCLK	71
+#define AT91_SCMI_CLK_GCK_ISC_GCLK	72
+#define AT91_SCMI_CLK_GCK_PDMIC_GCLK	73
+#define AT91_SCMI_CLK_GCK_I2S0_GCLK	74
+#define AT91_SCMI_CLK_GCK_I2S1_GCLK	75
+#define AT91_SCMI_CLK_GCK_CAN0_GCLK	76
+#define AT91_SCMI_CLK_GCK_CAN1_GCLK	77
+#define AT91_SCMI_CLK_GCK_CLASSD_GCLK	78
+
+#define AT91_SCMI_CLK_PROG_PROG0	79
+#define AT91_SCMI_CLK_PROG_PROG1	80
+#define AT91_SCMI_CLK_PROG_PROG2	81
+
+#define AT91_SCMI_CLK_SCKC_SLOWCK_32K	82
+
+/* SAMA7G5 */
+#define AT91_SCMI_CLK_CORE_CPUPLLCK		4
+#define AT91_SCMI_CLK_CORE_SYSPLLCK		5
+#define AT91_SCMI_CLK_CORE_DDRPLLCK		6
+#define AT91_SCMI_CLK_CORE_IMGPLLCK		7
+#define AT91_SCMI_CLK_CORE_ETHPLLCK		10
+#define AT91_SCMI_CLK_SYSTEM_PCK3		11
+#define AT91_SCMI_CLK_SYSTEM_PCK4		12
+#define AT91_SCMI_CLK_SYSTEM_PCK5		13
+#define AT91_SCMI_CLK_SYSTEM_PCK6		17
+#define AT91_SCMI_CLK_SYSTEM_PCK7		20
+#define AT91_SCMI_CLK_PERIPH_DMA2_CLK		100
+#define AT91_SCMI_CLK_PERIPH_FLX5_CLK		28
+#define AT91_SCMI_CLK_PERIPH_FLX6_CLK		29
+#define AT91_SCMI_CLK_PERIPH_FLX7_CLK		30
+#define AT91_SCMI_CLK_PERIPH_FLX8_CLK		31
+#define AT91_SCMI_CLK_PERIPH_FLX9_CLK		32
+#define AT91_SCMI_CLK_PERIPH_FLX10_CLK		33
+#define AT91_SCMI_CLK_PERIPH_FLX11_CLK		34
+#define AT91_SCMI_CLK_PERIPH_UDPHSB_CLK		35
+#define AT91_SCMI_CLK_PERIPH_PDMC1_CLK		36
+#define AT91_SCMI_CLK_PERIPH_UDPHSA_CLK		42
+#define AT91_SCMI_CLK_GCK_ADC_GCLK		40
+#define AT91_SCMI_CLK_PERIPH_PDMC0_CLK		46
+#define AT91_SCMI_CLK_PERIPH_CAN2_CLK		52
+#define AT91_SCMI_CLK_PERIPH_CAN3_CLK		53
+#define AT91_SCMI_CLK_PERIPH_CAN4_CLK		59
+#define AT91_SCMI_CLK_PERIPH_CAN5_CLK		60
+#define AT91_SCMI_CLK_PERIPH_SDMMC2_HCLK	63
+#define AT91_SCMI_CLK_GCK_SDMMC2_GCLK		71
+#define AT91_SCMI_CLK_GCK_MACB0_GCLK		72
+#define AT91_SCMI_CLK_GCK_MACB0_TSU		73
+#define AT91_SCMI_CLK_GCK_CAN2_GCLK		78
+#define AT91_SCMI_CLK_GCK_CAN3_GCLK		79
+#define AT91_SCMI_CLK_GCK_CAN4_GCLK		80
+#define AT91_SCMI_CLK_GCK_CAN5_GCLK		81
+#define AT91_SCMI_CLK_PERIPH_SPDIFRX_CLK	83
+#define AT91_SCMI_CLK_PERIPH_SPDIFTX_CLK	84
+#define AT91_SCMI_CLK_GCK_QSPI0_GCLK		85
+#define AT91_SCMI_CLK_GCK_QSPI1_GCLK		86
+#define AT91_SCMI_CLK_GCK_SPDIFRX_GCLK		87
+#define AT91_SCMI_CLK_GCK_SPDIFTX_GCLK		88
+#define AT91_SCMI_CLK_GCK_MACB1_GCLK		89
+#define AT91_SCMI_CLK_PERIPH_MACB1_CLK		90
+#define AT91_SCMI_CLK_GCK_MACB1_TSU		91
+#define AT91_SCMI_CLK_PERIPH_CSI_CLK		92
+#define AT91_SCMI_CLK_GCK_CSI_GCLK		93
+#define AT91_SCMI_CLK_PERIPH_CSI2DC_CLK		94
+#define AT91_SCMI_CLK_PERIPH_ASRC_CLK		95
+#define AT91_SCMI_CLK_GCK_ASRC_GCLK		96
+#define AT91_SCMI_CLK_UTMI1			97
+#define AT91_SCMI_CLK_UTMI2			98
+#define AT91_SCMI_CLK_UTMI3			99
+#define AT91_SCMI_CLK_PERIPH_DMA2_CLK		100
+#define AT91_SCMI_CLK_CPU_OPP			101
+
 #endif
--- linux-6.6.51/include/dt-bindings/clock/microchip,mpfs-clock.h	2024-12-05 13:07:56.487635200 +0900
+++ linux4microchip-fpga-2024.09/include/dt-bindings/clock/microchip,mpfs-clock.h	2024-12-04 16:41:36.880296900 +0900
@@ -44,6 +44,11 @@
 
 #define CLK_RTCREF	33
 #define CLK_MSSPLL	34
+#define CLK_MSSPLL0	34
+#define CLK_MSSPLL1	35
+#define CLK_MSSPLL2	36
+#define CLK_MSSPLL3	37
+/* 38 is reserved for MSS PLL internals */
 
 /* Clock Conditioning Circuitry Clock IDs */
 
--- /dev/null
+++ linux4microchip-fpga-2024.09/include/linux/clk/clk-regmap.h	2024-12-04 16:41:37.269256000 +0900
@@ -0,0 +1,137 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 BayLibre, SAS.
+ * Author: Jerome Brunet <jbrunet@baylibre.com>
+ */
+
+#ifndef __CLK_REGMAP_H
+#define __CLK_REGMAP_H
+
+#include <linux/clk-provider.h>
+#include <linux/regmap.h>
+
+/**
+ * struct clk_regmap - regmap backed clock
+ *
+ * @hw:		handle between common and hardware-specific interfaces
+ * @map:	pointer to the regmap structure controlling the clock
+ * @data:	data specific to the clock type
+ *
+ * Clock which is controlled by regmap backed registers. The actual type of
+ * of the clock is controlled by the clock_ops and data.
+ */
+struct clk_regmap {
+	struct clk_hw	hw;
+	struct regmap	*map;
+	void		*data;
+};
+
+static inline struct clk_regmap *to_clk_regmap(struct clk_hw *hw)
+{
+	return container_of(hw, struct clk_regmap, hw);
+}
+
+/**
+ * struct clk_regmap_gate_data - regmap backed gate specific data
+ *
+ * @offset:	offset of the register controlling gate
+ * @bit_idx:	single bit controlling gate
+ * @flags:	hardware-specific flags
+ *
+ * Flags:
+ * Same as clk_gate except CLK_GATE_HIWORD_MASK which is ignored
+ */
+struct clk_regmap_gate_data {
+	unsigned int	offset;
+	u8		bit_idx;
+	u8		flags;
+};
+
+static inline struct clk_regmap_gate_data *
+clk_get_regmap_gate_data(struct clk_regmap *clk)
+{
+	return (struct clk_regmap_gate_data *)clk->data;
+}
+
+extern const struct clk_ops clk_regmap_gate_ops;
+extern const struct clk_ops clk_regmap_gate_ro_ops;
+
+/**
+ * struct clk_regmap_div_data - regmap backed adjustable divider specific data
+ *
+ * @offset:	offset of the register controlling the divider
+ * @shift:	shift to the divider bit field
+ * @width:	width of the divider bit field
+ * @table:	array of value/divider pairs, last entry should have div = 0
+ *
+ * Flags:
+ * Same as clk_divider except CLK_DIVIDER_HIWORD_MASK which is ignored
+ */
+struct clk_regmap_div_data {
+	unsigned int	offset;
+	u8		shift;
+	u8		width;
+	u8		flags;
+	const struct clk_div_table	*table;
+};
+
+static inline struct clk_regmap_div_data *
+clk_get_regmap_div_data(struct clk_regmap *clk)
+{
+	return (struct clk_regmap_div_data *)clk->data;
+}
+
+extern const struct clk_ops clk_regmap_divider_ops;
+extern const struct clk_ops clk_regmap_divider_ro_ops;
+
+/**
+ * struct clk_regmap_mux_data - regmap backed multiplexer clock specific data
+ *
+ * @hw:		handle between common and hardware-specific interfaces
+ * @offset:	offset of theregister controlling multiplexer
+ * @table:	array of parent indexed register values
+ * @shift:	shift to multiplexer bit field
+ * @mask:	mask of mutliplexer bit field
+ * @flags:	hardware-specific flags
+ *
+ * Flags:
+ * Same as clk_divider except CLK_MUX_HIWORD_MASK which is ignored
+ */
+struct clk_regmap_mux_data {
+	unsigned int	offset;
+	u32		*table;
+	u32		mask;
+	u8		shift;
+	u8		flags;
+};
+
+static inline struct clk_regmap_mux_data *
+clk_get_regmap_mux_data(struct clk_regmap *clk)
+{
+	return (struct clk_regmap_mux_data *)clk->data;
+}
+
+extern const struct clk_ops clk_regmap_mux_ops;
+extern const struct clk_ops clk_regmap_mux_ro_ops;
+
+#define __MESON_PCLK(_name, _reg, _bit, _ops, _pname)			\
+struct clk_regmap _name = {						\
+	.data = &(struct clk_regmap_gate_data){				\
+		.offset = (_reg),					\
+		.bit_idx = (_bit),					\
+	},								\
+	.hw.init = &(struct clk_init_data) {				\
+		.name = #_name,						\
+		.ops = _ops,						\
+		.parent_hws = (const struct clk_hw *[]) { _pname },	\
+		.num_parents = 1,					\
+		.flags = (CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED),	\
+	},								\
+}
+
+#define MESON_PCLK(_name, _reg, _bit, _pname)	\
+	__MESON_PCLK(_name, _reg, _bit, &clk_regmap_gate_ops, _pname)
+
+#define MESON_PCLK_RO(_name, _reg, _bit, _pname)	\
+	__MESON_PCLK(_name, _reg, _bit, &clk_regmap_gate_ro_ops, _pname)
+#endif /* __CLK_REGMAP_H */
