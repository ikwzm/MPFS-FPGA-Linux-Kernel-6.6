--- /dev/null
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/media/microchip,fpga-dscmi.yaml	2024-12-04 16:41:10.250280500 +0900
@@ -0,0 +1,90 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/microchip,fpga-dscmi.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Microchip Digital Serial Camera Memory Interface
+
+maintainers:
+  - Shravan Chippa <shravan.chippa@microchip.com>
+
+description:
+  The Digital Serial Camera Memory Interface is a fabric-based video pipeline
+  used in Microchip's "Smart Embedded Vision" development kits. It captures raw
+  sRGB frames from a CSI2 interface, converts them to YUV422 & can convert to a
+  other formats, including H264 & MJPEG.
+
+properties:
+  compatible:
+    enum:
+      - microchip,fpga-dscmi
+      - microchip,fpga-dscmi-rtl-v2306  # Compatible hardware to enable/disable OSD feature
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  dmas:
+    maxItems: 1
+
+  dma-names:
+    items:
+      - const: rx
+
+  reset-gpios:
+    maxItems: 1
+    description: CSI2 module MIPI training reset
+
+  memory-region:
+    description:
+      This memory region is used for DMA transfers to/from the streaming
+      interface.
+    maxItems: 1
+
+  port:
+    $ref: /schemas/graph.yaml#/$defs/port-base
+    unevaluatedProperties: false
+    description:
+      supports a single port node with CSI2 interface.
+
+    properties:
+      endpoint:
+        $ref: /schemas/media/video-interfaces.yaml#
+        unevaluatedProperties: false
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - reset-gpios
+  - memory-region
+  - dmas
+  - dma-names
+  - port
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/gpio/gpio.h>
+
+    mchp_dscmi_cam0: video-pipeline@40000000 {
+        compatible = "microchip,fpga-dscmi";
+        reg = <0x40000000 0x2000>;
+        interrupt-parent = <&plic>;
+        interrupts = <118>;
+        reset-gpios = <&gpio2 4 GPIO_ACTIVE_HIGH>;
+        memory-region = <&cambuf0>;
+        dmas = <&pdma 0>;
+        dma-names = "rx";
+        port {
+            mchp_dscmi_ep_cam0: endpoint {
+                remote-endpoint = <&imx334_ep_cam0>;
+               };
+           };
+      };
+
+...
--- /dev/null
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/media/microchip,generic-video-pipeline-connector.yaml	2024-12-04 16:41:10.251278000 +0900
@@ -0,0 +1,215 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/microchip,generic-video-pipeline-connector.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Microchip Generic Video Pipeline Connector (GVPC)
+
+maintainers:
+  - Shravan Chippa <shravan.chippa@microchip.com>
+
+description: |
+  The Microchip generic video pipeline connector is used for the FPGA
+  logic to convert the video format and stream the data through
+  AXI streaming or negative interface for the image processing.
+
+properties:
+  compatible:
+    const: microchip,generic-video-pipeline-connector
+
+  reg:
+    maxItems: 1
+
+  ports:
+    $ref: /schemas/graph.yaml#/properties/ports
+
+    properties:
+      "#address-cells":
+        const: 1
+
+      "#size-cells":
+        const: 0
+
+      port@0:
+        type: object
+        description: Input/sink port node to receive the video data.
+
+        properties:
+          reg:
+            description: Input/sink port number.
+            const: 0
+
+          microchip,video-format:
+            description: Output/source video format. Possible values are as below.
+              0 - MVCF_MONO_SENSOR
+              1 - MVCF_YUV_444
+              2 - MVCF_YUV_422
+              3 - MVCF_YUV_420
+              4 - MVCF_RBG
+              5 - MVCF_H264
+              6 - MVCF_MJPEG
+              7 - MVCF_RGB
+            $ref: /schemas/types.yaml#/definitions/uint32
+            enum: [0, 1, 2, 3, 4, 5, 6, 7]
+
+          microchip,cfa-pattern:
+            description: Output/source video pattern.
+            $ref: /schemas/types.yaml#/definitions/string
+            enum:
+              - mono
+              - rggb
+              - bggr
+              - gbrg
+              - grbg
+            default: mono
+
+          microchip,video-width:
+            description: Output/source video axi stream width.
+            $ref: /schemas/types.yaml#/definitions/uint32
+            enum: [8, 10, 12, 16, 20, 32]
+
+          endpoint:
+            type: object
+
+            properties:
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        required:
+          - reg
+          - endpoint
+          - microchip,video-format
+          - microchip,video-width
+        allOf:
+          - if:
+              properties:
+                microchip,video-format:
+                  contains:
+                    const: 0
+            then:
+              required:
+                - microchip,cfa-pattern
+
+        additionalProperties: false
+
+    patternProperties:
+      "port@1":
+        type: object
+        description: Output/source port node to transmit the video data.
+        properties:
+          reg:
+            description: Output/source port number.
+
+          microchip,video-format:
+            description:
+              Output/source video format.
+              Possible values are as below -
+              0 - MVCF_MONO_SENSOR
+              1 - MVCF_YUV_444
+              2 - MVCF_YUV_422
+              3 - MVCF_YUV_420
+              4 - MVCF_RBG
+              5 - MVCF_H264
+              6 - MVCF_MJPEG
+              7 - MVCF_RGB
+            $ref: /schemas/types.yaml#/definitions/uint32
+            enum: [0, 1, 2, 3, 4, 5, 6, 7]
+
+          microchip,cfa-pattern:
+            description: Output/source video pattern.
+            $ref: /schemas/types.yaml#/definitions/string
+            enum:
+              - mono
+              - rggb
+              - bggr
+              - gbrg
+              - grbg
+            default: mono
+
+          microchip,video-width:
+            description: Output/source video axi stream width.
+            $ref: /schemas/types.yaml#/definitions/uint32
+            enum: [8, 10, 12, 16, 20, 32]
+
+          endpoint:
+            type: object
+
+            properties:
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        required:
+          - reg
+          - endpoint
+          - microchip,video-format
+          - microchip,video-width
+        allOf:
+          - if:
+              properties:
+                microchip,video-format:
+                  contains:
+                    const: 0
+            then:
+              required:
+                - microchip,cfa-pattern
+
+        additionalProperties: false
+
+    required:
+      - "#address-cells"
+      - "#size-cells"
+      - port@0
+      - port@1
+
+    additionalProperties: false
+
+required:
+  - compatible
+  - reg
+  - ports
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/media/microchip-common.h>
+
+    mgvpc_0: gvpc-video-0@50020000 {
+        compatible = "microchip,generic-video-pipeline-connector";
+        reg = <0x50020000 0x10000>;
+
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+
+            port@0 {
+                /* Sink port */
+                reg = <0>;
+                microchip,video-format = <MVCF_MONO_SENSOR>;
+                microchip,cfa-pattern = "rggb";
+                microchip,video-width = <8>;
+                gvpc_0_in: endpoint {
+                    remote-endpoint = <&mipi_csi2_0_out>;
+                };
+            };
+            port@1 {
+                /* Source port */
+                reg = <1>;
+                microchip,video-format = <MVCF_YUV_420>;
+                microchip,video-width = <8>;
+                gvpc_0_out: endpoint {
+                    remote-endpoint = <&h264_in>;
+                };
+            };
+        };
+    };
+...
--- /dev/null
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/media/microchip,image-enhancement.yaml	2024-12-04 16:41:10.251278000 +0900
@@ -0,0 +1,128 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/microchip,image-enhancement.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Microchip Video Image Enhancement
+
+maintainers:
+  - Shravan Chippa <shravan.chippa@microchip.com>
+
+description: |
+  The Microchip video image enhancement IP is used to control
+  the contrast, brightness etc of the video image and stream
+  the video data through AXI streaming interface or native
+  interface for image  processing.
+
+properties:
+  compatible:
+    enum:
+      - microchip,image-enhancement-rtl-v1
+
+  reg:
+    maxItems: 1
+
+  ports:
+    $ref: /schemas/graph.yaml#/properties/ports
+
+    properties:
+      "#address-cells":
+        const: 1
+
+      "#size-cells":
+        const: 0
+
+      port@0:
+        type: object
+        description: The Input/sink port node properties.
+        properties:
+          reg:
+            description: Input/sink port number.
+            const: 0
+
+          endpoint:
+            type: object
+
+            properties:
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        required:
+          - reg
+          - endpoint
+
+        additionalProperties: false
+
+    patternProperties:
+      "port@1":
+        type: object
+        description: The Output/source port node properties.
+        properties:
+          reg:
+            description: Output/source port number.
+
+          endpoint:
+            type: object
+
+            properties:
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        required:
+          - reg
+          - endpoint
+
+        additionalProperties: false
+
+    required:
+      - "#address-cells"
+      - "#size-cells"
+      - port@0
+      - port@1
+
+    additionalProperties: false
+
+required:
+  - compatible
+  - reg
+  - ports
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/media/microchip-common.h>
+    image-enhancement@50020000 {
+        compatible = "microchip,image-enhancement-rtl-v1";
+        reg = <0x50020000 0x10000>;
+
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+
+            port@0 {
+                /* Sink port */
+                reg = <0>;
+                image_enhancement_0_in: endpoint {
+                    remote-endpoint = <&monotorgb_0_out>;
+                };
+            };
+            port@1 {
+                /* Source port */
+                reg = <1>;
+                image_enhancement_0_out: endpoint {
+                    remote-endpoint = <&rgb_scaler_0_in>;
+                };
+            };
+        };
+    };
+...
--- /dev/null
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/media/microchip,mipi-csi2rx.yaml	2024-12-04 16:41:10.251278000 +0900
@@ -0,0 +1,147 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/microchip,mipi-csi2rx.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Microchip MIPI CSI-2 Receiver Subsystem
+
+maintainers:
+  - Shravan Chiappa  <shravan.chippa@microchip.com>
+
+description:
+  The Microchip MIPI CSI-2 Receiver Subsystem is used to capture MIPI CSI-2
+  traffic from compliant camera sensors and send the output as AXI4 Stream
+  video data for image processing.
+  The subsystem consists of a MIPI D-PHY in slave mode which captures the
+  data packets. This is passed along the MIPI CSI-2 Rx IP which extracts the
+  packet data.
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - microchip,mipi-csi2-rx-rtl-v0
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    items:
+      - description: AXI Lite clock
+      - description: Video frame clock
+
+  clock-names:
+    items:
+      - const: axi
+      - const: video
+
+  microchip,csi-pxl-format:
+    description: |
+      This denotes the CSI Data type selected in hw design.
+      Possible values are as below -
+      0x24 - RGB888
+      0x2a - RAW8
+      0x2b - RAW10
+      0x2c - RAW12
+      0x2d - RAW14
+      0x2e - RAW16
+    $ref: /schemas/types.yaml#/definitions/uint32
+    enum: [0x24, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e]
+    default: 0x2a
+
+  microchip,csi-fixed-out-raw8:
+    type: boolean
+    description: Present when Video Format output is raw8 fixed
+
+  ports:
+    $ref: /schemas/graph.yaml#/properties/ports
+
+    properties:
+      port@0:
+        $ref: /schemas/graph.yaml#/$defs/port-base
+        description: |
+          Input / sink port node, single endpoint describing the
+          CSI-2 transmitter.
+
+        properties:
+          endpoint:
+            $ref: /schemas/media/video-interfaces.yaml#
+            unevaluatedProperties: false
+
+            properties:
+              data-lanes:
+                description: |
+                  This is required only in the sink port 0 endpoint which
+                  connects to MIPI CSI-2 source like sensor.
+                  The possible values are -
+                  1       - For 1 lane enabled in IP.
+                  1 2     - For 2 lanes enabled in IP.
+                  1 2 3   - For 3 lanes enabled in IP.
+                  1 2 3 4 - For 4 lanes enabled in IP.
+                items:
+                  - const: 1
+                  - const: 2
+                  - const: 3
+                  - const: 4
+
+            required:
+              - data-lanes
+
+        unevaluatedProperties: false
+
+      port@1:
+        $ref: /schemas/graph.yaml#/properties/port
+        description: |
+          Output / source port node, endpoint describing modules
+          connected the CSI-2 receiver.
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - clocks
+  - clock-names
+  - microchip,csi-pxl-format
+  - ports
+
+additionalProperties: false
+
+examples:
+  - |
+    mcsi2rx_0: csi2rx@50020000 {
+        compatible = "microchip,mipi-csi2-rx";
+        reg = <0x50020000 0x10000>;
+        interrupt-parent = <&plic>;
+        interrupts = <120>;
+        microchip,csi-pxl-format = <0x2a>;
+        clock-names = "axi", "video";
+        clocks = <&axi_clk_0>, <&video_clk_0>;
+        status = "okay";
+
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+
+            port@0 {
+                /* Sink port */
+                reg = <0>;
+                csi_0_in: endpoint {
+                    data-lanes = <1 2 3 4>;
+                    /* MIPI CSI-2 Camera handle */
+                    remote-endpoint = <&camera_out>;
+                };
+            };
+            port@1 {
+                /* Source port */
+                reg = <1>;
+                csi_0_out: endpoint {
+                    remote-endpoint = <&vproc_in>;
+                };
+            };
+        };
+    };
+...
--- /dev/null
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/media/microchip,osd.yaml	2024-12-04 16:41:10.252275300 +0900
@@ -0,0 +1,127 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/microchip,osd.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Microchip Video On Screen Display (OSD)
+
+maintainers:
+  - Shravan Chippa <shravan.chippa@microchip.com>
+
+description: |
+  The Microchip video on screen display is a user-defined FPGA
+  logic to display text on the video frames and stream the video
+  data through the native interface for image processing.
+
+properties:
+  compatible:
+    enum:
+      - microchip,osd-rtl-v1
+
+  reg:
+    maxItems: 1
+
+  ports:
+    $ref: /schemas/graph.yaml#/properties/ports
+
+    properties:
+      "#address-cells":
+        const: 1
+
+      "#size-cells":
+        const: 0
+
+      port@0:
+        type: object
+        description: The Input/sink port node properties.
+        properties:
+          reg:
+            description: Input/sink port number.
+            const: 0
+
+          endpoint:
+            type: object
+
+            properties:
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        required:
+          - reg
+          - endpoint
+
+        additionalProperties: false
+
+    patternProperties:
+      "port@1":
+        type: object
+        description: The Output/source port node properties.
+        properties:
+          reg:
+            description: Output/source port number.
+
+          endpoint:
+            type: object
+
+            properties:
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        required:
+          - reg
+          - endpoint
+
+        additionalProperties: false
+
+    required:
+      - "#address-cells"
+      - "#size-cells"
+      - port@0
+      - port@1
+
+    additionalProperties: false
+
+required:
+  - compatible
+  - reg
+  - ports
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/media/microchip-common.h>
+    osd-0@50020000 {
+        compatible = "microchip,osd-rtl-v1";
+        reg = <0x50020000 0x10000>;
+
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+
+            port@0 {
+                /* Sink port */
+                reg = <0>;
+                osd_0_in: endpoint {
+                    remote-endpoint = <&monotorgb_0_out>;
+                };
+            };
+            port@1 {
+                /* Source port */
+                reg = <1>;
+                osd_0_out: endpoint {
+                    remote-endpoint = <&rgb_scaler_0_in>;
+                };
+            };
+        };
+    };
+...
--- /dev/null
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/media/microchip,rgb-scaler.yaml	2024-12-04 16:41:10.252275300 +0900
@@ -0,0 +1,127 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/microchip,rgb-scaler.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Microchip rgb scaler
+
+maintainers:
+  - Shravan Chippa <shravan.chippa@microchip.com>
+
+description: |
+  The Microchip video rgb scaler IP is used to scale up/down the
+  video image and stream the video data through AXI streaming
+  interface or native interface for the image processing.
+
+properties:
+  compatible:
+    enum:
+      - microchip,rgb-scaler-rtl-v1
+
+  reg:
+    maxItems: 1
+
+  ports:
+    $ref: /schemas/graph.yaml#/properties/ports
+
+    properties:
+      "#address-cells":
+        const: 1
+
+      "#size-cells":
+        const: 0
+
+      port@0:
+        type: object
+        description: The Input/sink port node properties.
+        properties:
+          reg:
+            description: Input/sink port number.
+            const: 0
+
+          endpoint:
+            type: object
+
+            properties:
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        required:
+          - reg
+          - endpoint
+
+        additionalProperties: false
+
+    patternProperties:
+      "port@1":
+        type: object
+        description: The Output/source port node properties.
+        properties:
+          reg:
+            description: Output/source port number.
+
+          endpoint:
+            type: object
+
+            properties:
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        required:
+          - reg
+          - endpoint
+
+        additionalProperties: false
+
+    required:
+      - "#address-cells"
+      - "#size-cells"
+      - port@0
+      - port@1
+
+    additionalProperties: false
+
+required:
+  - compatible
+  - reg
+  - ports
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/media/microchip-common.h>
+    rgb-scaler-0@50020000 {
+        compatible = "microchip,rgb-scaler-rtl-v1";
+        reg = <0x50020000 0x10000>;
+
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+
+            port@0 {
+                /* Sink port */
+                reg = <0>;
+                gvpc_0_in: endpoint {
+                    remote-endpoint = <&image_enhancement_0_out>;
+                };
+            };
+            port@1 {
+                /* Source port */
+                reg = <1>;
+                gvpc_0_out: endpoint {
+                    remote-endpoint = <&osd_0_in>;
+                };
+            };
+        };
+    };
+...
--- /dev/null
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/media/microchip,video-capture.yaml	2024-12-04 16:41:10.253272500 +0900
@@ -0,0 +1,86 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/microchip,video-capture.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Microchip Video Capture
+
+maintainers:
+  - Shravan Chiappa  <shravan.chippa@microchip.com>
+
+description:
+  Microchip Video Capture IP processes the video streams through one or more
+  video IP cores. The DT node of the video capture represents as a top level
+  node of the pipeline.
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - microchip,video-dma-rtl-v0
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    items:
+      - description: AXI Lite clock
+      - description: Video frame clock
+
+  clock-names:
+    items:
+      - const: axi
+      - const: video
+
+  memory-region:
+    description: Reserved memory for v4l2 buffers (optional)
+    maxItems: 1
+
+  ports:
+    $ref: /schemas/graph.yaml#/properties/ports
+
+    properties:
+      port@0:
+        $ref: /schemas/graph.yaml#/$defs/port-base
+        description: |
+          Input / sink port node, endpoint describing modules connected video capture IP.
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - clocks
+  - clock-names
+  - ports
+
+additionalProperties: false
+
+examples:
+  - |
+    video-cap@50020000 {
+        compatible = "microchip,video-dma-rtl-v0";
+        reg = <0x50020000 0x10000>;
+        interrupt-parent = <&plic>;
+        interrupts = <121>;
+        clock-names = "axi", "video";
+        clocks = <&axi_clk_0>, <&video_clk_0>;
+        status = "okay";
+
+        ports {
+          #address-cells = <1>;
+          #size-cells = <0>;
+            port@1 {
+                /* Sink port */
+                reg = <0>;
+                video_cap_in0: endpoint {
+                    remote-endpoint = <&any_in>;
+                };
+            };
+        };
+    };
+
+...
+
--- /dev/null
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/media/microchip,yuv2h264.yaml	2024-12-04 16:41:10.254269900 +0900
@@ -0,0 +1,129 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/microchip,yuv2h264.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Microchip H.264 Encoder IP
+
+maintainers:
+  - Shravan Chippa <shravan.chippa@microchip.com>
+
+description: |
+  The Microchip H.264 encoder IP used for encode H.264 frame from
+  yuv422 frames and stream the video data through AXI streaming
+  or native interface to video DMA node.
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - microchip,yuv2h264-rtl-v1
+
+  reg:
+    maxItems: 1
+
+  ports:
+    $ref: /schemas/graph.yaml#/properties/ports
+
+    properties:
+      "#address-cells":
+        const: 1
+
+      "#size-cells":
+        const: 0
+
+      port@0:
+        type: object
+        description: The Input/sink port node properties.
+        properties:
+          reg:
+            description: Input/sink port number.
+            const: 0
+
+          endpoint:
+            type: object
+
+            properties:
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        required:
+          - reg
+          - endpoint
+
+        additionalProperties: false
+
+    patternProperties:
+      "port@1":
+        type: object
+        description: The Output/source port node properties.
+        properties:
+          reg:
+            description: Output/source port number.
+
+          endpoint:
+            type: object
+
+            properties:
+              remote-endpoint: true
+
+            required:
+              - remote-endpoint
+
+            additionalProperties: false
+
+        required:
+          - reg
+          - endpoint
+
+        additionalProperties: false
+
+    required:
+      - "#address-cells"
+      - "#size-cells"
+      - port@0
+      - port@1
+
+    additionalProperties: false
+
+required:
+  - compatible
+  - reg
+  - ports
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/media/microchip-common.h>
+
+    yuv2h264_0: h264-video-0@50020000 {
+        compatible = "microchip,yuv2h264-rtl-v1";
+        reg = <0x50020000 0x10000>;
+
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+
+            port@0 {
+                /* Sink port */
+                reg = <0>;
+                h264_0_in: endpoint {
+                    remote-endpoint = <&yuv420_0_out>;
+                };
+            };
+            port@1 {
+                /* Source port */
+                reg = <1>;
+                h264_0_out: endpoint {
+                    remote-endpoint = <&video_dma_in>;
+                };
+            };
+        };
+    };
+...
--- /dev/null
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/media/snps,dw-csi.yaml	2024-12-04 16:41:10.275213800 +0900
@@ -0,0 +1,149 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/snps,dw-csi.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Synopsys DesignWare CSI-2 Host controller (csi2host)
+
+maintainers:
+  - Eugen Hristev <eugen.hristev@microchip.com>
+
+description:
+  CSI2HOST is used to receive image coming from an MIPI CSI-2 compatible
+  camera. It will convert the incoming CSI-2 stream into a dedicated
+  interface called the Synopsys IDI (Image Data Interface).
+  This interface is a 32-bit SoC internal only, and can be assimilated
+  with a CSI-2 interface.
+
+properties:
+  compatible:
+    const: snps,dw-csi
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    maxItems: 2
+
+  clock-names:
+    description:
+      CSI2HOST can have two clocks connected. One clock is the
+      peripheral clock for the inside functionality of the hardware block.
+      This is named 'perclk'. The second clock can be the phy clock,
+      which is used to clock the phy via an internal link.
+      This clock is named 'phyclk', phy clock.
+    items:
+      - const: perclk
+      - const: phyclk
+
+  phys:
+    maxItems: 1
+    description: MIPI D-PHY
+
+  phy-names:
+    items:
+      - const: dphy
+
+  resets:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  ports:
+    $ref: /schemas/graph.yaml#/properties/ports
+
+    properties:
+      port@0:
+        $ref: /schemas/graph.yaml#/$defs/port-base
+        unevaluatedProperties: false
+        description:
+          Input port node, single endpoint describing the input port.
+
+        properties:
+          endpoint:
+            $ref: video-interfaces.yaml#
+            unevaluatedProperties: false
+            description: Endpoint connected to input device
+
+            properties:
+              bus-type:
+                const: 4
+
+              data-lanes:
+                minItems: 1
+                maxItems: 4
+                items:
+                  maximum: 4
+
+              clock-lanes:
+                maxItems: 1
+
+              remote-endpoint: true
+
+      port@1:
+        $ref: /schemas/graph.yaml#/$defs/port-base
+        unevaluatedProperties: false
+        description:
+          Output port node, single endpoint describing the output port.
+
+        properties:
+          endpoint:
+            unevaluatedProperties: false
+            $ref: video-interfaces.yaml#
+            description: Endpoint connected to output device
+
+            properties:
+              bus-type:
+                const: 4
+
+              remote-endpoint: true
+
+    required:
+      - port@0
+      - port@1
+
+additionalProperties: false
+
+required:
+  - compatible
+  - ports
+
+examples:
+  - |
+    csi2: csi2@3000 {
+        compatible = "snps,dw-csi";
+        reg = <0x03000 0x7FF>;
+        phys = <&mipi_dphy_rx>;
+        phy-names = "dphy";
+        resets = <&dw_rst 1>;
+        interrupts = <2>;
+
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+
+            port@0 {
+                reg = <0>;
+
+                csi_ep1: endpoint {
+                    bus-type = <4>; /* MIPI CSI2 D-PHY */
+                    remote-endpoint = <&camera_1>;
+                    data-lanes = <1 2>;
+                    clock-lanes = <0>;
+                };
+            };
+
+            port@1 {
+                reg = <1>;
+
+                csi_ep2: endpoint {
+                    remote-endpoint = <&idi_receiver>;
+                    bus-type = <4>;
+                };
+            };
+        };
+    };
+
+...
--- linux-6.6.51/drivers/media/platform/Kconfig	2024-12-05 13:07:47.824811500 +0900
+++ linux4microchip-fpga-2024.09/drivers/media/platform/Kconfig	2024-12-04 16:41:27.979110800 +0900
@@ -69,6 +69,7 @@
 source "drivers/media/platform/atmel/Kconfig"
 source "drivers/media/platform/cadence/Kconfig"
 source "drivers/media/platform/chips-media/Kconfig"
+source "drivers/media/platform/dwc/Kconfig"
 source "drivers/media/platform/intel/Kconfig"
 source "drivers/media/platform/marvell/Kconfig"
 source "drivers/media/platform/mediatek/Kconfig"
--- linux-6.6.51/drivers/media/platform/Makefile	2024-12-05 13:07:47.824811500 +0900
+++ linux4microchip-fpga-2024.09/drivers/media/platform/Makefile	2024-12-04 16:41:27.980108100 +0900
@@ -12,6 +12,7 @@
 obj-y += atmel/
 obj-y += cadence/
 obj-y += chips-media/
+obj-y += dwc/
 obj-y += intel/
 obj-y += marvell/
 obj-y += mediatek/
@@ -34,3 +35,4 @@
 # (e. g. LC_ALL=C sort Makefile)
 obj-$(CONFIG_VIDEO_MEM2MEM_DEINTERLACE)	+= m2m-deinterlace.o
 obj-$(CONFIG_VIDEO_MUX)			+= video-mux.o
+
diff -urN '--label=/dev/null' /dev/null linux4microchip-fpga-2024.09/drivers/media/platform/dwc/Kconfig
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/dwc/Kconfig	2024-12-04 16:41:28.011025600 +0900
@@ -0,0 +1,41 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+#  Synopsys DWC Platform drivers
+#	Drivers here are currently for MIPI CSI-2 and MIPI DPHY support
+
+config DWC_MIPI_CSI2_HOST
+	tristate "Synopsys DesignWare CSI-2 Host Controller support"
+	select VIDEO_DEV
+	select VIDEO_V4L2
+	select VIDEO_V4L2_SUBDEV_API
+	select V4L2_FWNODE
+	help
+	  This selects the DesignWare MIPI CSI-2 host controller support. This
+	  controller gives access to control a CSI-2 receiver acting as a V4L2
+	  subdevice.
+
+	  If you have a controller with this interface, say Y.
+
+	   If unsure, say N.
+
+config DWC_MIPI_DPHY_GEN3
+	tristate "DesignWare platform support using a Gen3 D-PHY"
+	select GENERIC_PHY
+	help
+	 Synopsys MIPI D-PHY Generation 3 reference driver. This driver supports
+	 all Generation 3 D-PHYs. Choose Y or M if you have a platform with this
+	 block.
+
+	  If unsure, say N.
+
+if DWC_MIPI_DPHY_GEN3
+
+config DWC_MIPI_TC_DPHY_GEN3
+	bool "Platform support using a Synopsys Test Chip"
+	help
+	 Synopsys Test Chip is for prototyping purposes. This enables extra
+	 features that exist only in prototyping and/or for debug purposes.
+
+	  If unsure, say N.
+
+endif # DWC_MIPI_DPHY_GEN3
diff -urN '--label=/dev/null' /dev/null linux4microchip-fpga-2024.09/drivers/media/platform/dwc/Makefile
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/dwc/Makefile	2024-12-04 16:41:28.011025600 +0900
@@ -0,0 +1,15 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for Synopsys DWC Platform drivers
+#
+dw-csi-objs := dw-csi-plat.o dw-mipi-csi.o
+ifeq ($(CONFIG_DWC_MIPI_TC_DPHY_GEN3),y)
+	dw-csi-objs += dw-csi-sysfs.o
+endif
+obj-$(CONFIG_DWC_MIPI_CSI2_HOST) += dw-csi.o
+
+dw-dphy-objs := dw-dphy-plat.o dw-dphy-rx.o
+ifeq ($(CONFIG_DWC_MIPI_TC_DPHY_GEN3),y)
+	dw-dphy-objs += dw-dphy-sysfs.o
+endif
+obj-$(CONFIG_DWC_MIPI_DPHY_GEN3) += dw-dphy.o
diff -urN '--label=/dev/null' /dev/null linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-csi-plat.c
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-csi-plat.c	2024-12-04 16:41:28.012022800 +0900
@@ -0,0 +1,667 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018-2019 Synopsys, Inc. and/or its affiliates.
+ *
+ * Synopsys DesignWare MIPI CSI-2 Host controller driver.
+ * Platform driver
+ *
+ * Author: Luis Oliveira <luis.oliveira@synopsys.com>
+ */
+
+#include <media/dwc/dw-csi-data.h>
+#include <media/dwc/dw-dphy-data.h>
+
+#include "dw-csi-plat.h"
+#include <linux/clk.h>
+
+const struct mipi_dt csi_dt[] = {
+	{
+		.hex = CSI_2_YUV420_8,
+		.name = "YUV420_8bits",
+	}, {
+		.hex = CSI_2_YUV420_10,
+		.name = "YUV420_10bits",
+	}, {
+		.hex = CSI_2_YUV420_8_LEG,
+		.name = "YUV420_8bits_LEGACY",
+	}, {
+		.hex = CSI_2_YUV420_8_SHIFT,
+		.name = "YUV420_8bits_SHIFT",
+	}, {
+		.hex = CSI_2_YUV420_10_SHIFT,
+		.name = "YUV420_10bits_SHIFT",
+	}, {
+		.hex = CSI_2_YUV422_8,
+		.name = "YUV442_8bits",
+	}, {
+		.hex = CSI_2_YUV422_10,
+		.name = "YUV442_10bits",
+	}, {
+		.hex = CSI_2_RGB444,
+		.name = "RGB444",
+	}, {
+		.hex = CSI_2_RGB555,
+		.name = "RGB555",
+	}, {
+		.hex = CSI_2_RGB565,
+		.name = "RGB565",
+	}, {
+		.hex = CSI_2_RGB666,
+		.name = "RGB666",
+	}, {
+		.hex = CSI_2_RGB888,
+		.name = "RGB888",
+	}, {
+		.hex = CSI_2_RAW6,
+		.name = "RAW6",
+	}, {
+		.hex = CSI_2_RAW7,
+		.name = "RAW7",
+	}, {
+		.hex = CSI_2_RAW8,
+		.name = "RAW8",
+	}, {
+		.hex = CSI_2_RAW10,
+		.name = "RAW10",
+	}, {
+		.hex = CSI_2_RAW12,
+		.name = "RAW12",
+	}, {
+		.hex = CSI_2_RAW14,
+		.name = "RAW14",
+	}, {
+		.hex = CSI_2_RAW16,
+		.name = "RAW16",
+	},
+};
+
+static struct mipi_fmt *
+find_dw_mipi_csi_format(struct v4l2_mbus_framefmt *mf)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(dw_mipi_csi_formats); i++)
+		if (mf->code == dw_mipi_csi_formats[i].mbus_code)
+			return &dw_mipi_csi_formats[i];
+
+	return NULL;
+}
+
+static int dw_mipi_csi_enum_mbus_code(struct v4l2_subdev *sd,
+				      struct v4l2_subdev_state *sd_state,
+				      struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index >= ARRAY_SIZE(dw_mipi_csi_formats))
+		return -EINVAL;
+
+	code->code = dw_mipi_csi_formats[code->index].mbus_code;
+	return 0;
+}
+
+static struct mipi_fmt *
+dw_mipi_csi_try_format(struct v4l2_mbus_framefmt *mf)
+{
+	struct mipi_fmt *fmt;
+
+	fmt = find_dw_mipi_csi_format(mf);
+	if (!fmt)
+		fmt = &dw_mipi_csi_formats[0];
+
+	mf->code = fmt->mbus_code;
+
+	return fmt;
+}
+
+static struct v4l2_mbus_framefmt *
+dw_mipi_csi_get_format(struct dw_csi *dev, struct v4l2_subdev_state *sd_state,
+		       enum v4l2_subdev_format_whence which)
+{
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return sd_state->pads ? v4l2_subdev_get_try_format(&dev->sd,
+							sd_state,
+							0) : NULL;
+	dev_dbg(dev->dev,
+		"%s got v4l2_mbus_pixelcode. 0x%x\n", __func__,
+		dev->format.code);
+	dev_dbg(dev->dev,
+		"%s got width. 0x%x\n", __func__,
+		dev->format.width);
+	dev_dbg(dev->dev,
+		"%s got height. 0x%x\n", __func__,
+		dev->format.height);
+	return &dev->format;
+}
+
+static int
+dw_mipi_csi_set_fmt(struct v4l2_subdev *sd,
+		    struct v4l2_subdev_state *sd_state,
+		    struct v4l2_subdev_format *fmt)
+{
+	struct dw_csi *dev = sd_to_mipi_csi_dev(sd);
+	struct mipi_fmt *dev_fmt;
+	struct v4l2_mbus_framefmt *mf = dw_mipi_csi_get_format(dev, sd_state,
+							       fmt->which);
+	int i;
+
+	dev_fmt = dw_mipi_csi_try_format(&fmt->format);
+
+	if (dev_fmt) {
+		*mf = fmt->format;
+		if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+			dev->fmt = dev_fmt;
+		dw_mipi_csi_set_ipi_fmt(dev);
+	}
+
+	if (fmt->format.width > 0 && fmt->format.height > 0) {
+		dw_mipi_csi_fill_timings(dev, fmt);
+	} else {
+		dev_vdbg(dev->dev, "%s unacceptable values 0x%x.\n",
+			 __func__, fmt->format.width);
+		dev_vdbg(dev->dev, "%s unacceptable values 0x%x.\n",
+			 __func__, fmt->format.height);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(csi_dt); i++)
+		if (csi_dt[i].hex == dev->ipi_dt) {
+			dev_vdbg(dev->dev, "Using data type %s\n",
+				 csi_dt[i].name);
+		}
+	return 0;
+}
+
+static int
+dw_mipi_csi_get_fmt(struct v4l2_subdev *sd,
+		    struct v4l2_subdev_state *sd_state,
+		    struct v4l2_subdev_format *fmt)
+{
+	struct dw_csi *dev = sd_to_mipi_csi_dev(sd);
+	struct v4l2_mbus_framefmt *mf;
+
+	mf = dw_mipi_csi_get_format(dev, sd_state, fmt->which);
+	if (!mf)
+		return -EINVAL;
+
+	mutex_lock(&dev->lock);
+	fmt->format = *mf;
+	mutex_unlock(&dev->lock);
+
+	return 0;
+}
+
+static int
+dw_mipi_csi_log_status(struct v4l2_subdev *sd)
+{
+	struct dw_csi *dev = sd_to_mipi_csi_dev(sd);
+
+	dw_mipi_csi_dump(dev);
+
+	return 0;
+}
+
+#if IS_ENABLED(CONFIG_VIDEO_ADV_DEBUG)
+static int
+dw_mipi_csi_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)
+{
+	struct dw_csi *dev = sd_to_mipi_csi_dev(sd);
+
+	dev_vdbg(dev->dev, "%s: reg=%llu\n", __func__, reg->reg);
+	reg->val = dw_mipi_csi_read(dev, reg->reg);
+
+	return 0;
+}
+#endif
+
+static int dw_mipi_csi_init_cfg(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state)
+{
+	struct v4l2_mbus_framefmt *format =
+	    v4l2_subdev_get_try_format(sd, sd_state, 0);
+
+	format->colorspace = V4L2_COLORSPACE_SRGB;
+	format->code = MEDIA_BUS_FMT_RGB888_1X24;
+	format->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int dw_mipi_csi_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct dw_csi *dev = sd_to_mipi_csi_dev(sd);
+	int ret = v4l2_subdev_call(dev->input_sd, video, s_stream, enable);
+
+	if (enable) {
+		dw_mipi_csi_hw_stdby(dev);
+		dw_mipi_csi_start(dev);
+	}  else {
+		phy_power_off(dev->phy);
+		dw_mipi_csi_mask_irq_power_off(dev);
+		/* reset data type */
+		dev->ipi_dt = 0x0;
+	}
+	return ret;
+}
+
+static const struct v4l2_subdev_core_ops dw_mipi_csi_core_ops = {
+	.log_status = dw_mipi_csi_log_status,
+#if IS_ENABLED(CONFIG_VIDEO_ADV_DEBUG)
+	.g_register = dw_mipi_csi_g_register,
+#endif
+};
+
+static int dw_get_mbus_config(struct v4l2_subdev *sd, unsigned int pad,
+			      struct v4l2_mbus_config *cfg)
+{
+	cfg->bus.mipi_csi2.num_data_lanes = 2;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+static int dw_enum_frame_size(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index)
+		return -EINVAL;
+
+	fse->min_width = 16;
+	fse->max_width = 4000;
+	fse->min_height = 16;
+	fse->max_height = 3000;
+
+	return 0;
+}
+
+static struct v4l2_subdev_pad_ops dw_mipi_csi_pad_ops = {
+	.init_cfg = dw_mipi_csi_init_cfg,
+	.enum_mbus_code = dw_mipi_csi_enum_mbus_code,
+	.enum_frame_size = dw_enum_frame_size,
+	.get_fmt = dw_mipi_csi_get_fmt,
+	.set_fmt = dw_mipi_csi_set_fmt,
+	.get_mbus_config = dw_get_mbus_config,
+};
+
+static const struct v4l2_subdev_video_ops dw_mipi_csi_video_ops = {
+	.s_stream = dw_mipi_csi_s_stream,
+};
+
+static const struct v4l2_subdev_ops dw_mipi_csi_subdev_ops = {
+	.core = &dw_mipi_csi_core_ops,
+	.pad = &dw_mipi_csi_pad_ops,
+	.video = &dw_mipi_csi_video_ops,
+};
+
+static irqreturn_t dw_mipi_csi_irq1(int irq, void *dev_id)
+{
+	struct dw_csi *csi_dev = dev_id;
+
+	dw_mipi_csi_irq_handler(csi_dev);
+
+	return IRQ_HANDLED;
+}
+
+static int dw_async_bound(struct v4l2_async_notifier *notifier,
+			  struct v4l2_subdev *subdev,
+			  struct v4l2_async_connection *asc)
+{
+	struct dw_csi *dw = container_of(notifier,
+					struct dw_csi, notifier);
+	int ret;
+	int pad;
+
+	dev_dbg(dw->dev, "async bound\n");
+	dw->input_sd = subdev;
+
+	pad = media_entity_get_fwnode_pad(&subdev->entity,
+					  asc->match.fwnode,
+					  MEDIA_PAD_FL_SOURCE);
+	if (pad < 0) {
+		dev_err(dw->dev, "Failed to find pad for %s\n",
+			dw->sd.name);
+		return pad;
+	}
+
+	dw->remote_pad = pad;
+
+	ret = media_create_pad_link(&dw->input_sd->entity, dw->remote_pad,
+				    &dw->sd.entity, 0, MEDIA_LNK_FL_ENABLED);
+
+	if (ret < 0) {
+		dev_err(dw->dev,
+			"Failed to create pad link: %s to %s\n",
+			dw->input_sd->entity.name, dw->sd.entity.name);
+		return ret;
+	}
+
+	dev_dbg(dw->dev, "link with %s pad: %d\n",
+		dw->input_sd->name, dw->remote_pad);
+
+	return ret;
+}
+
+static const struct v4l2_async_notifier_operations csi2host_async_ops = {
+	.bound = dw_async_bound,
+};
+
+static int
+dw_mipi_csi_parse_dt(struct platform_device *pdev, struct dw_csi *dev)
+{
+	struct device_node *of_node = pdev->dev.of_node;
+	struct fwnode_handle *input_fwnode, *output_fwnode;
+	struct v4l2_fwnode_endpoint ep = { .bus_type = V4L2_MBUS_CSI2_DPHY };
+	struct v4l2_fwnode_endpoint ep2 = { };
+	struct v4l2_async_connection *asc;
+	int ret = 0;
+
+	if (of_property_read_u32(of_node, "snps,output-type",
+				 &dev->hw.output))
+		dev->hw.output = 2;
+
+	input_fwnode = fwnode_graph_get_next_endpoint(of_fwnode_handle(of_node),
+						      NULL);
+	if (!input_fwnode) {
+		dev_err(&pdev->dev,
+			"missing port node at %pOF, input node is mandatory.\n",
+			of_node);
+		return -EINVAL;
+	}
+
+	/* Get port node and validate MIPI-CSI channel id. */
+	ret = v4l2_fwnode_endpoint_parse(input_fwnode, &ep);
+	if (ret)
+		goto err;
+
+	dev->index = ep.base.port - 1;
+	if (dev->index >= CSI_MAX_ENTITIES) {
+		ret = -ENXIO;
+		goto err;
+	}
+	dev->hw.num_lanes = ep.bus.mipi_csi2.num_data_lanes;
+
+	output_fwnode = fwnode_graph_get_next_endpoint
+				(of_fwnode_handle(of_node), input_fwnode);
+
+	if (output_fwnode) {
+		ret = v4l2_fwnode_endpoint_parse(output_fwnode,
+						 &ep2);
+
+		fwnode_handle_put(output_fwnode);
+	}
+
+	if (!output_fwnode || ret) {
+		dev_info(&pdev->dev,
+			 "missing output node at %pOF\n", of_node);
+	}
+
+	v4l2_async_subdev_nf_init(&dev->notifier, &dev->sd);
+	asc = v4l2_async_nf_add_fwnode_remote(&dev->notifier, input_fwnode,
+					      struct v4l2_async_connection);
+
+	if (IS_ERR(asc)) {
+		ret = PTR_ERR(asc);
+		goto err;
+	}
+
+	if (ret) {
+		dev_err(&pdev->dev, "failed to add async notifier.\n");
+		goto err;
+	}
+
+	dev->notifier.ops = &csi2host_async_ops;
+
+	ret = v4l2_async_nf_register(&dev->notifier);
+
+	if (ret) {
+		dev_err(&pdev->dev, "fail to register async notifier.\n");
+		goto err;
+	}
+
+err:
+	of_node_put(of_node);
+	return ret;
+}
+
+static const struct of_device_id dw_mipi_csi_of_match[];
+
+static int dw_csi_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *of_id = NULL;
+	struct dw_csih_pdata *pdata = NULL;
+	struct device *dev = &pdev->dev;
+	struct resource *res = NULL;
+	struct dw_csi *csi;
+	struct v4l2_subdev *sd;
+	int ret;
+
+	if (!IS_ENABLED(CONFIG_OF))
+		pdata = pdev->dev.platform_data;
+
+	dev_dbg(dev, "Probing started\n");
+
+	/* Resource allocation */
+	csi = devm_kzalloc(dev, sizeof(*csi), GFP_KERNEL);
+	if (!csi)
+		return -ENOMEM;
+
+	mutex_init(&csi->lock);
+	spin_lock_init(&csi->slock);
+	csi->dev = dev;
+
+	csi->perclk = devm_clk_get(dev, "perclk");
+	if (IS_ERR(csi->perclk)) {
+		ret = PTR_ERR(csi->perclk);
+		dev_err(dev, "failed to get perclk: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(csi->perclk);
+	if (ret) {
+		dev_err(dev, "failed to enable perclk: %d\n", ret);
+		return ret;
+	}
+
+	csi->phyclk = devm_clk_get(dev, "phyclk");
+	if (IS_ERR(csi->perclk)) {
+		ret = PTR_ERR(csi->phyclk);
+		dev_err(dev, "failed to get phyclk: %d\n", ret);
+		goto csi2host_phyclk_err;
+	}
+
+	ret = clk_prepare_enable(csi->phyclk);
+	if (ret) {
+		dev_err(dev, "failed to enable phyclk: %d\n", ret);
+		goto csi2host_phyclk_err;
+	}
+
+	if (dev->of_node) {
+		of_id = of_match_node(dw_mipi_csi_of_match, dev->of_node);
+		if (!of_id) {
+			ret = -EINVAL;
+			goto csi2host_reg_err;
+		}
+
+		ret = dw_mipi_csi_parse_dt(pdev, csi);
+		if (ret < 0)
+			goto csi2host_reg_err;
+
+		csi->phy = devm_of_phy_get(dev, dev->of_node, NULL);
+		if (IS_ERR(csi->phy)) {
+			dev_dbg(dev, "No DPHY available\n");
+			ret = -EPROBE_DEFER; /* attempt to defer */
+			goto csi2host_defer_err;
+		}
+	} else {
+		if (!pdata)
+			goto csi2host_reg_err;
+
+		csi->phy = devm_phy_get(dev, phys[pdata->id].name);
+		if (IS_ERR(csi->phy)) {
+			dev_err(dev, "No '%s' DPHY available\n",
+				phys[pdata->id].name);
+			return PTR_ERR(csi->phy);
+		}
+		dev_vdbg(dev, "got D-PHY %s with id %d\n", phys[pdata->id].name,
+			 csi->phy->id);
+	}
+	/* Registers mapping */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENXIO;
+		goto csi2host_defer_err;
+	}
+
+	csi->base_address = devm_ioremap_resource(dev, res);
+	if (IS_ERR(csi->base_address)) {
+		dev_err(dev, "Base address not set.\n");
+		ret = PTR_ERR(csi->base_address);
+		goto csi2host_defer_err;
+	}
+
+	csi->ctrl_irq_number = platform_get_irq(pdev, 0);
+	if (csi->ctrl_irq_number < 0) {
+		dev_err(dev, "irq number %d not set.\n", csi->ctrl_irq_number);
+		ret = csi->ctrl_irq_number;
+		goto end;
+	}
+
+	csi->rst = devm_reset_control_get_optional_shared(dev, NULL);
+	if (IS_ERR(csi->rst)) {
+		dev_err(dev, "error getting reset control %d\n", ret);
+		ret =  PTR_ERR(csi->rst);
+		goto end;
+	}
+
+	ret = devm_request_irq(dev, csi->ctrl_irq_number,
+			       dw_mipi_csi_irq1, IRQF_SHARED,
+			       dev_name(dev), csi);
+	if (ret) {
+		if (dev->of_node)
+			dev_err(dev, "irq csi %s failed\n", of_id->name);
+		else
+			dev_err(dev, "irq csi %d failed\n", pdata->id);
+
+		goto end;
+	}
+
+	sd = &csi->sd;
+	v4l2_subdev_init(sd, &dw_mipi_csi_subdev_ops);
+	csi->sd.owner = THIS_MODULE;
+	csi->sd.fwnode = of_fwnode_handle(dev->of_node);
+
+	if (dev->of_node) {
+		snprintf(sd->name, sizeof(sd->name), "%s.%d",
+			 "dw-csi", csi->index);
+
+		csi->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	} else {
+		strlcpy(sd->name, dev_name(dev), sizeof(sd->name));
+	}
+	csi->fmt = &dw_mipi_csi_formats[0];
+	csi->format.code = dw_mipi_csi_formats[0].mbus_code;
+
+	sd->entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
+
+	if (dev->of_node) {
+		csi->pads[CSI_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+		csi->pads[CSI_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+		ret = media_entity_pads_init(&csi->sd.entity,
+					     CSI_PADS_NUM, csi->pads);
+		if (ret < 0) {
+			dev_err(dev, "media entity init failed\n");
+			goto end;
+		}
+	} else {
+		csi->hw.num_lanes = pdata->lanes;
+		csi->hw.pclk = pdata->pclk;
+		csi->hw.fps = pdata->fps;
+		csi->hw.dphy_freq = pdata->hs_freq;
+	}
+	v4l2_set_subdevdata(&csi->sd, pdev);
+	platform_set_drvdata(pdev, &csi->sd);
+	dev_set_drvdata(dev, sd);
+
+	if (csi->rst)
+		reset_control_deassert(csi->rst);
+
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+	dw_csi_create_capabilities_sysfs(pdev);
+#endif
+	dw_mipi_csi_get_version(csi);
+	dw_mipi_csi_specific_mappings(csi);
+	dw_mipi_csi_mask_irq_power_off(csi);
+
+	dev_info(dev, "DW MIPI CSI-2 Host registered successfully HW v%u.%u\n",
+		 csi->hw_version_major, csi->hw_version_minor);
+
+	phy_init(csi->phy);
+
+	ret = v4l2_async_register_subdev(&csi->sd);
+
+	if (ret)
+		dev_dbg(csi->dev, "failed to register the subdevice\n");
+
+	return ret;
+end:
+#if IS_ENABLED(CONFIG_OF)
+	media_entity_cleanup(&csi->sd.entity);
+#endif
+csi2host_defer_err:
+	v4l2_async_nf_unregister(&csi->notifier);
+	v4l2_async_nf_cleanup(&csi->notifier);
+
+csi2host_reg_err:
+	clk_disable_unprepare(csi->phyclk);
+csi2host_phyclk_err:
+	clk_disable_unprepare(csi->perclk);
+	return ret;
+}
+
+/**
+ * @short Exit routine - Exit point of the driver
+ * @param[in] pdev pointer to the platform device structure
+ * @return 0 on success
+ */
+static int dw_csi_remove(struct platform_device *pdev)
+{
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *mipi_csi = sd_to_mipi_csi_dev(sd);
+
+	dev_dbg(&pdev->dev, "Removing DW MIPI CSI-2 Host module\n");
+
+	if (mipi_csi->rst)
+		reset_control_assert(mipi_csi->rst);
+#if IS_ENABLED(CONFIG_OF)
+	media_entity_cleanup(&mipi_csi->sd.entity);
+#endif
+
+	return 0;
+}
+
+#if IS_ENABLED(CONFIG_OF)
+static const struct of_device_id dw_mipi_csi_of_match[] = {
+	{ .compatible = "snps,dw-csi" },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, dw_mipi_csi_of_match);
+#endif
+
+static struct platform_driver dw_mipi_csi_driver = {
+	.remove = dw_csi_remove,
+	.probe = dw_csi_probe,
+	.driver = {
+		.name = "dw-csi",
+		.owner = THIS_MODULE,
+#if IS_ENABLED(CONFIG_OF)
+		.of_match_table = of_match_ptr(dw_mipi_csi_of_match),
+#endif
+	},
+};
+
+module_platform_driver(dw_mipi_csi_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Luis Oliveira <luis.oliveira@synopsys.com>");
+MODULE_DESCRIPTION("Synopsys DesignWare MIPI CSI-2 Host Platform driver");
diff -urN '--label=/dev/null' /dev/null linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-csi-plat.h
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-csi-plat.h	2024-12-04 16:41:28.012022800 +0900
@@ -0,0 +1,102 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018 Synopsys, Inc.
+ *
+ * Synopsys DesignWare MIPI CSI-2 Host controller driver.
+ * Supported bus formats
+ *
+ * Author: Luis Oliveira <Luis.Oliveira@synopsys.com>
+ */
+
+#ifndef _DW_CSI_PLAT_H__
+#define _DW_CSI_PLAT_H__
+
+#include "dw-mipi-csi.h"
+
+/* Video formats supported by the MIPI CSI-2 */
+struct mipi_fmt dw_mipi_csi_formats[] = {
+	{
+		/* RAW 8 */
+		.mbus_code = MEDIA_BUS_FMT_SBGGR8_1X8,
+		.depth = 8,
+	}, {
+		/* RAW 10 */
+		.mbus_code = MEDIA_BUS_FMT_SBGGR10_1X10,
+		.depth = 10,
+	}, {
+		/* RAW 10 */
+		.mbus_code = MEDIA_BUS_FMT_SRGGB10_1X10,
+		.depth = 10,
+
+	}, {
+		/* RAW 12 */
+		.mbus_code = MEDIA_BUS_FMT_SBGGR12_1X12,
+		.depth = 12,
+	}, {
+		/* RAW 14 */
+		.mbus_code = MEDIA_BUS_FMT_SBGGR14_1X14,
+		.depth = 14,
+	}, {
+		/* RAW 16 */
+		.mbus_code = MEDIA_BUS_FMT_SBGGR16_1X16,
+		.depth = 16,
+	}, {
+		/* RGB 666 */
+		.mbus_code = MEDIA_BUS_FMT_RGB666_1X18,
+		.depth = 18,
+	}, {
+		/* RGB 565 */
+		.mbus_code = MEDIA_BUS_FMT_RGB565_2X8_BE,
+		.depth = 16,
+	}, {
+		/* BGR 565 */
+		.mbus_code = MEDIA_BUS_FMT_RGB565_2X8_LE,
+		.depth = 16,
+	}, {
+		/* RGB 555 */
+		.mbus_code = MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE,
+		.depth = 16,
+	}, {
+		/* BGR 555 */
+		.mbus_code = MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE,
+		.depth = 16,
+	}, {
+		/* RGB 444 */
+		.mbus_code = MEDIA_BUS_FMT_RGB444_2X8_PADHI_BE,
+		.depth = 16,
+	}, {
+		/* RGB 444 */
+		.mbus_code = MEDIA_BUS_FMT_RGB444_2X8_PADHI_LE,
+		.depth = 16,
+	}, {
+		/* RGB 888 */
+		.mbus_code = MEDIA_BUS_FMT_RGB888_2X12_LE,
+		.depth = 24,
+	}, {
+		/* BGR 888 */
+		.mbus_code = MEDIA_BUS_FMT_RGB888_2X12_BE,
+		.depth = 24,
+	}, {
+		/* BGR 888 */
+		.mbus_code = MEDIA_BUS_FMT_RGB888_1X24,
+		.depth = 24,
+	}, {
+		/* YUV 422 8-bit */
+		.mbus_code = MEDIA_BUS_FMT_VYUY8_1X16,
+		.depth = 16,
+	}, {
+		/* YUV 422 10-bit */
+		.mbus_code = MEDIA_BUS_FMT_VYUY10_2X10,
+		.depth = 20,
+	}, {
+		/* YUV 420 8-bit LEGACY */
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.depth = 8,
+	}, {
+		/* YUV 420 10-bit */
+		.mbus_code = MEDIA_BUS_FMT_Y10_1X10,
+		.depth = 10,
+	},
+};
+
+#endif	/* _DW_CSI_PLAT_H__ */
diff -urN '--label=/dev/null' /dev/null linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-csi-sysfs.c
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-csi-sysfs.c	2024-12-04 16:41:28.012022800 +0900
@@ -0,0 +1,623 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018-2019 Synopsys, Inc. and/or its affiliates.
+ *
+ * Synopsys DesignWare MIPI CSI-2 Host controller driver.
+ * SysFS components for the platform driver
+ *
+ * Author: Luis Oliveira <Luis.Oliveira@synopsys.com>
+ */
+
+#include "dw-mipi-csi.h"
+
+static ssize_t core_version_show(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	char buffer[10];
+
+	snprintf(buffer, 10, "v.%d.%d*\n", csi_dev->hw_version_major,
+		 csi_dev->hw_version_minor);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t n_lanes_store(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	int ret;
+	unsigned long lanes;
+
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	ret = kstrtoul(buf, 10, &lanes);
+	if (ret < 0)
+		return ret;
+
+	if (lanes > 8) {
+		dev_err(dev, "Invalid number of lanes %lu\n", lanes);
+		return count;
+	}
+
+	dev_info(dev, "Lanes %lu\n", lanes);
+	csi_dev->hw.num_lanes = lanes;
+
+	return count;
+}
+
+static ssize_t n_lanes_show(struct device *dev,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	char buffer[10];
+
+	snprintf(buffer, 10, "%d\n", csi_dev->hw.num_lanes);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t core_reset_show(struct device *dev,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	char buffer[10];
+
+	/* Reset Controller and DPHY */
+	phy_reset(csi_dev->phy);
+	dw_mipi_csi_reset(csi_dev);
+
+	snprintf(buffer, 10, "Reset\n");
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t data_type_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	int ret;
+	unsigned long dt;
+
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	ret = kstrtoul(buf, 16, &dt);
+	if (ret < 0)
+		return ret;
+
+	if (dt < 0x18 || dt > 0x2F) {
+		dev_err(dev, "Invalid data type %lx\n", dt);
+		return count;
+	}
+
+	dev_info(dev, "Data type 0x%lx\n", dt);
+	csi_dev->ipi_dt = dt;
+
+	return count;
+}
+
+static ssize_t data_type_show(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	char buffer[10];
+
+	snprintf(buffer, 10, "%x\n", csi_dev->ipi_dt);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t hsa_store(struct device *dev,
+			 struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	int ret;
+	unsigned long hsa;
+
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	ret = kstrtoul(buf, 16, &hsa);
+	if (ret < 0)
+		return ret;
+
+	if (hsa > 0xFFF) {
+		dev_err(dev, "Invalid HSA time %lx\n", hsa);
+		return count;
+	}
+
+	dev_info(dev, "HSA time 0x%lx\n", hsa);
+	csi_dev->hw.hsa = hsa;
+
+	return count;
+}
+
+static ssize_t hsa_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	char buffer[10];
+
+	snprintf(buffer, 10, "%x\n", csi_dev->hw.hsa);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t hbp_store(struct device *dev,
+			 struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	int ret;
+	unsigned long hbp;
+
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	ret = kstrtoul(buf, 16, &hbp);
+	if (ret < 0)
+		return ret;
+
+	if (hbp > 0xFFF) {
+		dev_err(dev, "Invalid HBP time %lx\n", hbp);
+		return count;
+	}
+
+	dev_info(dev, "HBP time 0x%lx\n", hbp);
+	csi_dev->hw.hbp = hbp;
+
+	return count;
+}
+
+static ssize_t hbp_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	char buffer[10];
+
+	snprintf(buffer, 10, "%x\n", csi_dev->hw.hbp);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t hsd_store(struct device *dev,
+			 struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	int ret;
+	unsigned long hsd;
+
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	ret = kstrtoul(buf, 16, &hsd);
+	if (ret < 0)
+		return ret;
+
+	if (hsd > 0xFF) {
+		dev_err(dev, "Invalid HSD time %lx\n", hsd);
+		return count;
+	}
+
+	dev_info(dev, "HSD time 0x%lx\n", hsd);
+	csi_dev->hw.hsd = hsd;
+
+	return count;
+}
+
+static ssize_t hsd_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	char buffer[10];
+
+	snprintf(buffer, 10, "%x\n", csi_dev->hw.hsd);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t vsa_store(struct device *dev,
+			 struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	int ret;
+	unsigned long vsa;
+
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	ret = kstrtoul(buf, 16, &vsa);
+	if (ret < 0)
+		return ret;
+
+	if (vsa > 0x3FF) {
+		dev_err(dev, "Invalid VSA period %lx\n", vsa);
+		return count;
+	}
+
+	dev_info(dev, "VSA period 0x%lx\n", vsa);
+	csi_dev->hw.vsa = vsa;
+
+	return count;
+}
+
+static ssize_t vsa_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	char buffer[10];
+
+	snprintf(buffer, 10, "%x\n", csi_dev->hw.vsa);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t vbp_store(struct device *dev,
+			 struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	int ret;
+	unsigned long vbp;
+
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	ret = kstrtoul(buf, 16, &vbp);
+	if (ret < 0)
+		return ret;
+
+	if (vbp > 0x2FF) {
+		dev_err(dev, "Invalid VBP period %lx\n", vbp);
+		return count;
+	}
+
+	dev_info(dev, "VBP period 0x%lx\n", vbp);
+	csi_dev->hw.vbp = vbp;
+
+	return count;
+}
+
+static ssize_t vbp_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	char buffer[10];
+
+	snprintf(buffer, 10, "%x\n", csi_dev->hw.vbp);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t vfp_store(struct device *dev,
+			 struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	int ret;
+	unsigned long vfp;
+
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	ret = kstrtoul(buf, 16, &vfp);
+	if (ret < 0)
+		return ret;
+
+	if (vfp > 0x3ff) {
+		dev_err(dev, "Invalid VFP period %lx\n", vfp);
+		return count;
+	}
+
+	dev_info(dev, "VFP period 0x%lx\n", vfp);
+	csi_dev->hw.vfp = vfp;
+
+	return count;
+}
+
+static ssize_t vfp_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	char buffer[10];
+
+	snprintf(buffer, 10, "%x\n", csi_dev->hw.vfp);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t virtual_channel_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	int ret;
+	unsigned long virtual_ch;
+
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	ret = kstrtoul(buf, 10, &virtual_ch);
+	if (ret < 0)
+		return ret;
+
+	if ((signed int)virtual_ch < 0 || (signed int)virtual_ch > 8) {
+		dev_err(dev, "Invalid Virtual Channel %lu\n", virtual_ch);
+		return count;
+	}
+
+	dev_info(dev, "Virtual Channel %lu\n", virtual_ch);
+	csi_dev->hw.virtual_ch = virtual_ch;
+
+	return count;
+}
+
+static ssize_t virtual_channel_show(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	char buffer[10];
+
+	snprintf(buffer, 10, "%d\n", csi_dev->hw.virtual_ch);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t ipi_color_mode_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	int ret;
+	unsigned long ipi_color_mode;
+
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	ret = kstrtoul(buf, 10, &ipi_color_mode);
+	if (ret < 0)
+		return ret;
+
+	if ((signed int)ipi_color_mode < 0 || (signed int)ipi_color_mode > 1) {
+		dev_err(dev,
+			"Wrong Color Mode %lu, (48 bits -> 0 or 16 bits -> 1\n",
+			ipi_color_mode);
+		return count;
+	}
+
+	dev_info(dev, "IPI Color mode %lu\n", ipi_color_mode);
+	csi_dev->hw.ipi_color_mode = ipi_color_mode;
+
+	return count;
+}
+
+static ssize_t ipi_color_mode_show(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	char buffer[10];
+
+	snprintf(buffer, 10, "%d\n", csi_dev->hw.ipi_color_mode);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t ipi_auto_flush_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	int ret;
+	unsigned long ipi_auto_flush;
+
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	ret = kstrtoul(buf, 10, &ipi_auto_flush);
+	if (ret < 0)
+		return ret;
+
+	if ((signed int)ipi_auto_flush < 0 || (signed int)ipi_auto_flush > 1) {
+		dev_err(dev,
+			"Invalid Auto Flush Mode %lu, (No -> 0 or Yes -> 1\n",
+			ipi_auto_flush);
+		return count;
+	}
+
+	dev_info(dev, "IPI Auto Flush %lu\n", ipi_auto_flush);
+	csi_dev->hw.ipi_auto_flush = ipi_auto_flush;
+
+	return count;
+}
+
+static ssize_t ipi_auto_flush_show(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	char buffer[10];
+
+	snprintf(buffer, 10, "%d\n", csi_dev->hw.ipi_auto_flush);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t ipi_timings_mode_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	int ret;
+	unsigned long ipi_mode;
+
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	ret = kstrtoul(buf, 10, &ipi_mode);
+	if (ret < 0)
+		return ret;
+
+	if ((signed int)ipi_mode < 0 || (signed int)ipi_mode > 1) {
+		dev_err(dev,
+			"Invalid Timing Source %lu (Camera:0|Controller:1)\n",
+			ipi_mode);
+		return count;
+	}
+
+	dev_info(dev, "IPI Color mode %lu\n", ipi_mode);
+	csi_dev->hw.ipi_mode = ipi_mode;
+
+	return count;
+}
+
+static ssize_t ipi_timings_mode_show(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	char buffer[10];
+
+	snprintf(buffer, 10, "%d\n", csi_dev->hw.ipi_mode);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t output_type_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	int ret;
+	unsigned long output;
+
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	ret = kstrtoul(buf, 10, &output);
+	if (ret < 0)
+		return ret;
+
+	if ((signed int)output < 0 || (signed int)output > 1) {
+		dev_err(dev,
+			"Invalid Core output %lu to be used (IPI-> 0 or IDI->1 or BOTH- 2\n",
+			output);
+		return count;
+	}
+
+	dev_info(dev, "IPI Color mode %lu\n", output);
+	csi_dev->hw.output = output;
+
+	return count;
+}
+
+static ssize_t output_type_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct v4l2_subdev *sd = platform_get_drvdata(pdev);
+	struct dw_csi *csi_dev = sd_to_mipi_csi_dev(sd);
+
+	char buffer[10];
+
+	snprintf(buffer, 10, "%d\n", csi_dev->hw.output);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static DEVICE_ATTR_RO(core_version);
+static DEVICE_ATTR_RO(core_reset);
+static DEVICE_ATTR_RW(n_lanes);
+static DEVICE_ATTR_RW(data_type);
+static DEVICE_ATTR_RW(hsa);
+static DEVICE_ATTR_RW(hbp);
+static DEVICE_ATTR_RW(hsd);
+static DEVICE_ATTR_RW(vsa);
+static DEVICE_ATTR_RW(vbp);
+static DEVICE_ATTR_RW(vfp);
+static DEVICE_ATTR_RW(virtual_channel);
+static DEVICE_ATTR_RW(ipi_color_mode);
+static DEVICE_ATTR_RW(ipi_auto_flush);
+static DEVICE_ATTR_RW(ipi_timings_mode);
+static DEVICE_ATTR_RW(output_type);
+
+int dw_csi_create_capabilities_sysfs(struct platform_device *pdev)
+{
+	device_create_file(&pdev->dev, &dev_attr_core_version);
+	device_create_file(&pdev->dev, &dev_attr_core_reset);
+	device_create_file(&pdev->dev, &dev_attr_n_lanes);
+	device_create_file(&pdev->dev, &dev_attr_data_type);
+	device_create_file(&pdev->dev, &dev_attr_hsa);
+	device_create_file(&pdev->dev, &dev_attr_hbp);
+	device_create_file(&pdev->dev, &dev_attr_hsd);
+	device_create_file(&pdev->dev, &dev_attr_vsa);
+	device_create_file(&pdev->dev, &dev_attr_vbp);
+	device_create_file(&pdev->dev, &dev_attr_vfp);
+	device_create_file(&pdev->dev, &dev_attr_virtual_channel);
+	device_create_file(&pdev->dev, &dev_attr_ipi_color_mode);
+	device_create_file(&pdev->dev, &dev_attr_ipi_auto_flush);
+	device_create_file(&pdev->dev, &dev_attr_ipi_timings_mode);
+	device_create_file(&pdev->dev, &dev_attr_output_type);
+
+	return 0;
+}
diff -urN '--label=/dev/null' /dev/null linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-dphy-plat.c
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-dphy-plat.c	2024-12-04 16:41:28.013020100 +0900
@@ -0,0 +1,227 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018-2019 Synopsys, Inc. and/or its affiliates.
+ *
+ * Synopsys DesignWare MIPI D-PHY controller driver.
+ * Platform driver
+ *
+ * Author: Luis Oliveira <luis.oliveira@synopsys.com>
+ */
+
+#include <media/dwc/dw-dphy-data.h>
+#include <media/dwc/dw-csi-data.h>
+
+#include "dw-dphy-rx.h"
+
+static struct phy_ops dw_dphy_ops = {
+	.init = dw_dphy_init,
+	.reset = dw_dphy_reset,
+	.power_on = dw_dphy_power_on,
+	.power_off = dw_dphy_power_off,
+	.owner = THIS_MODULE,
+};
+
+static struct phy_provider *phy_provider;
+
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+static u8 get_config_8l(struct device *dev, struct dw_dphy_rx *dphy)
+{
+	if (IS_ENABLED(CONFIG_OF) && dev->of_node) {
+		struct gpio_desc *conf;
+
+		conf = devm_fwnode_gpiod_get_index(dev, dev->fwnode, "config",
+						   0, GPIOD_IN,
+						   fwnode_get_name(dev->fwnode));
+		if (IS_ERR(conf)) {
+			dev_warn(dev, "8L config parse err, default is 4L\n");
+			dphy->config_8l = CTRL_4_LANES;
+		}
+	} else {
+		struct dw_phy_pdata *pdata = dev->platform_data;
+
+		dphy->config_8l = pdata->config_8l;
+	}
+	return dphy->config_8l;
+}
+#endif
+static int get_resources(struct device *dev, struct dw_dphy_rx *dphy)
+{
+	int ret = 0;
+
+	if (IS_ENABLED(CONFIG_OF) && dev->of_node) {
+		if (of_property_read_u32(dev->of_node, "snps,dphy-frequency",
+					 &dphy->dphy_freq)) {
+			dev_err(dev, "failed to find dphy frequency\n");
+			ret = -EINVAL;
+		}
+		if (of_property_read_u32(dev->of_node, "bus-width",
+					 &dphy->dphy_te_len)) {
+			dev_err(dev, "failed to find dphy te length\n");
+			ret = -EINVAL;
+		}
+		if (of_property_read_u32(dev->of_node, "snps,phy_type",
+					 &dphy->phy_type)) {
+			dev_err(dev, "failed to find dphy type\n");
+			ret = -EINVAL;
+		}
+	} else {
+		struct dw_phy_pdata *pdata = dev->platform_data;
+
+		dphy->dphy_freq = pdata->dphy_frequency;
+		dphy->dphy_te_len = pdata->dphy_te_len;
+		dphy->dphy_gen = pdata->dphy_gen;
+	}
+	dev_set_drvdata(dev, dphy);
+
+	return ret;
+}
+
+static int phy_register(struct device *dev)
+{
+	int ret = 0;
+
+	if (IS_ENABLED(CONFIG_OF) && dev->of_node) {
+		phy_provider = devm_of_phy_provider_register(dev,
+							     dw_dphy_xlate);
+		if (IS_ERR(phy_provider)) {
+			dev_err(dev, "error getting phy provider\n");
+			ret = PTR_ERR(phy_provider);
+		}
+	} else {
+		struct dw_phy_pdata *pdata = dev->platform_data;
+		struct dw_dphy_rx *dphy = dev_get_drvdata(dev);
+
+		ret = phy_create_lookup(dphy->phy,
+					phys[pdata->id].name,
+					csis[pdata->id].name);
+		if (ret)
+			dev_err(dev, "Failed to create dphy lookup\n");
+		else
+			dev_warn(dev,
+				 "Created dphy lookup [%s] --> [%s]\n",
+				 phys[pdata->id].name, csis[pdata->id].name);
+	}
+	return ret;
+}
+
+static void phy_unregister(struct device *dev)
+{
+	if (!dev->of_node) {
+		struct dw_dphy_rx *dphy = dev_get_drvdata(dev);
+
+		phy_remove_lookup(dphy->phy, "dw-dphy", "dw-csi");
+	}
+}
+
+static int dw_dphy_rx_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct dw_dphy_rx *dphy;
+	struct resource *res;
+
+	dphy = devm_kzalloc(&pdev->dev, sizeof(*dphy), GFP_KERNEL);
+	if (!dphy)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dphy->base_address = devm_ioremap(&pdev->dev,
+					  res->start, resource_size(res));
+	if (IS_ERR(dphy->base_address)) {
+		dev_err(&pdev->dev, "error requesting base address\n");
+		return PTR_ERR(dphy->base_address);
+	}
+
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+
+	dphy->dphy1_if_addr = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(dphy->dphy1_if_addr)) {
+		dev_err(&pdev->dev, "error requesting dphy 1 if regbank\n");
+		return PTR_ERR(dphy->dphy1_if_addr);
+	}
+
+	dphy->max_lanes =
+		dw_dphy_if_read_msk(dphy, DPHYID, DPHY_ID_LANE_SUPPORT, 4);
+
+	dphy->dphy_gen = dw_dphy_if_read_msk(dphy, DPHYID, DPHY_ID_GEN, 4);
+
+	dev_info(&pdev->dev, "DPHY GEN %s with maximum %s lanes\n",
+		 dphy->dphy_gen == GEN3 ? "3" : "2",
+		 dphy->max_lanes == CTRL_8_LANES ? "8" : "4");
+
+	if (dphy->max_lanes == CTRL_8_LANES) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+		dphy->dphy2_if_addr =
+			devm_ioremap(&pdev->dev,
+				     res->start, resource_size(res));
+
+		if (IS_ERR(dphy->dphy2_if_addr)) {
+			dev_err(&pdev->dev,
+				"error requesting dphy 2 if regbank\n");
+			return PTR_ERR(dphy->dphy2_if_addr);
+		}
+		dphy->config_8l = get_config_8l(&pdev->dev, dphy);
+	}
+#endif
+	if (get_resources(dev, dphy)) {
+		dev_err(dev, "failed to parse PHY resources\n");
+		return -EINVAL;
+	}
+
+	dphy->phy = devm_phy_create(dev, NULL, &dw_dphy_ops);
+	if (IS_ERR(dphy->phy)) {
+		dev_err(dev, "failed to create PHY\n");
+		return PTR_ERR(dphy->phy);
+	}
+
+	platform_set_drvdata(pdev, dphy);
+	phy_set_drvdata(dphy->phy, dphy);
+
+	if (phy_register(dev)) {
+		dev_err(dev, "failed to register PHY\n");
+		return -EINVAL;
+	}
+
+	dphy->lp_time = 1000; /* 1000 ns */
+	dphy->lanes_config = dw_dphy_setup_config(dphy);
+
+	dev_info(dev, "Probing dphy finished\n");
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+	dw_dphy_create_capabilities_sysfs(pdev);
+#endif
+
+	return 0;
+}
+
+static int dw_dphy_rx_remove(struct platform_device *pdev)
+{
+	phy_unregister(&pdev->dev);
+
+	return 0;
+}
+
+#if IS_ENABLED(CONFIG_OF)
+static const struct of_device_id dw_dphy_rx_of_match[] = {
+	{ .compatible = "snps,dw-dphy-rx" },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, dw_dphy_rx_of_match);
+#endif
+
+static struct platform_driver dw_dphy_rx_driver = {
+	.probe = dw_dphy_rx_probe,
+	.remove = dw_dphy_rx_remove,
+	.driver = {
+#if IS_ENABLED(CONFIG_OF)
+		.of_match_table = of_match_ptr(dw_dphy_rx_of_match),
+#endif
+		.name = "dw-dphy",
+		.owner = THIS_MODULE,
+	}
+};
+module_platform_driver(dw_dphy_rx_driver);
+
+MODULE_DESCRIPTION("Synopsys DesignWare MIPI DPHY Rx driver");
+MODULE_AUTHOR("Luis Oliveira <lolivei@synopsys.com>");
+MODULE_LICENSE("GPL v2");
diff -urN '--label=/dev/null' /dev/null linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-dphy-rx.c
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-dphy-rx.c	2024-12-04 16:41:28.013020100 +0900
@@ -0,0 +1,626 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018-2019 Synopsys, Inc. and/or its affiliates.
+ *
+ * Synopsys DesignWare MIPI D-PHY controller driver
+ * Core functions
+ *
+ * Author: Luis Oliveira <luis.oliveira@synopsys.com>
+ */
+
+#include "dw-dphy-rx.h"
+
+struct range_dphy_gen2 {
+	u32 freq;
+	u8 hsfregrange;
+};
+
+struct range_dphy_gen2 range_gen2[] = {
+	{ 80, 0x00 }, { 90, 0x10 }, { 100, 0x20 }, { 110, 0x30 },
+	{ 120, 0x01 }, { 130, 0x11 }, { 140, 0x21 }, { 150, 0x31 },
+	{ 160, 0x02 }, { 170, 0x12 }, { 180, 0x22 }, { 190, 0x32 },
+	{ 205, 0x03 }, { 220, 0x13 }, { 235, 0x23 }, { 250, 0x33 },
+	{ 275, 0x04 }, { 300, 0x14 }, { 325, 0x05 }, { 350, 0x15 },
+	{ 400, 0x25 }, { 450, 0x06 }, { 500, 0x16 }, { 550, 0x07 },
+	{ 600, 0x17 }, { 650, 0x08 }, { 700, 0x18 }, { 750, 0x09 },
+	{ 800, 0x19 }, { 850, 0x29 }, { 900, 0x39 }, { 950, 0x0A },
+	{ 1000, 0x1A }, { 1050, 0x2A }, { 1100, 0x3A }, { 1150, 0x0B },
+	{ 1200, 0x1B }, { 1250, 0x2B }, { 1300, 0x3B }, { 1350, 0x0C },
+	{ 1400, 0x1C }, { 1450, 0x2C }, { 1500, 0x3C }, { 1550, 0x0D },
+	{ 1600, 0x1D }, { 1650, 0x2D }, { 1700, 0x0E }, { 1750, 0x1E },
+	{ 1800, 0x2E }, { 1850, 0x3E }, { 1900, 0x0F }, { 1950, 0x1F },
+	{ 2000, 0x2F },
+};
+
+struct range_dphy_gen3 {
+	u32 freq;
+	u8 hsfregrange;
+	u32 osc_freq_target;
+};
+
+struct range_dphy_gen3 range_gen3[] = {
+	{ 80, 0x00, 0x1B6 }, { 90, 0x10, 0x1B6 }, { 100, 0x20, 0x1B6 },
+	{ 110, 0x30, 0x1B6 }, { 120, 0x01, 0x1B6 }, { 130, 0x11, 0x1B6 },
+	{ 140, 0x21, 0x1B6 }, { 150, 0x31, 0x1B6 }, { 160, 0x02, 0x1B6 },
+	{ 170, 0x12, 0x1B6 }, { 180, 0x22, 0x1B6 }, { 190, 0x32, 0x1B6 },
+	{ 205, 0x03, 0x1B6 }, { 220, 0x13, 0x1B6 }, { 235, 0x23, 0x1B6 },
+	{ 250, 0x33, 0x1B6 }, { 275, 0x04, 0x1B6 }, { 300, 0x14, 0x1B6 },
+	{ 325, 0x25, 0x1B6 }, { 350, 0x35, 0x1B6 }, { 400, 0x05, 0x1B6 },
+	{ 450, 0x16, 0x1B6 }, { 500, 0x26, 0x1B6 }, { 550, 0x37, 0x1B6 },
+	{ 600, 0x07, 0x1B6 }, { 650, 0x18, 0x1B6 }, { 700, 0x28, 0x1B6 },
+	{ 750, 0x39, 0x1B6 }, { 800, 0x09, 0x1B6 }, { 850, 0x19, 0x1B6 },
+	{ 900, 0x29, 0x1B6 }, { 950, 0x3A, 0x1B6 }, { 1000, 0x0A, 0x1B6 },
+	{ 1050, 0x1A, 0x1B6 }, { 1100, 0x2A, 0x1B6 }, { 1150, 0x3B, 0x1B6 },
+	{ 1200, 0x0B, 0x1B6 }, { 1250, 0x1B, 0x1B6 }, { 1300, 0x2B, 0x1B6 },
+	{ 1350, 0x3C, 0x1B6 }, { 1400, 0x0C, 0x1B6 }, { 1450, 0x1C, 0x1B6 },
+	{ 1500, 0x2C, 0x1B6 }, { 1550, 0x3D, 0x10F }, { 1600, 0x0D, 0x118 },
+	{ 1650, 0x1D, 0x121 }, { 1700, 0x2E, 0x12A }, { 1750, 0x3E, 0x132 },
+	{ 1800, 0x0E, 0x13B }, { 1850, 0x1E, 0x144 }, { 1900, 0x2F, 0x14D },
+	{ 1950, 0x3F, 0x155 }, { 2000, 0x0F, 0x15E }, { 2050, 0x40, 0x167 },
+	{ 2100, 0x41, 0x170 }, { 2150, 0x42, 0x178 }, { 2200, 0x43, 0x181 },
+	{ 2250, 0x44, 0x18A }, { 2300, 0x45, 0x193 }, { 2350, 0x46, 0x19B },
+	{ 2400, 0x47, 0x1A4 }, { 2450, 0x48, 0x1AD }, { 2500, 0x49, 0x1B6 }
+};
+
+u8 dw_dphy_setup_config(struct dw_dphy_rx *dphy)
+{
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+	int ret;
+	struct gpio_desc *config_gpio;
+
+	if (dphy->max_lanes == CTRL_4_LANES) {
+		dev_vdbg(&dphy->phy->dev, "CONFIG 4L\n");
+		return CTRL_4_LANES;
+	}
+	if (IS_ENABLED(CONFIG_OF)) {
+		config_gpio = devm_gpiod_get(&dphy->phy->dev, "config",
+					     GPIOD_IN);
+		if (IS_ERR(config_gpio)) {
+			dev_vdbg(&dphy->phy->dev,
+				 "8L config parse err, default 4L");
+			return CTRL_4_LANES;
+		}
+		ret = gpiod_get_value(config_gpio);
+	} else {
+		ret = dphy->config_8l;
+	}
+
+	dev_vdbg(&dphy->phy->dev,
+		 "Booting in [%s] mode\n",
+		 ret == CTRL_8_LANES ? "8L" : "4+4L");
+	return ret;
+
+#endif /* CONFIG_DWC_MIPI_TC_DPHY_GEN3 */
+	return CTRL_4_LANES;
+}
+
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+void dw_dphy_if_write(struct dw_dphy_rx *dphy, u32 address, u32 data)
+{
+	writel(data, dphy->dphy1_if_addr + address);
+
+	if (dphy->lanes_config == CTRL_4_LANES)
+		return;
+
+	iowrite32(data, dphy->dphy2_if_addr + address);
+}
+
+u32 dw_dphy_if_read(struct dw_dphy_rx *dphy, u32 address)
+{
+	u32 if1 = 0, if2 = 0;
+
+	if1 = readl(dphy->dphy1_if_addr + address);
+
+	if (dphy->lanes_config == CTRL_4_LANES)
+		goto end;
+
+	if (dphy->lanes_config == DPHYID)
+		goto end;
+
+	if2 = readl(dphy->dphy2_if_addr + address);
+
+	if (if1 != if2)
+		dev_vdbg(&dphy->phy->dev,
+			 "Values read different for each interface\n");
+end:
+	return if1;
+}
+#endif
+
+void dw_dphy_write(struct dw_dphy_rx *dphy, u32 address, u32 data)
+{
+	iowrite32(data, dphy->base_address + address);
+
+	if (dphy->lanes_config == CTRL_4_LANES)
+		return;
+
+	if (address == R_CSI2_DPHY_TST_CTRL0)
+		iowrite32(data, dphy->base_address + R_CSI2_DPHY2_TST_CTRL0);
+	else if (address == R_CSI2_DPHY_TST_CTRL1)
+		iowrite32(data, dphy->base_address + R_CSI2_DPHY2_TST_CTRL1);
+}
+
+u32 dw_dphy_read(struct dw_dphy_rx *dphy, u32 address)
+{
+	int dphy1 = 0, dphy2 = 0;
+
+	dphy1 = ioread32(dphy->base_address + address);
+
+	if (dphy->lanes_config == CTRL_4_LANES)
+		goto end;
+
+	if (address == R_CSI2_DPHY_TST_CTRL0)
+		dphy2 = ioread32(dphy->base_address + R_CSI2_DPHY2_TST_CTRL0);
+	else if (address == R_CSI2_DPHY_TST_CTRL1)
+		dphy2 = ioread32(dphy->base_address + R_CSI2_DPHY2_TST_CTRL1);
+	else
+		return -ENODEV;
+end:
+	return dphy1;
+}
+
+void dw_dphy_write_msk(struct dw_dphy_rx *dev, u32 address, u32 data, u8 shift,
+		       u8 width)
+{
+	u32 temp = dw_dphy_read(dev, address);
+	u32 mask = (1 << width) - 1;
+
+	temp &= ~(mask << shift);
+	temp |= (data & mask) << shift;
+	dw_dphy_write(dev, address, temp);
+}
+
+static void dw_dphy_te_12b_write(struct dw_dphy_rx *dphy, u16 addr, u8 data)
+{
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 0, PHY_TESTEN, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 0, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 1, PHY_TESTEN, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 1, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 0x00, PHY_TESTDIN, 8);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 0, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 0, PHY_TESTEN, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, (u8)(addr >> 8),
+			  PHY_TESTDIN, 8);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 1, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 0, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 1, PHY_TESTEN, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 1, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, (u8)addr, PHY_TESTDIN,
+			  8);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 0, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 0, PHY_TESTEN, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, (u8)data, PHY_TESTDIN,
+			  8);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 1, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 0, PHY_TESTCLK, 1);
+}
+
+static void dw_dphy_te_8b_write(struct dw_dphy_rx *dphy, u8 addr, u8 data)
+{
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 1, PHY_TESTCLK, 1);
+	dw_dphy_write(dphy, R_CSI2_DPHY_TST_CTRL1, addr);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 1, PHY_TESTEN, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 0, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 0, PHY_TESTEN, 1);
+	dw_dphy_write(dphy, R_CSI2_DPHY_TST_CTRL1, data);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 1, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 0, PHY_TESTCLK, 1);
+}
+
+static void dw_dphy_te_write(struct dw_dphy_rx *dphy, u16 addr, u8 data)
+{
+	if (dphy->dphy_te_len == BIT12)
+		dw_dphy_te_12b_write(dphy, addr, data);
+	else
+		dw_dphy_te_8b_write(dphy, addr, data);
+}
+
+static int dw_dphy_te_12b_read(struct dw_dphy_rx *dphy, u32 addr)
+{
+	u8 ret;
+
+	dw_dphy_write(dphy, R_CSI2_DPHY_SHUTDOWNZ, 0);
+	dw_dphy_write(dphy, R_CSI2_DPHY_RSTZ, 0);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 0, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 0, PHY_TESTEN, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 1, PHY_TESTEN, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 1, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 0x00, PHY_TESTDIN, 8);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 0, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 0, PHY_TESTEN, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, (u8)(addr >> 8),
+			  PHY_TESTDIN, 8);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 1, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 0, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 1, PHY_TESTEN, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 1, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, (u8)addr, PHY_TESTDIN,
+			  8);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 0, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 0x00, 0, PHY_TESTDIN);
+	ret = dw_dphy_read_msk(dphy, R_CSI2_DPHY_TST_CTRL1, PHY_TESTDOUT, 8);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 0, PHY_TESTEN, 1);
+	dw_dphy_write(dphy, R_CSI2_DPHY_RSTZ, 1);
+	dw_dphy_write(dphy, R_CSI2_DPHY_SHUTDOWNZ, 1);
+
+	return ret;
+}
+
+static int dw_dphy_te_8b_read(struct dw_dphy_rx *dphy, u32 addr)
+{
+	u8 ret;
+
+	dw_dphy_write(dphy, R_CSI2_DPHY_SHUTDOWNZ, 0);
+	dw_dphy_write(dphy, R_CSI2_DPHY_RSTZ, 0);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 1, PHY_TESTEN, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 1, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, addr, PHY_TESTDIN, 8);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 0, PHY_TESTCLK, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 0, PHY_TESTEN, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL1, 0, PHY_TESTDIN, 8);
+	ret = dw_dphy_read_msk(dphy, R_CSI2_DPHY_TST_CTRL1, PHY_TESTDOUT, 8);
+	dw_dphy_write(dphy, R_CSI2_DPHY_RSTZ, 1);
+	dw_dphy_write(dphy, R_CSI2_DPHY_SHUTDOWNZ, 1);
+
+	return ret;
+}
+
+int dw_dphy_te_read(struct dw_dphy_rx *dphy, u32 addr)
+{
+	int ret;
+
+	if (dphy->dphy_te_len == BIT12)
+		ret = dw_dphy_te_12b_read(dphy, addr);
+	else
+		ret = dw_dphy_te_8b_read(dphy, addr);
+
+	return ret;
+}
+
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+static void dw_dphy_if_init(struct dw_dphy_rx *dphy)
+{
+	dw_dphy_if_write(dphy, DPHYGLUEIFTESTER, RESET);
+	dw_dphy_if_write(dphy, DPHYGLUEIFTESTER, TX_PHY);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 1, PHY_TESTCLR, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 0, PHY_TESTCLR, 1);
+	dw_dphy_if_write(dphy, DPHYZCALCTRL, 0);
+	dw_dphy_if_write(dphy, DPHYZCALCTRL, 1);
+	dw_dphy_if_write(dphy, DPHYGLUEIFTESTER, RESET);
+	dw_dphy_if_write(dphy, DPHYGLUEIFTESTER, GLUELOGIC);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 1, PHY_TESTCLR, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 0, PHY_TESTCLR, 1);
+	dw_dphy_if_write(dphy, DPHYZCALCTRL, 0);
+	dw_dphy_if_write(dphy, DPHYZCALCTRL, 1);
+	dw_dphy_if_write(dphy, DPHYGLUEIFTESTER, RESET);
+	dw_dphy_if_write(dphy, DPHYGLUEIFTESTER, RX_PHY);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 1, PHY_TESTCLR, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 0, PHY_TESTCLR, 1);
+	dw_dphy_if_write(dphy, DPHYZCALCTRL, 0);
+	dw_dphy_if_write(dphy, DPHYZCALCTRL, 1);
+}
+#endif
+
+static void dw_dphy_gen3_12bit_tc_power_up(struct dw_dphy_rx *dphy)
+{
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+	dw_dphy_if_write(dphy, DPHYGLUEIFTESTER, RESET);
+	dw_dphy_if_write(dphy, DPHYGLUEIFTESTER, GLUELOGIC);
+#endif
+	dw_dphy_te_write(dphy, CFGCLKFREQRANGE_TX, 0x1C);
+
+	/* CLKSEL | UPDATEPLL | SHADOW_CLEAR | SHADOW_CTRL | FORCEPLL */
+	dw_dphy_te_write(dphy, BYPASS, 0x3F);
+
+	/* IO_DS3 | IO_DS2 | IO_DS1 | IO_DS0 */
+	if (dphy->dphy_freq > 1500)
+		dw_dphy_te_write(dphy, IO_DS, 0x0F);
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+	dw_dphy_if_write(dphy, DPHYGLUEIFTESTER, RESET);
+	dw_dphy_if_write(dphy, DPHYGLUEIFTESTER, RX_PHY);
+#endif
+}
+
+static void dw_dphy_gen3_8bit_tc_power_up(struct dw_dphy_rx *dphy)
+{
+	u32 input_freq = dphy->dphy_freq / 1000;
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+	dw_dphy_if_write(dphy, DPHYGLUEIFTESTER, RESET);
+	dw_dphy_if_write(dphy, DPHYGLUEIFTESTER, GLUELOGIC);
+	dw_dphy_te_write(dphy, CFGCLKFREQRANGE_RX, 0x1C);
+	dw_dphy_if_write(dphy, DPHYGLUEIFTESTER, RESET);
+	dw_dphy_if_write(dphy, DPHYGLUEIFTESTER, RX_PHY);
+#endif
+	dw_dphy_te_write(dphy, OSC_FREQ_TARGET_RX0_MSB, 0x03);
+	dw_dphy_te_write(dphy, OSC_FREQ_TARGET_RX0_LSB, 0x02);
+	dw_dphy_te_write(dphy, OSC_FREQ_TARGET_RX1_MSB, 0x03);
+	dw_dphy_te_write(dphy, OSC_FREQ_TARGET_RX1_LSB, 0x02);
+	dw_dphy_te_write(dphy, OSC_FREQ_TARGET_RX2_MSB, 0x03);
+	dw_dphy_te_write(dphy, OSC_FREQ_TARGET_RX2_LSB, 0x02);
+	dw_dphy_te_write(dphy, OSC_FREQ_TARGET_RX3_MSB, 0x03);
+	dw_dphy_te_write(dphy, OSC_FREQ_TARGET_RX3_LSB, 0x02);
+	dw_dphy_te_write(dphy, BANDGAP_CTRL, 0x80);
+
+	if (input_freq < 2000)
+		dw_dphy_te_write(dphy, HS_RX_CTRL_LANE0, 0xC0);
+
+	if (input_freq < 1000) {
+		dw_dphy_te_write(dphy, HS_RX_CTRL_LANE1, 0xC0);
+		dw_dphy_te_write(dphy, HS_RX_CTRL_LANE2, 0xC0);
+		dw_dphy_te_write(dphy, HS_RX_CTRL_LANE3, 0xC0);
+	}
+}
+
+int dw_dphy_g118_settle(struct dw_dphy_rx *dphy)
+{
+	u32 input_freq, total_settle, settle_time, byte_clk, lp_time;
+
+	lp_time = dphy->lp_time;
+	input_freq = dphy->dphy_freq / 1000;
+
+	settle_time = (8 * (1000000 / (input_freq))) + 115000;
+	byte_clk = (8000000 / (input_freq));
+	total_settle = (settle_time + lp_time * 1000) / byte_clk;
+
+	if (total_settle > 0xFF)
+		total_settle = 0xFF;
+
+	return total_settle;
+}
+
+static void dw_dphy_pwr_down(struct dw_dphy_rx *dphy)
+{
+	dw_dphy_write(dphy, R_CSI2_DPHY_RSTZ, 0);
+
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 0, PHY_TESTCLK, 1);
+	if (dphy->lanes_config == CTRL_8_LANES)
+		dw_dphy_write_msk(dphy, R_CSI2_DPHY2_TST_CTRL0, 0, PHY_TESTCLK,
+				  1);
+
+	dw_dphy_write(dphy, R_CSI2_DPHY_SHUTDOWNZ, 0);
+}
+
+static void dw_dphy_pwr_up(struct dw_dphy_rx *dphy)
+{
+	u32 state = 0, wait = 0;
+
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 1, PHY_TESTCLK, 1);
+	if (dphy->lanes_config == CTRL_8_LANES)
+		dw_dphy_write_msk(dphy, R_CSI2_DPHY2_TST_CTRL0, 1, PHY_TESTCLK,
+				  1);
+	dev_vdbg(&dphy->phy->dev, "DPHY power up.\n");
+	dw_dphy_write(dphy, R_CSI2_DPHY_SHUTDOWNZ, 1);
+	usleep_range(100, 500);
+	dw_dphy_write(dphy, R_CSI2_DPHY_RSTZ, 1);
+
+	while (state != 0x10003) {
+		state = dw_dphy_read(dphy, R_CSI2_DPHY_STOPSTATE);
+		usleep_range(100, 500);
+		wait++;
+		if (wait > 10)
+			break;
+	}
+	if (state != 0x10003)
+		dev_warn(&dphy->phy->dev, "PHY Stop state not reached %x\n",
+			 state);
+}
+
+static int dw_dphy_gen3_12bit_configure(struct dw_dphy_rx *dphy)
+{
+	u32 input_freq = dphy->dphy_freq;
+	u8 range = 0;
+
+	dev_vdbg(&dphy->phy->dev, "12bit: PHY GEN 3: Freq: %u\n", input_freq);
+	for (range = 0; (range < ARRAY_SIZE(range_gen3) - 1) &&
+	     ((input_freq / 1000) > range_gen3[range].freq);
+	     range++)
+		;
+
+	dw_dphy_gen3_12bit_tc_power_up(dphy);
+	dw_dphy_te_write(dphy, RX_SYS_1, range_gen3[range].hsfregrange);
+	dw_dphy_te_write(dphy, RX_SYS_0, 0x20);
+	dw_dphy_te_write(dphy, RX_RX_STARTUP_OVR_2,
+			 (u8)range_gen3[range].osc_freq_target);
+	dw_dphy_te_write(dphy, RX_RX_STARTUP_OVR_3,
+			 (u8)(range_gen3[range].osc_freq_target >> 8));
+	dw_dphy_te_write(dphy, RX_RX_STARTUP_OVR_4, 0x01);
+
+	if (dphy->phy_type) {
+		dw_dphy_te_write(dphy, RX_RX_STARTUP_OVR_1, 0x01);
+		dw_dphy_te_write(dphy, RX_RX_STARTUP_OVR_0, 0x80);
+	}
+
+	if (dphy->phy_type || input_freq <= 1500)
+		dw_dphy_te_write(dphy, RX_SYS_7, 0x38);
+
+	return 0;
+}
+
+static int dw_dphy_gen3_8bit_configure(struct dw_dphy_rx *dphy)
+{
+	u32 input_freq = dphy->dphy_freq;
+	u8 data;
+	u8 range = 0;
+
+	dev_vdbg(&dphy->phy->dev, "8bit: PHY GEN 3: Freq: %u\n", input_freq);
+	for (range = 0; (range < ARRAY_SIZE(range_gen3) - 1) &&
+	     ((input_freq / 1000) > range_gen3[range].freq);
+	     range++)
+		;
+
+	dw_dphy_te_write(dphy, RX_SKEW_CAL, dw_dphy_g118_settle(dphy));
+	data = 1 << 7 | range_gen3[range].hsfregrange;
+	dw_dphy_te_write(dphy, HSFREQRANGE_8BIT, data);
+	dw_dphy_gen3_8bit_tc_power_up(dphy);
+
+	return 0;
+}
+
+static int dw_dphy_gen2_configure(struct dw_dphy_rx *dphy)
+{
+	u32 input_freq = dphy->dphy_freq;
+	u8 data;
+	u8 range = 0;
+
+	/* provide an initial active-high test clear pulse in TESTCLR  */
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 1, PHY_TESTCLR, 1);
+	dw_dphy_write_msk(dphy, R_CSI2_DPHY_TST_CTRL0, 0, PHY_TESTCLR, 1);
+
+	dev_vdbg(&dphy->phy->dev, "PHY GEN 2: Freq: %u\n", input_freq);
+	for (range = 0; (range < ARRAY_SIZE(range_gen2) - 1) &&
+	     ((input_freq / 1000) > range_gen2[range].freq); range++)
+		;
+
+	data = range_gen2[range].hsfregrange << 1;
+	dw_dphy_te_write(dphy, HSFREQRANGE_8BIT, data);
+
+	return 0;
+}
+
+static int dw_dphy_configure(struct dw_dphy_rx *dphy)
+{
+	dw_dphy_pwr_down(dphy);
+
+	if (dphy->dphy_gen == GEN3) {
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+		dw_dphy_if_init(dphy);
+#endif
+		if (dphy->dphy_te_len == BIT12)
+			dw_dphy_gen3_12bit_configure(dphy);
+		else
+			dw_dphy_gen3_8bit_configure(dphy);
+	} else {
+		dw_dphy_gen2_configure(dphy);
+	}
+	dw_dphy_pwr_up(dphy);
+
+	return 0;
+}
+
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+int dw_dphy_if_set_idelay(struct dw_dphy_rx *dphy, u8 dly, u8 cells)
+{
+	u32 val = 0;
+
+	dw_dphy_if_write(dphy, IDLYCFG, 0);
+	dw_dphy_if_write(dphy, IDLYSEL, cells);
+	dw_dphy_if_write(dphy, IDLYCNTINVAL, dly);
+
+	/* Pulse Value Set */
+	dw_dphy_if_write(dphy, IDLYCFG, 1);
+	usleep_range(10, 20);
+	dw_dphy_if_write(dphy, IDLYCFG, 0);
+
+	/* Pulse IDELAY CTRL Reset */
+	dw_dphy_if_write(dphy, DPHY1REGRSTN, 0);
+	usleep_range(10, 20);
+	dw_dphy_if_write(dphy, DPHY1REGRSTN, 1);
+
+	/* Get Value*/
+	val = dw_dphy_if_read(dphy, IDLYCNTOUTVAL);
+
+	if (val != dly) {
+		dev_vdbg(&dphy->phy->dev,
+			 "odelay config failed, set %d get %d", dly, val);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int dw_dphy_if_get_idelay(struct dw_dphy_rx *dphy)
+{
+	return dw_dphy_if_read(dphy, IDLYCNTOUTVAL);
+}
+
+int dw_dphy_if_set_idelay_lane(struct dw_dphy_rx *dphy, u8 dly, u8 lane)
+{
+	int cell;
+
+	switch (lane) {
+	case 0:
+		for (cell = 3; cell <= 10; cell++)
+			dw_dphy_if_set_idelay(dphy, dly, cell);
+		break;
+	case 1:
+		for (cell = 14; cell <= 21; cell++)
+			dw_dphy_if_set_idelay(dphy, dly, cell);
+		break;
+	case 2:
+		for (cell = 24; cell <= 31; cell++)
+			dw_dphy_if_set_idelay(dphy, dly, cell);
+		break;
+	case 3:
+		for (cell = 34; cell <= 41; cell++)
+			dw_dphy_if_set_idelay(dphy, dly, cell);
+		break;
+	case 4: /* ALL */
+		dw_dphy_if_set_idelay(dphy, dly, 0x7F);
+		break;
+	default:
+		dev_err(&dphy->phy->dev, "Lane Value not recognized\n");
+		return -1;
+	}
+	return 0;
+}
+#endif
+
+int dw_dphy_init(struct phy *phy)
+{
+	struct dw_dphy_rx *dphy = phy_get_drvdata(phy);
+
+	dev_vdbg(&dphy->phy->dev, "Init DPHY.\n");
+
+	dw_dphy_write(dphy, R_CSI2_DPHY_RSTZ, 0);
+	dw_dphy_write(dphy, R_CSI2_DPHY_SHUTDOWNZ, 0);
+
+	return 0;
+}
+
+static int dw_dphy_set_phy_state(struct dw_dphy_rx *dphy, u32 on)
+{
+	u8 hs_freq;
+
+	dphy->lanes_config = dw_dphy_setup_config(dphy);
+
+	if (dphy->dphy_te_len == BIT12)
+		hs_freq = RX_SYS_1;
+	else
+		hs_freq = HSFREQRANGE_8BIT;
+
+	if (on) {
+		dw_dphy_configure(dphy);
+		dev_vdbg(&dphy->phy->dev,
+			 "HS Code: 0X%x\n", dw_dphy_te_read(dphy, hs_freq));
+	} else {
+		dw_dphy_write(dphy, R_CSI2_DPHY_SHUTDOWNZ, 0);
+		dw_dphy_write(dphy, R_CSI2_DPHY_RSTZ, 0);
+	}
+
+	return 0;
+}
+
+int dw_dphy_power_on(struct phy *phy)
+{
+	struct dw_dphy_rx *dphy = phy_get_drvdata(phy);
+
+	return dw_dphy_set_phy_state(dphy, 1);
+}
+
+int dw_dphy_power_off(struct phy *phy)
+{
+	struct dw_dphy_rx *dphy = phy_get_drvdata(phy);
+
+	return dw_dphy_set_phy_state(dphy, 0);
+}
+
+int dw_dphy_reset(struct phy *phy)
+{
+	struct dw_dphy_rx *dphy = phy_get_drvdata(phy);
+
+	dw_dphy_write(dphy, R_CSI2_DPHY_RSTZ, 0);
+	usleep_range(100, 200);
+	dw_dphy_write(dphy, R_CSI2_DPHY_RSTZ, 1);
+
+	return 0;
+}
diff -urN '--label=/dev/null' /dev/null linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-dphy-rx.h
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-dphy-rx.h	2024-12-04 16:41:28.013020100 +0900
@@ -0,0 +1,212 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018-2019 Synopsys, Inc. and/or its affiliates.
+ *
+ * Synopsys DesignWare MIPI D-PHY controller driver
+ *
+ * Author: Luis Oliveira <luis.oliveira@synopsys.com>
+ */
+
+#ifndef __PHY_SNPS_DPHY_RX_H__
+#define __PHY_SNPS_DPHY_RX_H__
+
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#include <linux/phy/phy.h>
+#include <linux/phy/phy-mipi-dphy.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+
+/* DPHY interface register bank*/
+
+#define R_CSI2_DPHY_SHUTDOWNZ 0x0
+#define R_CSI2_DPHY_RSTZ 0x4
+#define R_CSI2_DPHY_RX 0x8
+#define	R_CSI2_DPHY_STOPSTATE 0xC
+#define R_CSI2_DPHY_TST_CTRL0 0x10
+#define R_CSI2_DPHY_TST_CTRL1 0x14
+#define R_CSI2_DPHY2_TST_CTRL0 0x18
+#define R_CSI2_DPHY2_TST_CTRL1 0x1C
+
+enum dphy_id_mask {
+	DPHY_ID_LANE_SUPPORT = 0,
+	DPHY_ID_IF = 4,
+	DPHY_ID_GEN = 8,
+};
+
+enum dphy_gen_values {
+	GEN1,
+	GEN2,
+	GEN3,
+};
+
+enum dphy_interface_length {
+	BIT8 = 8,
+	BIT12 = 12,
+};
+
+enum tst_ctrl0 {
+	PHY_TESTCLR,
+	PHY_TESTCLK,
+};
+
+enum tst_ctrl1 {
+	PHY_TESTDIN = 0,
+	PHY_TESTDOUT = 8,
+	PHY_TESTEN = 16,
+};
+
+enum lanes_config_values {
+	CTRL_4_LANES,
+	CTRL_8_LANES,
+};
+
+enum dphy_tc {
+	CFGCLKFREQRANGE_TX = 0x02,
+	CFGCLKFREQRANGE_RX = 0x05,
+	BYPASS = 0x20,
+	IO_DS = 0x30,
+};
+
+enum dphy_8bit_interface_addr {
+	BANDGAP_CTRL = 0x24,
+	HS_RX_CTRL_LANE0 = 0x42,
+	HSFREQRANGE_8BIT = 0x44,
+	OSC_FREQ_TARGET_RX0_LSB	= 0x4e,
+	OSC_FREQ_TARGET_RX0_MSB	= 0x4f,
+	HS_RX_CTRL_LANE1 = 0x52,
+	OSC_FREQ_TARGET_RX1_LSB	= 0x5e,
+	OSC_FREQ_TARGET_RX1_MSB	= 0x5f,
+	RX_SKEW_CAL = 0x7e,
+	HS_RX_CTRL_LANE2 = 0x82,
+	OSC_FREQ_TARGET_RX2_LSB	= 0x8e,
+	OSC_FREQ_TARGET_RX2_MSB	= 0x8f,
+	HS_RX_CTRL_LANE3 = 0x92,
+	OSC_FREQ_TARGET_RX3_LSB	= 0x9e,
+	OSC_FREQ_TARGET_RX3_MSB	= 0x9f,
+};
+
+enum dphy_12bit_interface_addr {
+	RX_SYS_0 = 0x01,
+	RX_SYS_1 = 0x02,
+	RX_SYS_7 = 0x08,
+	RX_RX_STARTUP_OVR_0 = 0xe0,
+	RX_RX_STARTUP_OVR_1 = 0xe1,
+	RX_RX_STARTUP_OVR_2 = 0xe2,
+	RX_RX_STARTUP_OVR_3 = 0xe3,
+	RX_RX_STARTUP_OVR_4 = 0xe4,
+};
+
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+/* Testchip interface register bank */
+#define IDLYCFG	0x00
+#define IDLYSEL	0x04
+#define IDLYCNTINVAL 0x08
+#define IDLYCNTOUTVAL 0x0c
+#define DPHY1REGRSTN 0x10
+#define DPHYZCALSTAT 0x14
+#define DPHYZCALCTRL 0x18
+#define DPHYLANE0STAT 0x1c
+#define DPHYLANE1STAT 0x20
+#define DPHYLANE2STAT 0x24
+#define DPHYLANE3STAT 0x28
+#define DPHYCLKSTAT 0x2c
+#define DPHYZCLKCTRL 0x30
+#define TCGENPURPOSOUT 0x34
+#define TCGENPURPOSIN 0x38
+#define DPHYGENERICOUT 0x3c
+#define DPHYGENERICIN 0x40
+#define DPHYGLUEIFTESTER 0x44
+#define DPHYID 0x100
+
+#define DPHY_DEFAULT_FREQ 300000
+
+enum glueiftester {
+	RESET = 0x0,
+	TX_PHY = 0x1,
+	RX_PHY = 0x2,
+	GLUELOGIC = 0x4,
+};
+#endif
+
+/**
+ * struct phy		specifies associated phy component
+ * struct cfg		to pass mipi dphy specific configurations
+ * @lanes_config	lanes configuration
+ * @dphy_freq		operating frequency of the d-phy (mbps)
+ * @phy_type		dphy can be of two types, passed here
+ * @dphy_gen		dphy can be of three generations, passed here
+ * @dphy_te_len		bus width
+ * @max_lanes		maximum number of lanes
+ * @lp_time		time in low-power
+ * @base_address	memmory address of dphy test interface
+ * @dphy1_if_addr	gluelogic dphy 1 memmory address of interface
+ * @dphy2_if_addr	gluelogic dphy 2 memmory address of interface
+ * @config_8l		eight lanes configuration
+ */
+
+struct dw_dphy_rx {
+	struct phy *phy;
+	struct phy_configure_opts_mipi_dphy *cfg;
+	u32 lanes_config;
+	u32 dphy_freq;
+	u32 phy_type;
+	u32 dphy_gen;
+	u32 dphy_te_len;
+	u32 max_lanes;
+	u32 lp_time;
+	void __iomem *base_address;
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+	void __iomem *dphy1_if_addr;
+	void __iomem *dphy2_if_addr;
+	u8 config_8l;
+	u8 (*get_config_8l)(struct device *dev, struct dw_dphy_rx *dphy);
+#endif
+	u8 (*phy_register)(struct device *dev);
+	void (*phy_unregister)(struct device *dev);
+};
+
+int dw_dphy_init(struct phy *phy);
+int dw_dphy_reset(struct phy *phy);
+int dw_dphy_power_off(struct phy *phy);
+int dw_dphy_power_on(struct phy *phy);
+u8 dw_dphy_setup_config(struct dw_dphy_rx *dphy);
+void dw_dphy_write(struct dw_dphy_rx *dphy, u32 address, u32 data);
+u32 dw_dphy_read(struct dw_dphy_rx *dphy, u32 address);
+int dw_dphy_te_read(struct dw_dphy_rx *dphy, u32 addr);
+
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+u32 dw_dphy_if_read(struct dw_dphy_rx *dphy, u32 address);
+int dw_dphy_if_get_idelay(struct dw_dphy_rx *dphy);
+int dw_dphy_if_set_idelay_lane(struct dw_dphy_rx *dphy, u8 dly, u8 lane);
+int dw_dphy_create_capabilities_sysfs(struct platform_device *pdev);
+
+static inline
+u32 dw_dphy_if_read_msk(struct dw_dphy_rx *dphy,
+			u32 address, u8 shift, u8 width)
+{
+	return (dw_dphy_if_read(dphy, address) >> shift) & ((1 << width) - 1);
+}
+#endif /*IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)*/
+
+static inline struct phy *dw_dphy_xlate(struct device *dev,
+					struct of_phandle_args *args)
+{
+	struct dw_dphy_rx *dphy = dev_get_drvdata(dev);
+
+	return dphy->phy;
+}
+
+static inline
+u32 dw_dphy_read_msk(struct dw_dphy_rx *dev, u32 address, u8 shift,  u8 width)
+{
+	return (dw_dphy_read(dev, address) >> shift) & ((1 << width) - 1);
+}
+#endif /*__PHY_SNPS_DPHY_RX_H__*/
diff -urN '--label=/dev/null' /dev/null linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-dphy-sysfs.c
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-dphy-sysfs.c	2024-12-04 16:41:28.014017500 +0900
@@ -0,0 +1,232 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018-2019 Synopsys, Inc. and/or its affiliates.
+ *
+ * Synopsys DesignWare MIPI D-PHY controller driver.
+ * SysFS components for the platform driver
+ *
+ * Author: Luis Oliveira <luis.oliveira@synopsys.com>
+ */
+
+#include "dw-dphy-rx.h"
+
+static ssize_t dphy_reset_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dw_dphy_rx *dphy = platform_get_drvdata(pdev);
+	char buffer[15];
+
+	dw_dphy_write(dphy, R_CSI2_DPHY_RSTZ, 0);
+	usleep_range(100, 200);
+	dw_dphy_write(dphy, R_CSI2_DPHY_RSTZ, 1);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t dphy_freq_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf,
+			       size_t count)
+{
+	int ret;
+	unsigned long freq;
+
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dw_dphy_rx *dphy = platform_get_drvdata(pdev);
+
+	ret = kstrtoul(buf, 10, &freq);
+	if (ret < 0)
+		return ret;
+
+	if (freq > 2500) {
+		dev_info(dev, "Freq must be under 2500 Mhz\n");
+		return count;
+	}
+	if (freq < 80) {
+		dev_info(dev, "Freq must be over 80 Mhz\n");
+		return count;
+	}
+
+	dev_vdbg(dev, "Data Rate %lu Mbps\n", freq);
+	dphy->dphy_freq = freq;
+
+	return count;
+}
+
+static ssize_t dphy_freq_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dw_dphy_rx *dphy = platform_get_drvdata(pdev);
+	char buffer[15];
+
+	snprintf(buffer,
+		 sizeof(buffer),
+		 "Freq %d\n", dphy->dphy_freq);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t dphy_addr_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf,
+			       size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dw_dphy_rx *dphy = platform_get_drvdata(pdev);
+	unsigned long val;
+	u8 addr, payload;
+	int ret;
+
+	ret = kstrtoul(buf, 32, &val);
+	if (ret < 0)
+		return ret;
+
+	payload = (u16)val;
+	addr = (u16)(val >> 16);
+
+	dev_vdbg(dev, "addr 0x%lX\n", val);
+	dev_vdbg(dev, "payload: 0x%X\n", addr);
+	dev_vdbg(dev, "Addr [0x%x] -> 0x%x\n", (unsigned int)addr,
+		 dw_dphy_te_read(dphy, addr));
+
+	return count;
+}
+
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+static ssize_t idelay_show(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dw_dphy_rx *dphy = platform_get_drvdata(pdev);
+	char buffer[15];
+
+	snprintf(buffer,
+		 sizeof(buffer), "idelay %d\n", dw_dphy_if_get_idelay(dphy));
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t idelay_store(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dw_dphy_rx *dphy = platform_get_drvdata(pdev);
+	unsigned long val;
+	u8 lane, delay;
+	int ret;
+
+	ret = kstrtoul(buf, 16, &val);
+	if (ret < 0)
+		return ret;
+
+	lane = (u8)val;
+	delay = (u8)(val >> 8);
+
+	dev_vdbg(dev, "Lanes %u\n", lane);
+	dev_vdbg(dev, "Delay %u\n", delay);
+
+	dw_dphy_if_set_idelay_lane(dphy, delay, lane);
+
+	return count;
+}
+#endif
+
+static ssize_t len_config_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf,
+				size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dw_dphy_rx *dphy = platform_get_drvdata(pdev);
+	unsigned long length;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &length);
+	if (ret < 0)
+		return ret;
+
+	if (length == BIT8)
+		dev_vdbg(dev, "Configured for 8-bit interface\n");
+	else if (length == BIT12)
+		dev_vdbg(dev, "Configured for 12-bit interface\n");
+	else
+		return count;
+
+	dphy->dphy_te_len = length;
+
+	return count;
+}
+
+static ssize_t len_config_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dw_dphy_rx *dphy = platform_get_drvdata(pdev);
+	char buffer[20];
+
+	snprintf(buffer, sizeof(buffer), "Length %d\n", dphy->dphy_te_len);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static ssize_t dw_dphy_g118_settle_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dw_dphy_rx *dphy = platform_get_drvdata(pdev);
+	unsigned long lp_time;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &lp_time);
+	if (ret < 0)
+		return ret;
+
+	if (lp_time > 1 && lp_time < 10000) {
+		dphy->lp_time = lp_time;
+	} else {
+		dev_vdbg(dev, "Invalid Value configuring for 1000 ns\n");
+		dphy->lp_time = 1000;
+	}
+
+	dphy->lp_time = lp_time;
+
+	return count;
+}
+
+static ssize_t dw_dphy_g118_settle_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dw_dphy_rx *dphy = platform_get_drvdata(pdev);
+	char buffer[10];
+
+	snprintf(buffer, sizeof(buffer), "Settle %d ns\n", dphy->lp_time);
+
+	return strlcpy(buf, buffer, PAGE_SIZE);
+}
+
+static DEVICE_ATTR_RO(dphy_reset);
+static DEVICE_ATTR_RW(dphy_freq);
+static DEVICE_ATTR_WO(dphy_addr);
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+static DEVICE_ATTR_RW(idelay);
+#endif
+static DEVICE_ATTR_RW(len_config);
+static DEVICE_ATTR_RW(dw_dphy_g118_settle);
+
+int dw_dphy_create_capabilities_sysfs(struct platform_device *pdev)
+{
+	device_create_file(&pdev->dev, &dev_attr_dphy_reset);
+	device_create_file(&pdev->dev, &dev_attr_dphy_freq);
+	device_create_file(&pdev->dev, &dev_attr_dphy_addr);
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+	device_create_file(&pdev->dev, &dev_attr_idelay);
+#endif
+	device_create_file(&pdev->dev, &dev_attr_len_config);
+	device_create_file(&pdev->dev, &dev_attr_dw_dphy_g118_settle);
+	return 0;
+}
diff -urN '--label=/dev/null' /dev/null linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-mipi-csi.c
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-mipi-csi.c	2024-12-04 16:41:28.014017500 +0900
@@ -0,0 +1,570 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018-2019 Synopsys, Inc. and/or its affiliates.
+ *
+ * Synopsys DesignWare MIPI CSI-2 Host controller driver
+ * Core MIPI CSI-2 functions
+ *
+ * Author: Luis Oliveira <Luis.Oliveira@synopsys.com>
+ */
+
+#include "dw-mipi-csi.h"
+
+static struct R_CSI2 reg = {
+	.VERSION = 0x00,
+	.N_LANES = 0x04,
+	.CTRL_RESETN = 0x08,
+	.INTERRUPT = 0x0C,
+	.DATA_IDS_1 = 0x10,
+	.DATA_IDS_2 = 0x14,
+	.IPI_MODE = 0x80,
+	.IPI_VCID = 0x84,
+	.IPI_DATA_TYPE = 0x88,
+	.IPI_MEM_FLUSH = 0x8C,
+	.IPI_HSA_TIME = 0x90,
+	.IPI_HBP_TIME = 0x94,
+	.IPI_HSD_TIME = 0x98,
+	.IPI_HLINE_TIME = 0x9C,
+	.IPI_SOFTRSTN = 0xA0,
+	.IPI_ADV_FEATURES = 0xAC,
+	.IPI_VSA_LINES = 0xB0,
+	.IPI_VBP_LINES = 0xB4,
+	.IPI_VFP_LINES = 0xB8,
+	.IPI_VACTIVE_LINES = 0xBC,
+	.INT_PHY_FATAL = 0xe0,
+	.MASK_INT_PHY_FATAL = 0xe4,
+	.FORCE_INT_PHY_FATAL = 0xe8,
+	.INT_PKT_FATAL = 0xf0,
+	.MASK_INT_PKT_FATAL = 0xf4,
+	.FORCE_INT_PKT_FATAL = 0xf8,
+	.INT_PHY = 0x110,
+	.MASK_INT_PHY = 0x114,
+	.FORCE_INT_PHY = 0x118,
+	.INT_LINE = 0x130,
+	.MASK_INT_LINE = 0x134,
+	.FORCE_INT_LINE = 0x138,
+	.INT_IPI = 0x140,
+	.MASK_INT_IPI = 0x144,
+	.FORCE_INT_IPI = 0x148,
+};
+
+struct interrupt_type csi_int = {
+	.PHY_FATAL = BIT(0),
+	.PKT_FATAL = BIT(1),
+	.PHY = BIT(16),
+};
+
+#define dw_print(VAR) \
+	dev_info(csi_dev->dev, "%s: 0x%x: %X\n", "#VAR#",\
+	VAR, dw_mipi_csi_read(csi_dev, VAR))
+
+void dw_mipi_csi_write_part(struct dw_csi *dev, u32 address, u32 data,
+			    u8 shift, u8 width)
+{
+	u32 mask = (1 << width) - 1;
+	u32 temp = dw_mipi_csi_read(dev, address);
+
+	temp &= ~(mask << shift);
+	temp |= (data & mask) << shift;
+	dw_mipi_csi_write(dev, address, temp);
+}
+
+void dw_mipi_csi_reset(struct dw_csi *csi_dev)
+{
+	dw_mipi_csi_write(csi_dev, reg.CTRL_RESETN, 0);
+	usleep_range(100, 200);
+	dw_mipi_csi_write(csi_dev, reg.CTRL_RESETN, 1);
+}
+
+int dw_mipi_csi_mask_irq_power_off(struct dw_csi *csi_dev)
+{
+	if (csi_dev->hw_version_major == 1) {
+		/* set only one lane (lane 0) as active (ON) */
+		dw_mipi_csi_write(csi_dev, reg.N_LANES, 0);
+		dw_mipi_csi_write(csi_dev, reg.MASK_INT_PHY_FATAL, 0);
+		dw_mipi_csi_write(csi_dev, reg.MASK_INT_PKT_FATAL, 0);
+		dw_mipi_csi_write(csi_dev, reg.MASK_INT_PHY, 0);
+		dw_mipi_csi_write(csi_dev, reg.MASK_INT_LINE, 0);
+		dw_mipi_csi_write(csi_dev, reg.MASK_INT_IPI, 0);
+
+		/* only for version 1.30 */
+		if (csi_dev->hw_version_minor == 30)
+			dw_mipi_csi_write(csi_dev,
+					  reg.MASK_INT_FRAME_FATAL, 0);
+
+		dw_mipi_csi_write(csi_dev, reg.CTRL_RESETN, 0);
+
+		/* only for version 1.40 */
+		if (csi_dev->hw_version_minor == 40) {
+			dw_mipi_csi_write(csi_dev,
+					  reg.MSK_BNDRY_FRAME_FATAL, 0);
+			dw_mipi_csi_write(csi_dev,
+					  reg.MSK_SEQ_FRAME_FATAL, 0);
+			dw_mipi_csi_write(csi_dev,
+					  reg.MSK_CRC_FRAME_FATAL, 0);
+			dw_mipi_csi_write(csi_dev, reg.MSK_PLD_CRC_FATAL, 0);
+			dw_mipi_csi_write(csi_dev, reg.MSK_DATA_ID, 0);
+			dw_mipi_csi_write(csi_dev, reg.MSK_ECC_CORRECT, 0);
+		}
+	}
+
+	return 0;
+}
+
+int dw_mipi_csi_hw_stdby(struct dw_csi *csi_dev)
+{
+	if (csi_dev->hw_version_major == 1) {
+		/* set only one lane (lane 0) as active (ON) */
+		dw_mipi_csi_reset(csi_dev);
+		dw_mipi_csi_write(csi_dev, reg.N_LANES, 0);
+		phy_init(csi_dev->phy);
+
+		/* only for version 1.30 */
+		if (csi_dev->hw_version_minor == 30)
+			dw_mipi_csi_write(csi_dev,
+					  reg.MASK_INT_FRAME_FATAL,
+					  GENMASK(31, 0));
+
+		/* common */
+		dw_mipi_csi_write(csi_dev, reg.MASK_INT_PHY_FATAL,
+				  GENMASK(8, 0));
+		dw_mipi_csi_write(csi_dev, reg.MASK_INT_PKT_FATAL,
+				  GENMASK(1, 0));
+		dw_mipi_csi_write(csi_dev, reg.MASK_INT_PHY, GENMASK(23, 0));
+		dw_mipi_csi_write(csi_dev, reg.MASK_INT_LINE, GENMASK(23, 0));
+		dw_mipi_csi_write(csi_dev, reg.MASK_INT_IPI, GENMASK(5, 0));
+
+		/* only for version 1.40 */
+		if (csi_dev->hw_version_minor == 40) {
+			dw_mipi_csi_write(csi_dev,
+					  reg.MSK_BNDRY_FRAME_FATAL,
+					  GENMASK(31, 0));
+			dw_mipi_csi_write(csi_dev,
+					  reg.MSK_SEQ_FRAME_FATAL,
+					  GENMASK(31, 0));
+			dw_mipi_csi_write(csi_dev,
+					  reg.MSK_CRC_FRAME_FATAL,
+					  GENMASK(31, 0));
+			dw_mipi_csi_write(csi_dev,
+					  reg.MSK_PLD_CRC_FATAL,
+					  GENMASK(31, 0));
+			dw_mipi_csi_write(csi_dev,
+					  reg.MSK_DATA_ID, GENMASK(31, 0));
+			dw_mipi_csi_write(csi_dev,
+					  reg.MSK_ECC_CORRECT, GENMASK(31, 0));
+		}
+	}
+	return 0;
+}
+
+void dw_mipi_csi_set_ipi_fmt(struct dw_csi *csi_dev)
+{
+	struct device *dev = csi_dev->dev;
+
+	if (csi_dev->ipi_dt) {
+		dw_mipi_csi_write(csi_dev, reg.IPI_DATA_TYPE, csi_dev->ipi_dt);
+		switch (csi_dev->ipi_dt) {
+		case CSI_2_YUV420_8:
+		case CSI_2_YUV420_8_LEG:
+		case CSI_2_YUV420_8_SHIFT:
+		break;
+		case CSI_2_YUV420_10:
+		case CSI_2_YUV420_10_SHIFT:
+		break;
+		}
+	} else {
+		switch (csi_dev->fmt->mbus_code) {
+		/* RGB 666 */
+		case MEDIA_BUS_FMT_RGB666_1X18:
+		csi_dev->ipi_dt =  CSI_2_RGB666;
+		break;
+		/* RGB 565 */
+		case MEDIA_BUS_FMT_RGB565_2X8_BE:
+		case MEDIA_BUS_FMT_RGB565_2X8_LE:
+		csi_dev->ipi_dt = CSI_2_RGB565;
+		break;
+		/* RGB 555 */
+		case MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE:
+		case MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE:
+		csi_dev->ipi_dt = CSI_2_RGB555;
+		break;
+		/* RGB 444 */
+		case MEDIA_BUS_FMT_RGB444_2X8_PADHI_BE:
+		case MEDIA_BUS_FMT_RGB444_2X8_PADHI_LE:
+		csi_dev->ipi_dt = CSI_2_RGB444;
+		break;
+		/* RGB 888 */
+		break;
+		case MEDIA_BUS_FMT_RGB888_2X12_LE:
+		case MEDIA_BUS_FMT_RGB888_2X12_BE:
+		csi_dev->ipi_dt = CSI_2_RGB888;
+		break;
+		/* RAW 10 */
+		case MEDIA_BUS_FMT_SBGGR10_1X10:
+		case MEDIA_BUS_FMT_SRGGB10_1X10:
+		case MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_BE:
+		csi_dev->ipi_dt = CSI_2_RAW10;
+		break;
+		/* RAW 12 */
+		case MEDIA_BUS_FMT_SBGGR12_1X12:
+		csi_dev->ipi_dt = CSI_2_RAW12;
+		break;
+		/* RAW 14 */
+		case MEDIA_BUS_FMT_SBGGR14_1X14:
+		csi_dev->ipi_dt = CSI_2_RAW14;
+		break;
+		/* RAW 16 */
+		case MEDIA_BUS_FMT_SBGGR16_1X16:
+		csi_dev->ipi_dt = CSI_2_RAW16;
+		break;
+		/* RAW 8 */
+		case MEDIA_BUS_FMT_SBGGR8_1X8:
+		csi_dev->ipi_dt = CSI_2_RAW8;
+		break;
+		/* YUV 422 8-bit */
+		case MEDIA_BUS_FMT_YVYU8_2X8:
+		csi_dev->ipi_dt = CSI_2_RAW8;
+		break;
+		/* YUV 422 10-bit */
+		case MEDIA_BUS_FMT_VYUY8_1X16:
+		csi_dev->ipi_dt = CSI_2_YUV422_8;
+		break;
+		/* YUV 420 8-bit LEGACY */
+		case MEDIA_BUS_FMT_Y8_1X8:
+		csi_dev->ipi_dt = CSI_2_RAW8;
+		break;
+		/* YUV 420 10-bit */
+		case MEDIA_BUS_FMT_Y10_1X10:
+		csi_dev->ipi_dt = CSI_2_RAW8;
+		break;
+		default:
+		break;
+		}
+		dw_mipi_csi_write(csi_dev, reg.DATA_IDS_1, csi_dev->ipi_dt);
+	}
+	dev_dbg(dev, "Selected IPI Data Type 0x%X\n", csi_dev->ipi_dt);
+}
+
+void dw_mipi_csi_fill_timings(struct dw_csi *dev,
+			      struct v4l2_subdev_format *fmt)
+{
+	/* expected values */
+	dev->hw.virtual_ch = 0;
+	dev->hw.ipi_color_mode = COLOR48;
+	dev->hw.ipi_auto_flush = 1;
+	dev->hw.ipi_mode = CAMERA_TIMING;
+	dev->hw.ipi_cut_through = CTINACTIVE;
+	dev->hw.ipi_adv_features = LINE_EVENT_SELECTION(EVSELAUTO);
+	dev->hw.htotal = fmt->format.width + dev->hw.hsa +
+			 dev->hw.hbp + dev->hw.hsd;
+	dev->hw.vactive = fmt->format.height;
+	dev->hw.output = 2;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		dev_dbg(dev->dev, "*********** timings *********\n");
+		dev_dbg(dev->dev, "Horizontal Sync Active: %d\n", dev->hw.hsa);
+		dev_dbg(dev->dev, "Horizontal Back Porch: %d\n", dev->hw.hbp);
+		dev_dbg(dev->dev, "Horizontal Width: %d\n", fmt->format.width);
+		dev_dbg(dev->dev, "Horizontal Total: %d\n", dev->hw.htotal);
+		dev_dbg(dev->dev, "Vertical Sync Active: %d\n", dev->hw.vsa);
+		dev_dbg(dev->dev, "Vertical Back Porch: %d\n", dev->hw.vbp);
+		dev_dbg(dev->dev, "Vertical Front Porch: %d\n", dev->hw.vfp);
+		dev_dbg(dev->dev, "Vertical Active: %d\n", dev->hw.vactive);
+	}
+}
+
+void dw_mipi_csi_start(struct dw_csi *csi_dev)
+{
+	struct device *dev = csi_dev->dev;
+
+	dw_mipi_csi_write(csi_dev, reg.N_LANES, (csi_dev->hw.num_lanes - 1));
+	dev_dbg(dev, "number of lanes: %d\n", csi_dev->hw.num_lanes);
+
+	/* IPI Related Configuration */
+	if (csi_dev->hw.output == IPI_OUT || csi_dev->hw.output == BOTH_OUT) {
+		if (csi_dev->hw_version_major >= 1) {
+			if (csi_dev->hw_version_minor >= 20)
+				dw_mipi_csi_write(csi_dev,
+						  reg.IPI_ADV_FEATURES,
+						  csi_dev->hw.ipi_adv_features);
+			if (csi_dev->hw_version_minor >= 30)
+				dw_mipi_csi_write(csi_dev,
+						  reg.IPI_SOFTRSTN, 0x1);
+		}
+		/*  address | data, | shift | width */
+		dw_mipi_csi_write_part(csi_dev, reg.IPI_MODE, 1, 24, 1);
+		dw_mipi_csi_write_part(csi_dev,
+				       reg.IPI_MODE,
+				       csi_dev->hw.ipi_mode,
+				       0, 1);
+		if (csi_dev->hw.ipi_mode == CAMERA_TIMING) {
+			dw_mipi_csi_write(csi_dev,
+					  reg.IPI_ADV_FEATURES,
+					  LINE_EVENT_SELECTION(EVSELPROG) |
+					  EN_VIDEO |
+					  EN_LINE_START |
+					  EN_NULL |
+					  EN_BLANKING |
+					  EN_EMBEDDED);
+		}
+		dw_mipi_csi_write_part(csi_dev,
+				       reg.IPI_MODE,
+				       csi_dev->hw.ipi_color_mode,
+				       8, 1);
+		dw_mipi_csi_write_part(csi_dev,
+				       reg.IPI_MODE,
+				       csi_dev->hw.ipi_cut_through,
+				       16, 1);
+		dw_mipi_csi_write_part(csi_dev,
+				       reg.IPI_VCID,
+				       csi_dev->hw.virtual_ch,
+				       0, 2);
+		dw_mipi_csi_write_part(csi_dev,
+				       reg.IPI_MEM_FLUSH,
+				       csi_dev->hw.ipi_auto_flush,
+				       8, 1);
+
+		dev_vdbg(dev, "*********** config *********\n");
+		dev_vdbg(dev, "IPI enable: %s\n",
+			 csi_dev->hw.output ? "YES" : "NO");
+		dev_vdbg(dev, "video mode transmission type: %s timming\n",
+			 csi_dev->hw.ipi_mode ? "controller" : "camera");
+		dev_vdbg(dev, "Color Mode: %s\n",
+			 csi_dev->hw.ipi_color_mode ? "16 bits" : "48 bits");
+		dev_vdbg(dev, "Cut Through Mode: %s\n",
+			 csi_dev->hw.ipi_cut_through ? "enable" : "disable");
+		dev_vdbg(dev, "Virtual Channel: %d\n",
+			 csi_dev->hw.virtual_ch);
+		dev_vdbg(dev, "Auto-flush: %d\n",
+			 csi_dev->hw.ipi_auto_flush);
+		dw_mipi_csi_write(csi_dev, reg.IPI_SOFTRSTN, 1);
+
+		if (csi_dev->hw.ipi_mode == AUTO_TIMING)
+			phy_power_on(csi_dev->phy);
+
+		dw_mipi_csi_write(csi_dev,
+				  reg.IPI_HSA_TIME, csi_dev->hw.hsa);
+		dw_mipi_csi_write(csi_dev,
+				  reg.IPI_HBP_TIME, csi_dev->hw.hbp);
+		dw_mipi_csi_write(csi_dev,
+				  reg.IPI_HSD_TIME, csi_dev->hw.hsd);
+		dw_mipi_csi_write(csi_dev,
+				  reg.IPI_HLINE_TIME, csi_dev->hw.htotal);
+		dw_mipi_csi_write(csi_dev,
+				  reg.IPI_VSA_LINES, csi_dev->hw.vsa);
+		dw_mipi_csi_write(csi_dev,
+				  reg.IPI_VBP_LINES, csi_dev->hw.vbp);
+		dw_mipi_csi_write(csi_dev,
+				  reg.IPI_VFP_LINES, csi_dev->hw.vfp);
+		dw_mipi_csi_write(csi_dev,
+				  reg.IPI_VACTIVE_LINES, csi_dev->hw.vactive);
+	}
+	phy_power_on(csi_dev->phy);
+}
+
+int dw_mipi_csi_irq_handler(struct dw_csi *csi_dev)
+{
+	struct device *dev = csi_dev->dev;
+	u32 global_int_status, i_sts;
+	unsigned long flags;
+
+	spin_lock_irqsave(&csi_dev->slock, flags);
+	global_int_status = dw_mipi_csi_read(csi_dev, reg.INTERRUPT);
+
+	if (global_int_status & csi_int.PHY_FATAL) {
+		i_sts = dw_mipi_csi_read(csi_dev, reg.INT_PHY_FATAL);
+		dev_err_ratelimited(dev, "int %08X: PHY FATAL: %08X\n",
+				    reg.INT_PHY_FATAL, i_sts);
+	}
+
+	if (global_int_status & csi_int.PKT_FATAL) {
+		i_sts = dw_mipi_csi_read(csi_dev, reg.INT_PKT_FATAL);
+		dev_err_ratelimited(dev, "int %08X: PKT FATAL: %08X\n",
+				    reg.INT_PKT_FATAL, i_sts);
+	}
+
+	if (global_int_status & csi_int.FRAME_FATAL &&
+	    csi_dev->hw_version_major == 1 &&
+	    csi_dev->hw_version_minor == 30) {
+		i_sts = dw_mipi_csi_read(csi_dev, reg.INT_FRAME_FATAL);
+		dev_err_ratelimited(dev, "int %08X: FRAME FATAL: %08X\n",
+				    reg.INT_FRAME_FATAL, i_sts);
+	}
+
+	if (global_int_status & csi_int.PHY) {
+		i_sts = dw_mipi_csi_read(csi_dev, reg.INT_PHY);
+		dev_err_ratelimited(dev, "int %08X: PHY: %08X\n",
+				    reg.INT_PHY, i_sts);
+	}
+
+	if (global_int_status & csi_int.PKT &&
+	    csi_dev->hw_version_major == 1 &&
+	    csi_dev->hw_version_minor <= 30) {
+		i_sts = dw_mipi_csi_read(csi_dev, reg.INT_PKT);
+		dev_err_ratelimited(dev, "int %08X: PKT: %08X\n",
+				    reg.INT_PKT, i_sts);
+	}
+
+	if (global_int_status & csi_int.LINE) {
+		i_sts = dw_mipi_csi_read(csi_dev, reg.INT_LINE);
+		dev_err_ratelimited(dev, "int %08X: LINE: %08X\n",
+				    reg.INT_LINE, i_sts);
+	}
+
+	if (global_int_status & csi_int.IPI) {
+		i_sts = dw_mipi_csi_read(csi_dev, reg.INT_IPI);
+		dev_err_ratelimited(dev, "int %08X: IPI: %08X\n",
+				    reg.INT_IPI, i_sts);
+	}
+
+	if (global_int_status & csi_int.BNDRY_FRAME_FATAL) {
+		i_sts = dw_mipi_csi_read(csi_dev, reg.ST_BNDRY_FRAME_FATAL);
+		dev_err_ratelimited(dev,
+				    "int %08X: ST_BNDRY_FRAME_FATAL: %08X\n",
+				    reg.ST_BNDRY_FRAME_FATAL, i_sts);
+	}
+
+	if (global_int_status & csi_int.SEQ_FRAME_FATAL) {
+		i_sts = dw_mipi_csi_read(csi_dev, reg.ST_SEQ_FRAME_FATAL);
+		dev_err_ratelimited(dev,
+				    "int %08X: ST_SEQ_FRAME_FATAL: %08X\n",
+				    reg.ST_SEQ_FRAME_FATAL, i_sts);
+	}
+
+	if (global_int_status & csi_int.CRC_FRAME_FATAL) {
+		i_sts = dw_mipi_csi_read(csi_dev, reg.ST_CRC_FRAME_FATAL);
+		dev_err_ratelimited(dev,
+				    "int %08X: ST_CRC_FRAME_FATAL: %08X\n",
+				    reg.ST_CRC_FRAME_FATAL, i_sts);
+	}
+
+	if (global_int_status & csi_int.PLD_CRC_FATAL) {
+		i_sts = dw_mipi_csi_read(csi_dev, reg.ST_PLD_CRC_FATAL);
+		dev_err_ratelimited(dev,
+				    "int %08X: ST_PLD_CRC_FATAL: %08X\n",
+				    reg.ST_PLD_CRC_FATAL, i_sts);
+	}
+
+	if (global_int_status & csi_int.DATA_ID) {
+		i_sts = dw_mipi_csi_read(csi_dev, reg.ST_DATA_ID);
+		dev_err_ratelimited(dev, "int %08X: ST_DATA_ID: %08X\n",
+				    reg.ST_DATA_ID, i_sts);
+	}
+
+	if (global_int_status & csi_int.ECC_CORRECTED) {
+		i_sts = dw_mipi_csi_read(csi_dev, reg.ST_ECC_CORRECT);
+		dev_err_ratelimited(dev, "int %08X: ST_ECC_CORRECT: %08X\n",
+				    reg.ST_ECC_CORRECT, i_sts);
+	}
+
+	spin_unlock_irqrestore(&csi_dev->slock, flags);
+
+	return 1;
+}
+
+void dw_mipi_csi_get_version(struct dw_csi *csi_dev)
+{
+	u32 hw_version;
+
+	hw_version = dw_mipi_csi_read(csi_dev, reg.VERSION);
+	csi_dev->hw_version_major = (u8)((hw_version >> 24) - '0');
+	csi_dev->hw_version_minor = (u8)((hw_version >> 16) - '0');
+	csi_dev->hw_version_minor = csi_dev->hw_version_minor * 10;
+	csi_dev->hw_version_minor += (u8)((hw_version >> 8) - '0');
+}
+
+int dw_mipi_csi_specific_mappings(struct dw_csi *csi_dev)
+{
+	struct device *dev = csi_dev->dev;
+
+	if (csi_dev->hw_version_major == 1) {
+		if (csi_dev->hw_version_minor == 30) {
+			/*
+			 * Hardware registers that were
+			 * exclusive to version < 1.40
+			 */
+			reg.INT_FRAME_FATAL = 0x100;
+			reg.MASK_INT_FRAME_FATAL = 0x104;
+			reg.FORCE_INT_FRAME_FATAL = 0x108;
+			reg.INT_PKT = 0x120;
+			reg.MASK_INT_PKT = 0x124;
+			reg.FORCE_INT_PKT = 0x128;
+
+			/* interrupt source present until this release */
+			csi_int.PKT = BIT(17);
+			csi_int.LINE = BIT(18);
+			csi_int.IPI = BIT(19);
+			csi_int.FRAME_FATAL = BIT(2);
+
+		} else if (csi_dev->hw_version_minor == 40) {
+			/*
+			 * HW registers that were added
+			 * to version 1.40
+			 */
+			reg.ST_BNDRY_FRAME_FATAL = 0x280;
+			reg.MSK_BNDRY_FRAME_FATAL = 0x284;
+			reg.FORCE_BNDRY_FRAME_FATAL = 0x288;
+			reg.ST_SEQ_FRAME_FATAL = 0x290;
+			reg.MSK_SEQ_FRAME_FATAL	= 0x294;
+			reg.FORCE_SEQ_FRAME_FATAL = 0x298;
+			reg.ST_CRC_FRAME_FATAL = 0x2a0;
+			reg.MSK_CRC_FRAME_FATAL	= 0x2a4;
+			reg.FORCE_CRC_FRAME_FATAL = 0x2a8;
+			reg.ST_PLD_CRC_FATAL = 0x2b0;
+			reg.MSK_PLD_CRC_FATAL = 0x2b4;
+			reg.FORCE_PLD_CRC_FATAL = 0x2b8;
+			reg.ST_DATA_ID = 0x2c0;
+			reg.MSK_DATA_ID = 0x2c4;
+			reg.FORCE_DATA_ID = 0x2c8;
+			reg.ST_ECC_CORRECT = 0x2d0;
+			reg.MSK_ECC_CORRECT = 0x2d4;
+			reg.FORCE_ECC_CORRECT = 0x2d8;
+			reg.DATA_IDS_VC_1 = 0x0;
+			reg.DATA_IDS_VC_2 = 0x0;
+			reg.VC_EXTENSION = 0x0;
+
+			/* interrupts map were changed */
+			csi_int.LINE = BIT(17);
+			csi_int.IPI = BIT(18);
+			csi_int.BNDRY_FRAME_FATAL = BIT(2);
+			csi_int.SEQ_FRAME_FATAL	= BIT(3);
+			csi_int.CRC_FRAME_FATAL = BIT(4);
+			csi_int.PLD_CRC_FATAL = BIT(5);
+			csi_int.DATA_ID = BIT(6);
+			csi_int.ECC_CORRECTED = BIT(7);
+
+		} else {
+			dev_info(dev, "Version minor not supported.");
+		}
+	} else {
+		dev_info(dev, "Version major not supported.");
+	}
+	return 0;
+}
+
+void dw_mipi_csi_dump(struct dw_csi *csi_dev)
+{
+	dw_print(reg.VERSION);
+	dw_print(reg.N_LANES);
+	dw_print(reg.CTRL_RESETN);
+	dw_print(reg.INTERRUPT);
+	dw_print(reg.DATA_IDS_1);
+	dw_print(reg.DATA_IDS_2);
+	dw_print(reg.IPI_MODE);
+	dw_print(reg.IPI_VCID);
+	dw_print(reg.IPI_DATA_TYPE);
+	dw_print(reg.IPI_MEM_FLUSH);
+	dw_print(reg.IPI_HSA_TIME);
+	dw_print(reg.IPI_HBP_TIME);
+	dw_print(reg.IPI_HSD_TIME);
+	dw_print(reg.IPI_HLINE_TIME);
+	dw_print(reg.IPI_SOFTRSTN);
+	dw_print(reg.IPI_ADV_FEATURES);
+	dw_print(reg.IPI_VSA_LINES);
+	dw_print(reg.IPI_VBP_LINES);
+	dw_print(reg.IPI_VFP_LINES);
+	dw_print(reg.IPI_VACTIVE_LINES);
+	dw_print(reg.IPI_DATA_TYPE);
+	dw_print(reg.VERSION);
+	dw_print(reg.IPI_ADV_FEATURES);
+}
diff -urN '--label=/dev/null' /dev/null linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-mipi-csi.h
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/dwc/dw-mipi-csi.h	2024-12-04 16:41:28.014017500 +0900
@@ -0,0 +1,294 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018-2019 Synopsys, Inc. and/or its affiliates.
+ *
+ * Synopsys DesignWare MIPI CSI-2 Host controller driver
+ *
+ * Author: Luis Oliveira <Luis.Oliveira@synopsys.com>
+ */
+
+#ifndef _DW_MIPI_CSI_H__
+#define _DW_MIPI_CSI_H__
+
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/phy/phy.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/ratelimit.h>
+#include <linux/reset.h>
+#include <linux/videodev2.h>
+#include <linux/wait.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/dwc/dw-mipi-csi-pltfrm.h>
+
+/* Advanced features */
+#define IPI_DT_OVERWRITE BIT(0)
+#define DATA_TYPE_OVERWRITE(dt) (((dt) & GENMASK(5, 0)) << 8)
+#define LINE_EVENT_SELECTION(n) ((n) << 16)
+
+enum line_event {
+	EVSELAUTO = 0,
+	EVSELPROG = 1,
+};
+
+#define EN_VIDEO BIT(17)
+#define EN_LINE_START BIT(18)
+#define EN_NULL BIT(19)
+#define EN_BLANKING BIT(20)
+#define EN_EMBEDDED BIT(21)
+#define IPI_SYNC_EVENT_MODE(n) ((n) << 24)
+
+enum sync_event {
+	SYNCEVFSN = 0,
+	SYNCEVFS = 1,
+};
+
+/* DW MIPI CSI-2 register addresses*/
+
+struct R_CSI2 {
+	u16 VERSION;
+	u16 N_LANES;
+	u16 CTRL_RESETN;
+	u16 INTERRUPT;
+	u16 DATA_IDS_1;
+	u16 DATA_IDS_2;
+	u16 DATA_IDS_VC_1;
+	u16 DATA_IDS_VC_2;
+	u16 IPI_MODE;
+	u16 IPI_VCID;
+	u16 IPI_DATA_TYPE;
+	u16 IPI_MEM_FLUSH;
+	u16 IPI_HSA_TIME;
+	u16 IPI_HBP_TIME;
+	u16 IPI_HSD_TIME;
+	u16 IPI_HLINE_TIME;
+	u16 IPI_SOFTRSTN;
+	u16 IPI_ADV_FEATURES;
+	u16 IPI_VSA_LINES;
+	u16 IPI_VBP_LINES;
+	u16 IPI_VFP_LINES;
+	u16 IPI_VACTIVE_LINES;
+	u16 VC_EXTENSION;
+	u16 INT_PHY_FATAL;
+	u16 MASK_INT_PHY_FATAL;
+	u16 FORCE_INT_PHY_FATAL;
+	u16 INT_PKT_FATAL;
+	u16 MASK_INT_PKT_FATAL;
+	u16 FORCE_INT_PKT_FATAL;
+	u16 INT_FRAME_FATAL;
+	u16 MASK_INT_FRAME_FATAL;
+	u16 FORCE_INT_FRAME_FATAL;
+	u16 INT_PHY;
+	u16 MASK_INT_PHY;
+	u16 FORCE_INT_PHY;
+	u16 INT_PKT;
+	u16 MASK_INT_PKT;
+	u16 FORCE_INT_PKT;
+	u16 INT_LINE;
+	u16 MASK_INT_LINE;
+	u16 FORCE_INT_LINE;
+	u16 INT_IPI;
+	u16 MASK_INT_IPI;
+	u16 FORCE_INT_IPI;
+	u16 ST_BNDRY_FRAME_FATAL;
+	u16 MSK_BNDRY_FRAME_FATAL;
+	u16 FORCE_BNDRY_FRAME_FATAL;
+	u16 ST_SEQ_FRAME_FATAL;
+	u16 MSK_SEQ_FRAME_FATAL;
+	u16 FORCE_SEQ_FRAME_FATAL;
+	u16 ST_CRC_FRAME_FATAL;
+	u16 MSK_CRC_FRAME_FATAL;
+	u16 FORCE_CRC_FRAME_FATAL;
+	u16 ST_PLD_CRC_FATAL;
+	u16 MSK_PLD_CRC_FATAL;
+	u16 FORCE_PLD_CRC_FATAL;
+	u16 ST_DATA_ID;
+	u16 MSK_DATA_ID;
+	u16 FORCE_DATA_ID;
+	u16 ST_ECC_CORRECT;
+	u16 MSK_ECC_CORRECT;
+	u16 FORCE_ECC_CORRECT;
+};
+
+/* Interrupt Masks */
+struct interrupt_type {
+	u32 PHY_FATAL;
+	u32 PKT_FATAL;
+	u32 FRAME_FATAL;
+	u32 PHY;
+	u32 PKT;
+	u32 LINE;
+	u32 IPI;
+	u32 BNDRY_FRAME_FATAL;
+	u32 SEQ_FRAME_FATAL;
+	u32 CRC_FRAME_FATAL;
+	u32 PLD_CRC_FATAL;
+	u32 DATA_ID;
+	u32 ECC_CORRECTED;
+};
+
+/* IPI Data Types */
+enum data_type {
+	CSI_2_YUV420_8 = 0x18,
+	CSI_2_YUV420_10 = 0x19,
+	CSI_2_YUV420_8_LEG = 0x1A,
+	CSI_2_YUV420_8_SHIFT = 0x1C,
+	CSI_2_YUV420_10_SHIFT = 0x1D,
+	CSI_2_YUV422_8 = 0x1E,
+	CSI_2_YUV422_10 = 0x1F,
+	CSI_2_RGB444 = 0x20,
+	CSI_2_RGB555 = 0x21,
+	CSI_2_RGB565 = 0x22,
+	CSI_2_RGB666 = 0x23,
+	CSI_2_RGB888 = 0x24,
+	CSI_2_RAW6 = 0x28,
+	CSI_2_RAW7 = 0x29,
+	CSI_2_RAW8 = 0x2A,
+	CSI_2_RAW10 = 0x2B,
+	CSI_2_RAW12 = 0x2C,
+	CSI_2_RAW14 = 0x2D,
+	CSI_2_RAW16 = 0x2E,
+	CSI_2_RAW20 = 0x2F,
+	USER_DEFINED_1 = 0x30,
+	USER_DEFINED_2 = 0x31,
+	USER_DEFINED_3 = 0x32,
+	USER_DEFINED_4 = 0x33,
+	USER_DEFINED_5 = 0x34,
+	USER_DEFINED_6 = 0x35,
+	USER_DEFINED_7 = 0x36,
+	USER_DEFINED_8 = 0x37,
+};
+
+/* DWC MIPI CSI-2 output types */
+enum output {
+	IPI_OUT = 0,
+	IDI_OUT = 1,
+	BOTH_OUT = 2
+};
+
+/* IPI color components */
+enum color_mode {
+	COLOR48 = 0,
+	COLOR16 = 1
+};
+
+/* IPI cut through */
+enum cut_through {
+	CTINACTIVE = 0,
+	CTACTIVE = 1
+};
+
+/* IPI output types */
+enum ipi_output {
+	CAMERA_TIMING = 0,
+	AUTO_TIMING = 1
+};
+
+/* Format template */
+struct mipi_fmt {
+	u32 mbus_code;
+	u8 depth;
+};
+
+struct mipi_dt {
+	u32 hex;
+	char *name;
+};
+
+/* CSI specific configuration */
+struct csi_data {
+	u32 num_lanes;
+	u32 dphy_freq;
+	u32 pclk;
+	u32 fps;
+	u32 bpp;
+	u32 output;
+	u32 ipi_mode;
+	u32 ipi_adv_features;
+	u32 ipi_cut_through;
+	u32 ipi_color_mode;
+	u32 ipi_auto_flush;
+	u32 virtual_ch;
+	u32 hsa;
+	u32 hbp;
+	u32 hsd;
+	u32 htotal;
+	u32 vsa;
+	u32 vbp;
+	u32 vfp;
+	u32 vactive;
+};
+
+/* Structure to embed device driver information */
+struct dw_csi {
+	struct v4l2_subdev sd;
+	struct video_device vdev;
+	struct v4l2_device v4l2_dev;
+	struct device *dev;
+	struct clk *perclk, *phyclk;
+	struct media_pad pads[CSI_PADS_NUM];
+	struct mipi_fmt *fmt;
+	struct v4l2_mbus_framefmt format;
+	void __iomem *base_address;
+	void __iomem *demo;
+	void __iomem *csc;
+	int ctrl_irq_number;
+	int demosaic_irq;
+	struct csi_data hw;
+	struct reset_control *rst;
+	struct phy *phy;
+	struct dw_csih_pdata *config;
+	struct mutex lock; /* protect resources sharing */
+	spinlock_t slock; /* interrupt handling lock */
+	u8 ipi_dt;
+	u8 index;
+	u8 hw_version_major;
+	u16 hw_version_minor;
+
+	struct v4l2_async_notifier notifier;
+
+	u32 remote_pad;
+
+	struct v4l2_subdev *input_sd;
+};
+
+static inline struct dw_csi *sd_to_mipi_csi_dev(struct v4l2_subdev *sdev)
+{
+	return container_of(sdev, struct dw_csi, sd);
+}
+
+void dw_mipi_csi_reset(struct dw_csi *csi_dev);
+int dw_mipi_csi_mask_irq_power_off(struct dw_csi *csi_dev);
+int dw_mipi_csi_hw_stdby(struct dw_csi *csi_dev);
+void dw_mipi_csi_set_ipi_fmt(struct dw_csi *csi_dev);
+void dw_mipi_csi_start(struct dw_csi *csi_dev);
+int dw_mipi_csi_irq_handler(struct dw_csi *csi_dev);
+void dw_mipi_csi_get_version(struct dw_csi *csi_dev);
+int dw_mipi_csi_specific_mappings(struct dw_csi *csi_dev);
+void dw_mipi_csi_fill_timings(struct dw_csi *dev,
+			      struct v4l2_subdev_format *fmt);
+void dw_mipi_csi_dump(struct dw_csi *csi_dev);
+
+#if IS_ENABLED(CONFIG_DWC_MIPI_TC_DPHY_GEN3)
+int dw_csi_create_capabilities_sysfs(struct platform_device *pdev);
+#endif
+
+static inline void dw_mipi_csi_write(struct dw_csi *dev,
+				     u32 address, u32 data)
+{
+	writel(data, dev->base_address + address);
+}
+
+static inline u32 dw_mipi_csi_read(struct dw_csi *dev, u32 address)
+{
+	return readl(dev->base_address + address);
+}
+
+#endif /*_DW_MIPI_CSI_H__ */
--- linux-6.6.51/drivers/media/platform/microchip/Kconfig	2024-12-05 13:07:47.903600700 +0900
+++ linux4microchip-fpga-2024.09/drivers/media/platform/microchip/Kconfig	2024-12-04 16:41:28.063884000 +0900
@@ -59,3 +59,85 @@
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called microchip-csi2dc.
+
+config VIDEO_MCHP_DSCMI
+	tristate "Microchip Digital Serial Camera Memory Interface Driver"
+	depends on V4L_PLATFORM_DRIVERS
+	depends on VIDEO_DEV && OF
+	select VIDEOBUF2_DMA_CONTIG
+	select MEDIA_CONTROLLER
+	select VIDEO_V4L2_SUBDEV_API
+	select V4L2_FWNODE
+	help
+	  Microchip Digital Serial Camera Memory Interface Driver Support For Smart Embedded Vision Kit.
+
+config VIDEO_MICROCHIP_COMMON
+	tristate
+	default n
+	help
+	  Microchip common code base for FPAG Soft IP drivers.
+
+config VIDEO_MICROCHIP_GVPC
+	tristate "Microchip GVPC (Generic Video Pipeline Connector) Driver"
+	depends on VIDEO_DEV && OF
+	select CONFIG_VIDEO_V4L2_SUBDEV_API
+	select V4L2_FWNODE
+	select VIDEO_MICROCHIP_COMMON
+	help
+	  Microchip GVPC (Generic Video Pipeline Connector) Driver Support.
+
+config VIDEO_MICROCHIP_IMAGE_ENHANCEMENT
+        tristate "Microchip Video image enhancement"
+	depends on VIDEO_DEV && OF
+	select CONFIG_VIDEO_V4L2_SUBDEV_API
+	select V4L2_FWNODE
+	select VIDEO_MICROCHIP_COMMON
+        help
+          Driver for the Microchip Video image enhancement
+
+config VIDEO_MICROCHIP_MIPI_CSI2
+	tristate "Microchip MIPI CSI2 Driver"
+	depends on VIDEO_DEV && OF
+	select CONFIG_VIDEO_V4L2_SUBDEV_API
+	select V4L2_FWNODE
+	select VIDEO_MICROCHIP_COMMON
+	help
+	  Microchip MIPI CSI2 FPGA Soft IP Driver Support.
+
+config VIDEO_MICROCHIP_OSD
+        tristate "Microchip Video On Screen Display"
+	depends on VIDEO_DEV && OF
+	select CONFIG_VIDEO_V4L2_SUBDEV_API
+	select V4L2_FWNODE
+	select VIDEO_MICROCHIP_COMMON
+        help
+          Driver for the Microchip Video OSD (On Screen Display)
+
+config VIDEO_MICROCHIP_RGB_SCALER
+        tristate "Microchip Video RGB Scaler"
+	depends on VIDEO_DEV && OF
+	select CONFIG_VIDEO_V4L2_SUBDEV_API
+	select V4L2_FWNODE
+	select VIDEO_MICROCHIP_COMMON
+        help
+          Driver for the Microchip Video RGB Scaler
+
+config VIDEO_MICROCHIP_VIDEO_CAPTURE
+	tristate "Microchip Video Capture Driver"
+	depends on VIDEO_DEV && OF
+	select CONFIG_VIDEO_V4L2_SUBDEV_API
+	select VIDEOBUF2_DMA_CONTIG
+	select V4L2_FWNODE
+	select VIDEO_MICROCHIP_COMMON
+	help
+	  Microchip Video Capture Driver Support For FPGA Soft IP.
+
+config VIDEO_MICROCHIP_YUV2H264
+	tristate "Microchip Video H264 Encoder Driver"
+	depends on VIDEO_DEV && OF
+	select CONFIG_VIDEO_V4L2_SUBDEV_API
+	select V4L2_FWNODE
+	select VIDEO_MICROCHIP_COMMON
+	help
+	  Microchip Video H264 Encoder Driver Support.
+
--- linux-6.6.51/drivers/media/platform/microchip/Makefile	2024-12-05 13:07:47.904598600 +0900
+++ linux4microchip-fpga-2024.09/drivers/media/platform/microchip/Makefile	2024-12-04 16:41:28.063884000 +0900
@@ -7,3 +7,12 @@
 obj-$(CONFIG_VIDEO_MICROCHIP_ISC) += microchip-isc.o
 obj-$(CONFIG_VIDEO_MICROCHIP_XISC) += microchip-xisc.o
 obj-$(CONFIG_VIDEO_MICROCHIP_CSI2DC) += microchip-csi2dc.o
+obj-$(CONFIG_VIDEO_MCHP_DSCMI) += mchp-dscmi.o
+obj-$(CONFIG_VIDEO_MICROCHIP_COMMON) += microchip-common.o
+obj-$(CONFIG_VIDEO_MICROCHIP_GVPC) += microchip-gvpc.o
+obj-$(CONFIG_VIDEO_MICROCHIP_IMAGE_ENHANCEMENT) += microchip-image-enhancement.o
+obj-$(CONFIG_VIDEO_MICROCHIP_MIPI_CSI2) += microchip-mipi-csi2rx.o
+obj-$(CONFIG_VIDEO_MICROCHIP_OSD) += microchip-osd.o
+obj-$(CONFIG_VIDEO_MICROCHIP_RGB_SCALER) += microchip-rgb-scaler.o
+obj-$(CONFIG_VIDEO_MICROCHIP_VIDEO_CAPTURE) += microchip-vcpp.o
+obj-$(CONFIG_VIDEO_MICROCHIP_YUV2H264) += microchip-yuv2h264.o
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/microchip/mchp-dscmi.c	2024-12-04 16:41:28.064881300 +0900
@@ -0,0 +1,1765 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Microchip Digital Serial Camera Memory Interface Driver.
+ *
+ * Copyright (C) 2021-2022 Microchip Technology Inc. and its subsidiaries
+ * Author: Shravan Chippa <shavan.chippa@microchip.com>
+ *
+ * Driver based on stm32-dcmi.c
+ */
+
+#include <linux/bitfield.h>
+#include <linux/delay.h>
+#include <linux/dmaengine.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kmod.h>
+#include <linux/mutex.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/videodev2.h>
+#include <linux/of_device.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/videobuf2-v4l2.h>
+#include <media/videobuf2-dma-contig.h>
+
+#define MCHP_DSCMI_DRV_NAME			"mchp-dscmi"
+#define MCHP_DSCMI_DRV_VERSION			"0.1"
+
+/* Offset address to control Red, Green, Blue gain etc */
+#define MCHP_DSCMI_R_CONSTRAINT			0x1004
+#define MCHP_DSCMI_G_CONSTRAINT			0x1008
+#define MCHP_DSCMI_B_CONSTRAINT			0x100C
+#define MCHP_DSCMI_SECOND_CONSTRAINT		0x1010
+#define MCHP_DSCMI_RGB_SUM			0x1038
+
+/* Offset address to control space */
+#define MCHP_DSCMI_FRAME_Q_FACTOR		0x1074
+#define MCHP_DSCMI_FRAME_WIDTH			0x1078
+#define MCHP_DSCMI_FRAME_HIGHT			0x107C
+#define MCHP_DSCMI_FRAME_SIZE_REG		0x1080
+#define MCHP_DSCMI_FRAME_START_REG		0x1084
+#define MCHP_DSCMI_STREAM_ADDR_LOW		0x1088
+#define MCHP_DSCMI_STREAM_ADDR_HIGH		0x108C
+#define MCHP_DSCMI_H264_RATIO			0x1108
+#define MCHP_DSCMI_R_FRAME_WIDTH		0x110C
+#define MCHP_DSCMI_R_FRAME_HIGHT		0x1110
+#define MCHP_DSCMI_OSD_X_Y_POS			0x1100
+#define MCHP_DSCMI_OSD_COLOR			0x1104
+#define MCHP_DSCMI_OSD_EN			0x1114
+
+/* Offset address to get video capability */
+#define MCHP_DSCMI_CAPABILITIES_V4L2		0x1500
+
+#define MCHP_DSCMI_FRAME_START			0x1
+#define MCHP_DSCMI_FRAME_STOP			0x0
+
+#define MCHP_DSCMI_H264_NUM_CTRLS		11
+#define MCHP_DSCMI_NUM_CTRLS			7
+
+#define MCHP_DSCMI_CAM_POWER_ON			1
+#define MCHP_DSCMI_CAM_POWER_OFF		0
+
+#define MCHP_DSCMI_CAM_START			1
+#define MCHP_DSCMI_CAM_STOP			0
+
+#define MCHP_DSCMI_FRAME_SIZE_MASK		GENMASK(27, 0)
+#define MCHP_DSCMI_FRAME_INDEX_MASK		GENMASK(29, 28)
+
+#define MCHP_DSCMI_MAX_FRAMES			4
+#define MCHP_DSCMI_FRAME_S_NEXT			(1024 * 1024)
+#define MCHP_DSCMI_FRAME_MAX_SIZE		(1024 * 1024)
+
+/* Video capabilities */
+#define MCHP_DSCMI_CAPABILITIES_H264		0x48323634
+#define MCHP_DSCMI_CAPABILITIES_MJPEG		0x4D4A5047
+#define MCHP_DSCMI_CAPABILITIES_YUV		0x59555956
+
+/* User defined v4l2 control */
+#define MCHP_DSCMI_CID_RED_GAIN			(V4L2_CID_USER_BASE | 0x1001)
+#define MCHP_DSCMI_CID_GREEN_GAIN		(V4L2_CID_USER_BASE | 0x1002)
+#define MCHP_DSCMI_CID_BLUE_GAIN		(V4L2_CID_USER_BASE | 0x1003)
+#define MCHP_DSCMI_CID_Q_FACTOR			(V4L2_CID_USER_BASE | 0x1004)
+#define MCHP_DSCMI_CID_OSD_X_POS		(V4L2_CID_USER_BASE | 0x1005)
+#define MCHP_DSCMI_CID_OSD_Y_POS		(V4L2_CID_USER_BASE | 0x1006)
+#define MCHP_DSCMI_CID_OSD_ENABLE		(V4L2_CID_USER_BASE | 0x1007)
+#define MCHP_DSCMI_CID_OSD_COLOR		(V4L2_CID_USER_BASE | 0x1008)
+
+/* Default resolution */
+#define MCHP_DSCMI_FIXED_WIDTH			1280
+#define MCHP_DSCMI_FIXED_HEIGHT			720
+
+#define MCHP_DSCMI_MAX_WIDTH			1920
+#define MCHP_DSCMI_MAX_HEIGHT			1080
+
+#define MCHP_DSCMI_GAIN_AVERAGE			125
+#define MCHP_DSCMI_GAIN_MIN			5
+#define MCHP_DSCMI_GAIN_INIT			80
+#define MCHP_DSCMI_HYSTERESIS_GAIN		4
+#define MCHP_DSCMI_GAIN_CTL_DEFAULT		112
+#define MCHP_DSCMI_GAIN_CTL_MAX			255
+#define MCHP_DSCMI_CTL_MAX			255
+#define MCHP_DSCMI_CTL_MIN			0
+#define MCHP_DSCMI_CTL_STEP			1
+#define MCHP_DSCMI_Q_FACTOR_CTL_MAX		52
+#define MCHP_DSCMI_Q_FACTOR_CTL_MIN		25
+#define MCHP_DSCMI_Q_FACTOR_CTL_DEFAULT		30
+
+/* Text overlay (On Screen Display) */
+#define MCHP_DSCMI_OSD_X_Y_POS_MAX		4096
+#define MCHP_DSCMI_OSD_X_Y_POS_MIN		4
+#define MCHP_DSCMI_OSD_X_Y_POS_DEFAULT		4
+#define MCHP_DSCMI_OSD_X_Y_POS_STEP		2
+#define MCHP_DSCMI_OSD_ENABLE_MAX		1
+#define MCHP_DSCMI_OSD_ENABLE_MIN		0
+#define MCHP_DSCMI_OSD_ENABLE_DEFAULT		1
+#define MCHP_DSCMI_OSD_ENABLE_STEP		1
+#define MCHP_DSCMI_OSD_DISABLE_MAX_PIX		0x2000
+#define MCHP_DSCMI_OSD_X_POS_SHIFT		16
+#define MCHP_DSCMI_OSD_COLOR_MAX		0xFFFFFF
+#define MCHP_DSCMI_OSD_COLOR_MIN		0x000000
+#define MCHP_DSCMI_OSD_COLOR_DEFAULT		0xFFFFFF
+#define MCHP_DSCMI_OSD_COLOR_STEP		1
+
+/* The compression ratio is calculated for every 60 frames */
+#define MCHP_DSCMI_OSD_MAX_FRAMES_RESET_COUNT	60
+#define MCHP_DSCMI_OSD_MAX_FRAMES_INIT		50
+#define MCHP_DSCMI_OSD_MAX_ARRAY		6
+
+/* Auto gain check delay in msecs*/
+#define MCHP_DSCMI_DELAYED_WORK_TIME_M_SEC	150
+
+/* Minimum wait time for camera to stabilize */
+#define MCHP_DSCMI_DELAYED_CAM_M_SEC		100
+
+#define MCHP_DSCMI_OSD_EN_FPGA_RTL		BIT(0)
+
+enum mchp_dscmi_state {
+	STOPPED = 0,
+	WAIT_FOR_BUFFER,
+	RUNNING,
+};
+
+enum mchp_dscmi_capabilities {
+	H264 = 0,
+	MJPEG,
+	YUV_RAW,
+};
+
+/**
+ * struct mchp_dscmi_framesize - size of the frame
+ * @width:	frame width
+ * @height:	frame height
+ */
+struct mchp_dscmi_framesize {
+	u32 width;
+	u32 height;
+};
+
+struct mchp_dscmi_driver_platdata {
+	u32 quirks;
+};
+
+/**
+ * struct mchp_dscmi_compression_ratio - for compression calculation
+ * @frame_size:		accumulated frames size
+ * @frame_size_index:	accumulated present frames size index
+ * @frame_count:	present frame count
+ */
+struct mchp_dscmi_compression_ratio {
+	u32 frame_size[MCHP_DSCMI_OSD_MAX_ARRAY];
+	u32 frame_size_index;
+	u32 frame_count;
+};
+
+/**
+ * struct mchp_dscmi_buffer - buffer for one video frame
+ * @vb:		video buffer information struct vb2_v4l2_buffer
+ * @prepared:	status of buffer
+ * @paddr:	physical address of buffer
+ * @size:	size of buffer
+ * @list:	list of all requested buffers from user space
+ */
+struct mchp_dscmi_buffer {
+	struct vb2_v4l2_buffer vb;
+	bool prepared;
+	dma_addr_t paddr;
+	size_t size;
+	struct list_head list;
+};
+
+/**
+ * struct mchp_dscmi_cam_buffer - camera dma buffers and size
+ * @paddr:	camera stream base address
+ * @size:	size of buffer
+ */
+struct mchp_dscmi_cam_buffer {
+	dma_addr_t paddr;
+	size_t size;
+};
+
+/**
+ * struct mchp_dscmi_format - media bus format information
+ * @fourcc:	Fourcc code for this format
+ * @mbus_code:	V4L2 media bus format code
+ * @bpp:	Bytes per pixel (when stored in memory)
+ */
+struct mchp_dscmi_format {
+	u32 fourcc;
+	u32 mbus_code;
+	u8 bpp;
+};
+
+/**
+ * struct mchp_dscmi_fpga - V4L2 device context
+ * @base:		pointer to control register
+ * @pdev:		platform device
+ * @dev:		device
+ * @active:		current buffer in queue
+ * @current_subdev:	current subdevice: the camera sensor
+ * @reset_gpio:		sensor fabric rest
+ * @dma_chan:		DMA engine channel
+ * @auto_gain_wq:	auto gain control work queue struct
+ * @auto_gain_dw:	auto gain delayed work struct
+ * @v4l2_dev:		top-level v4l2 device struct
+ * @vdev:		video node structure
+ * @fmt:		current v4l2 format
+ * @queue:		vb2 video capture queue
+ * @lock:		mutex lock for vb2 buffs
+ * @qlock:		spinlock controlling access to buf_list and sequence
+ * @buf_list:		list of buffers queued for DMA
+ * @subdev_entities:	subdevice list
+ * @ctrl_handler:	control handler structure
+ * @dma_cookie:		DMA engine cookie
+ * @dma_lock:		DMA mutex lock for serializing dma use
+ * @cambuf:		struct cam_buffer
+ * @h264_ratio:		struct compression_ratio
+ * @state:		state of buffers
+ * @capabilities:	capabilities to identify the fabric v4l2 support
+ * @s_buff_index:	current streaming buf index
+ * @s_buff_size:	current streaming buf size
+ * @irq:		external IRQ for new frame
+ * @contrast:		contrast value
+ * @brightness:		brightness value
+ * @sequence:		frame sequence counter
+ * @drop_count:		total frame drop counter
+ * @horizontal_pos:	overlay horizontal position
+ * @vertical_pos:	overlay vertical position
+ * @has_hw_osd_enable:	osd enable feture status
+ */
+struct mchp_dscmi_fpga {
+	void __iomem *base;
+	struct platform_device *pdev;
+	struct device *dev;
+	struct mchp_dscmi_buffer *active;
+	struct mchp_dscmi_subdev_entity *current_subdev;
+	struct gpio_desc *reset_gpio;
+	struct dma_chan	 *dma_chan;
+	struct workqueue_struct	*auto_gain_wq;
+	struct delayed_work auto_gain_dw;
+	struct v4l2_device v4l2_dev;
+	struct video_device vdev;
+	struct v4l2_format fmt;
+	struct vb2_queue queue;
+	struct mutex lock; /* vb2 buffer lock */
+	spinlock_t qlock;
+	struct list_head buf_list;
+	struct list_head subdev_entities;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct mutex dma_lock; /* mutex for dma operations */
+	struct mchp_dscmi_cam_buffer cambuf;
+	struct mchp_dscmi_compression_ratio h264_ratio;
+	enum mchp_dscmi_state state;
+	enum mchp_dscmi_capabilities capabilities;
+	dma_cookie_t dma_cookie;
+	int s_buff_index;
+	int s_buff_size;
+	int irq;
+	int contrast;
+	int brightness;
+	int sequence;
+	int drop_count;
+	int horizontal_pos;
+	int vertical_pos;
+	bool has_hw_osd_enable;
+};
+
+struct mchp_dscmi_subdev_entity {
+	struct v4l2_subdev *subdev;
+	struct v4l2_async_connection *asc;
+	struct device_node *epn;
+	struct v4l2_async_notifier notifier;
+	struct list_head list;
+};
+
+static struct mchp_dscmi_framesize framesize_list[] = {
+	{
+		.width = 1920,
+		.height = 1072,
+	},
+	{
+		.width = 1280,
+		.height = 720,
+	},
+	{
+		.width = 960,
+		.height = 544,
+	},
+	{
+		.width = 640,
+		.height = 480,
+	},
+	{
+		.width = 432,
+		.height = 240,
+	},
+	{},
+};
+
+static struct mchp_dscmi_format mchp_dscmi_formats[] = {
+	{
+		.fourcc = V4L2_PIX_FMT_H264,
+		.mbus_code = MEDIA_BUS_FMT_SRGGB10_1X10,
+	}, {
+		.fourcc	= V4L2_PIX_FMT_MJPEG,
+		.mbus_code = MEDIA_BUS_FMT_SRGGB10_1X10,
+	}, {
+		.fourcc = V4L2_PIX_FMT_YUYV,
+		.mbus_code = MEDIA_BUS_FMT_SRGGB10_1X10,
+		.bpp = 2,
+	},
+};
+
+static inline void mchp_dscmi_reg_write(struct mchp_dscmi_fpga *mchp_dscmi,
+					u32 reg, u32 val)
+{
+	writel_relaxed(val, mchp_dscmi->base + reg);
+}
+
+static inline u32 mchp_dscmi_reg_read(struct mchp_dscmi_fpga *mchp_dscmi,
+				      u32 reg)
+{
+	return readl_relaxed(mchp_dscmi->base + reg);
+}
+
+/*
+ * Compression ratio is the percentage of compressed image over the actual image.
+ * The YUV420 requires 3 bytes per 2 pixels, or 1.5 bytes per pixel, because
+ * groups of pixels share a single color value.
+ * The compression ratio can be calculated as:
+ * (width * height * accumulated-frame-count * bytes-per-pixel) / accumulated-frame-size
+ */
+static u32 compression_ratio_calc(u32 hres, u32 vres, u32 accumulated_frame_size)
+{
+	return ((hres * vres * MCHP_DSCMI_OSD_MAX_FRAMES_RESET_COUNT * 3) /
+		(accumulated_frame_size)) / 2;
+}
+
+/*
+ * The compression ratio is calculated by the driver, but overlaid by
+ * the FPGA logic. It is displayed as a percentage, with the 4 least
+ * significant bits of MCHP_DSCMI_H264_RATIO containing the units,
+ * bits 4 to 7 containing the tens etc to be displayed.
+ */
+
+static void mchp_dscmi_osd_text(struct mchp_dscmi_fpga *mchp_dscmi,
+				u32 compression_ratio)
+{
+	u32 compression_ratio_osd = ((compression_ratio % 10) |
+				    ((compression_ratio / 10 % 10) << 4) |
+				    ((compression_ratio / 100) << 8));
+
+	mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_H264_RATIO, compression_ratio_osd);
+}
+
+static void mchp_dscmi_buffer_done(struct mchp_dscmi_fpga *mchp_dscmi,
+				   struct mchp_dscmi_buffer *buf,
+				   size_t bytesused,
+				   int err)
+{
+	struct vb2_v4l2_buffer *vbuf;
+
+	if (!buf)
+		return;
+
+	list_del_init(&buf->list);
+	vbuf = &buf->vb;
+	vbuf->sequence = mchp_dscmi->sequence++;
+	vbuf->field = V4L2_FIELD_NONE;
+	vbuf->vb2_buf.timestamp = ktime_get_ns();
+
+	vb2_set_plane_payload(&vbuf->vb2_buf, 0, bytesused);
+
+	vb2_buffer_done(&vbuf->vb2_buf,
+			err ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);
+
+	dev_dbg(mchp_dscmi->dev, "Buffer[%d] done seq=%d, bytesused=%zu\n",
+		vbuf->vb2_buf.index, vbuf->sequence, bytesused);
+
+	mchp_dscmi->active = NULL;
+}
+
+static void mchp_dscmi_dma_callback(void *param)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi = param;
+	struct mchp_dscmi_buffer *buf = mchp_dscmi->active;
+	struct dma_tx_state state;
+	enum dma_status status;
+
+	spin_lock_irq(&mchp_dscmi->qlock);
+
+	status = dmaengine_tx_status(mchp_dscmi->dma_chan,
+				     mchp_dscmi->dma_cookie, &state);
+
+	switch (status) {
+	case DMA_ERROR:
+		dev_err(mchp_dscmi->dev, "Received DMA_ERROR\n");
+		mchp_dscmi_buffer_done(mchp_dscmi, buf, 0, -EIO);
+		break;
+	case DMA_COMPLETE:
+		dev_dbg(mchp_dscmi->dev, "Received DMA_COMPLETE\n");
+		mchp_dscmi_buffer_done(mchp_dscmi, buf,
+				       mchp_dscmi->s_buff_size, 0);
+		break;
+
+	default:
+		dev_err(mchp_dscmi->dev, "Received unknown status\n");
+		break;
+	}
+
+	spin_unlock_irq(&mchp_dscmi->qlock);
+}
+
+static int mchp_dscmi_start_dma(struct mchp_dscmi_fpga *mchp_dscmi,
+				struct mchp_dscmi_buffer *buf)
+{
+	struct dma_async_tx_descriptor *desc = NULL;
+	struct dma_slave_config config;
+	struct mchp_dscmi_compression_ratio *h264_ratio = &mchp_dscmi->h264_ratio;
+	int ret, buf_size, i;
+	int *frame_size_index = &h264_ratio->frame_size_index;
+
+	memset(&config, 0, sizeof(config));
+
+	spin_lock_irq(&mchp_dscmi->qlock);
+	config.src_addr = mchp_dscmi->cambuf.paddr +
+		(MCHP_DSCMI_FRAME_S_NEXT * mchp_dscmi->s_buff_index);
+
+	buf_size = mchp_dscmi->s_buff_size;
+	spin_unlock_irq(&mchp_dscmi->qlock);
+
+	h264_ratio->frame_count++;
+	h264_ratio->frame_size[*frame_size_index] += buf_size;
+
+	if (h264_ratio->frame_count % 10 == 0)
+		(*frame_size_index)++;
+
+	if (*frame_size_index == MCHP_DSCMI_OSD_MAX_ARRAY)
+		*frame_size_index = 0;
+
+	if (h264_ratio->frame_count == MCHP_DSCMI_OSD_MAX_FRAMES_RESET_COUNT) {
+		u32 accumulated_frame_size = 0, compression_ratio, hres, vres;
+
+		for (i = 0; i < MCHP_DSCMI_OSD_MAX_ARRAY; i++)
+			accumulated_frame_size += h264_ratio->frame_size[i];
+
+		hres = mchp_dscmi_reg_read(mchp_dscmi, MCHP_DSCMI_R_FRAME_WIDTH);
+		vres = mchp_dscmi_reg_read(mchp_dscmi, MCHP_DSCMI_R_FRAME_HIGHT);
+
+		compression_ratio = compression_ratio_calc(hres, vres,
+							   accumulated_frame_size);
+
+		mchp_dscmi_osd_text(mchp_dscmi, compression_ratio);
+
+		h264_ratio->frame_count = MCHP_DSCMI_OSD_MAX_FRAMES_INIT;
+		h264_ratio->frame_size[*frame_size_index] = 0;
+	}
+
+	config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	config.dst_maxburst = 4;
+
+	ret = dmaengine_slave_config(mchp_dscmi->dma_chan, &config);
+	if (ret) {
+		dev_err(mchp_dscmi->dev,
+			"DMA channel config failed (%d)\n", ret);
+		return ret;
+	}
+
+	mutex_lock(&mchp_dscmi->dma_lock);
+
+	desc = dmaengine_prep_dma_memcpy(mchp_dscmi->dma_chan, buf->paddr,
+					 config.src_addr, buf_size,
+					 DMA_CTRL_ACK | DMA_PREP_INTERRUPT);
+	if (!desc) {
+		dev_err(mchp_dscmi->dev,
+			"DMA failed for buffer src=%pad dst=%pad size=%d\n",
+			 &config.src_addr, &buf->paddr, buf_size);
+		mutex_unlock(&mchp_dscmi->dma_lock);
+		return -EINVAL;
+	}
+
+	desc->callback = mchp_dscmi_dma_callback;
+	desc->callback_param = mchp_dscmi;
+
+	mchp_dscmi->dma_cookie = dmaengine_submit(desc);
+
+	ret = dma_submit_error(mchp_dscmi->dma_cookie);
+	mutex_unlock(&mchp_dscmi->dma_lock);
+	if (ret) {
+		dev_err(mchp_dscmi->dev, "DMA submission failed %d\n", ret);
+		return -ENXIO;
+	}
+
+	dma_async_issue_pending(mchp_dscmi->dma_chan);
+
+	return 0;
+}
+
+static int mchp_dscmi_restart_capture(struct mchp_dscmi_fpga *mchp_dscmi)
+{
+	struct mchp_dscmi_buffer *buf;
+
+	spin_lock_irq(&mchp_dscmi->qlock);
+
+	if (list_empty(&mchp_dscmi->buf_list)) {
+		dev_dbg(mchp_dscmi->dev,
+			"Capture restart is deferred to next buffer queue\n");
+		mchp_dscmi->state = WAIT_FOR_BUFFER;
+		mchp_dscmi->drop_count++;
+		spin_unlock_irq(&mchp_dscmi->qlock);
+		return 0;
+	}
+
+	buf = list_entry(mchp_dscmi->buf_list.next,
+			 struct mchp_dscmi_buffer, list);
+
+	mchp_dscmi->active = buf;
+
+	spin_unlock_irq(&mchp_dscmi->qlock);
+
+	return mchp_dscmi_start_dma(mchp_dscmi, buf);
+}
+
+static irqreturn_t mchp_dscmi_irq_ext(int irq, void *dev_id)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi = dev_id;
+	int frame_info;
+	unsigned long flags;
+
+	frame_info = mchp_dscmi_reg_read(mchp_dscmi, MCHP_DSCMI_FRAME_SIZE_REG);
+
+	spin_lock_irqsave(&mchp_dscmi->qlock, flags);
+
+	if (mchp_dscmi->state != RUNNING) {
+		spin_unlock_irqrestore(&mchp_dscmi->qlock, flags);
+		mchp_dscmi->drop_count++;
+		return IRQ_HANDLED;
+	}
+
+	mchp_dscmi->s_buff_index = FIELD_GET(MCHP_DSCMI_FRAME_INDEX_MASK, frame_info);
+
+	mchp_dscmi->s_buff_size = frame_info & MCHP_DSCMI_FRAME_SIZE_MASK;
+
+	if (mchp_dscmi->s_buff_size >= MCHP_DSCMI_FRAME_S_NEXT ||
+	    mchp_dscmi->s_buff_size == 0) {
+		spin_unlock_irqrestore(&mchp_dscmi->qlock, flags);
+		mchp_dscmi->drop_count++;
+		return IRQ_HANDLED;
+	}
+
+	spin_unlock_irqrestore(&mchp_dscmi->qlock, flags);
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t mchp_dscmi_irq_thread_fn(int irq, void *dev_id)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi = dev_id;
+	int ret;
+
+	ret = mchp_dscmi_restart_capture(mchp_dscmi);
+	if (ret)
+		dev_warn_once(mchp_dscmi->dev,
+			      "failed to mchp restart capture %d\n", ret);
+
+	return IRQ_HANDLED;
+}
+
+static int mchp_dscmi_queue_setup(struct vb2_queue *vq,
+				  unsigned int *nbuffers, unsigned int *nplanes,
+				  unsigned int sizes[], struct device *alloc_devs[])
+{
+	struct mchp_dscmi_fpga *mchp_dscmi = vb2_get_drv_priv(vq);
+	unsigned int size;
+
+	if (*nbuffers > MCHP_DSCMI_MAX_FRAMES) {
+		dev_dbg(mchp_dscmi->dev,
+			"output frame count too high (%d), cut to %d\n",
+				 *nbuffers, MCHP_DSCMI_MAX_FRAMES);
+		*nbuffers = MCHP_DSCMI_MAX_FRAMES;
+	}
+
+	size = mchp_dscmi->fmt.fmt.pix.sizeimage;
+
+	if (*nplanes)
+		return sizes[0] < size ? -EINVAL : 0;
+
+	*nplanes = 1;
+	sizes[0] = size;
+
+	dev_dbg(mchp_dscmi->dev, "Setup queue, count=%d, size=%d\n",
+		*nbuffers, size);
+
+	return 0;
+}
+
+static int mchp_dscmi_buffer_prepare(struct vb2_buffer *vb)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi = vb2_get_drv_priv(vb->vb2_queue);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct mchp_dscmi_buffer *buf =
+			container_of(vbuf, struct mchp_dscmi_buffer, vb);
+	unsigned long size;
+
+	size = mchp_dscmi->fmt.fmt.pix.sizeimage;
+
+	if (vb2_plane_size(vb, 0) < size) {
+		dev_err(mchp_dscmi->dev,
+			"data will not fit into plane (%lu < %lu)\n",
+			vb2_plane_size(vb, 0), size);
+		return -EINVAL;
+	}
+
+	if (!buf->prepared) {
+		buf->paddr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
+		buf->size = vb2_plane_size(&buf->vb.vb2_buf, 0);
+		vb2_set_plane_payload(&buf->vb.vb2_buf, 0, buf->size);
+		buf->prepared = true;
+	}
+
+	return 0;
+}
+
+static void mchp_dscmi_buffer_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct mchp_dscmi_fpga *mchp_dscmi = vb2_get_drv_priv(vb->vb2_queue);
+	struct mchp_dscmi_buffer *buf =
+				container_of(vbuf, struct mchp_dscmi_buffer, vb);
+
+	spin_lock_irq(&mchp_dscmi->qlock);
+	list_add_tail(&buf->list, &mchp_dscmi->buf_list);
+
+	if (mchp_dscmi->state == WAIT_FOR_BUFFER) {
+		mchp_dscmi->state = RUNNING;
+		mchp_dscmi->active = buf;
+	}
+
+	spin_unlock_irq(&mchp_dscmi->qlock);
+}
+
+static void return_all_buffers(struct mchp_dscmi_fpga *mchp_dscmi,
+			       enum vb2_buffer_state state)
+{
+	struct mchp_dscmi_buffer *buf, *node;
+
+	list_for_each_entry_safe(buf, node, &mchp_dscmi->buf_list, list) {
+		vb2_buffer_done(&buf->vb.vb2_buf, state);
+		list_del(&buf->list);
+	}
+	mchp_dscmi->active = NULL;
+}
+
+static int mchp_dscmi_start_streaming(struct vb2_queue *vq, unsigned int count)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi = vb2_get_drv_priv(vq);
+	struct v4l2_subdev *subdev = mchp_dscmi->current_subdev->subdev;
+	struct mchp_dscmi_compression_ratio *h264_ratio = &mchp_dscmi->h264_ratio;
+	int ret;
+
+	v4l2_subdev_call(subdev, core, s_power, MCHP_DSCMI_CAM_POWER_ON);
+
+	ret = v4l2_subdev_call(subdev, video, s_stream, MCHP_DSCMI_CAM_START);
+	if (ret && ret != -ENOIOCTLCMD) {
+		dev_err(mchp_dscmi->dev,
+			"stream enable failed in subdev %d\n", ret);
+		goto err_free_buffers;
+	}
+
+	mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_FRAME_START_REG, MCHP_DSCMI_FRAME_STOP);
+	mdelay(MCHP_DSCMI_DELAYED_CAM_M_SEC);
+	mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_FRAME_START_REG,
+			     MCHP_DSCMI_FRAME_START);
+
+	mchp_dscmi->sequence = 0;
+	mchp_dscmi->drop_count = 0;
+	mchp_dscmi->s_buff_index = 0;
+	mchp_dscmi->s_buff_size = 0;
+
+	h264_ratio->frame_size_index = 0;
+	h264_ratio->frame_count = 0;
+
+	ret = request_threaded_irq(mchp_dscmi->irq, mchp_dscmi_irq_ext,
+				   mchp_dscmi_irq_thread_fn, IRQF_NO_SUSPEND,
+				   KBUILD_MODNAME, mchp_dscmi);
+
+	if (ret) {
+		dev_err(mchp_dscmi->dev, "request threaded irq failed %d\n",
+			ret);
+		goto err_free_buffers;
+	}
+
+	spin_lock_irq(&mchp_dscmi->qlock);
+
+	if (list_empty(&mchp_dscmi->buf_list)) {
+		dev_dbg(mchp_dscmi->dev,
+			"Start streaming is deferred to next buffer queue\n");
+		mchp_dscmi->state = WAIT_FOR_BUFFER;
+		spin_unlock_irq(&mchp_dscmi->qlock);
+		return 0;
+	}
+
+	mchp_dscmi->state = RUNNING;
+
+	spin_unlock_irq(&mchp_dscmi->qlock);
+
+	return 0;
+
+err_free_buffers:
+	spin_lock_irq(&mchp_dscmi->qlock);
+	return_all_buffers(mchp_dscmi, VB2_BUF_STATE_QUEUED);
+	spin_unlock_irq(&mchp_dscmi->qlock);
+	return ret;
+}
+
+static void mchp_dscmi_stop_streaming(struct vb2_queue *vq)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi = vb2_get_drv_priv(vq);
+	struct v4l2_subdev *subdev = mchp_dscmi->current_subdev->subdev;
+
+	free_irq(mchp_dscmi->irq, mchp_dscmi);
+
+	spin_lock_irq(&mchp_dscmi->qlock);
+
+	return_all_buffers(mchp_dscmi, VB2_BUF_STATE_QUEUED);
+
+	mchp_dscmi->active = NULL;
+	mchp_dscmi->state = STOPPED;
+
+	spin_unlock_irq(&mchp_dscmi->qlock);
+
+	mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_FRAME_START_REG, MCHP_DSCMI_FRAME_STOP);
+
+	v4l2_subdev_call(subdev, video, s_stream, MCHP_DSCMI_CAM_STOP);
+
+	v4l2_subdev_call(subdev, core, s_power, MCHP_DSCMI_CAM_POWER_OFF);
+
+	dev_dbg(mchp_dscmi->dev, "Capture frame count %d & drop count %d\n",
+		mchp_dscmi->sequence, mchp_dscmi->drop_count);
+}
+
+static const struct vb2_ops mchp_dscmi_qops = {
+	.queue_setup		= mchp_dscmi_queue_setup,
+	.buf_prepare		= mchp_dscmi_buffer_prepare,
+	.buf_queue		= mchp_dscmi_buffer_queue,
+	.start_streaming	= mchp_dscmi_start_streaming,
+	.stop_streaming		= mchp_dscmi_stop_streaming,
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
+};
+
+static int mchp_dscmi_querycap(struct file *file, void *priv,
+			       struct v4l2_capability *cap)
+{
+	strscpy(cap->driver, MCHP_DSCMI_DRV_NAME, sizeof(cap->driver));
+	strscpy(cap->card, "MCHP Camera Memory Interface", sizeof(cap->card));
+	strscpy(cap->bus_info, "platform: mchp-dscmi", sizeof(cap->bus_info));
+
+	return 0;
+}
+
+static int mchp_dscmi_try_fmt(struct mchp_dscmi_fpga *mchp_dscmi,
+			      struct v4l2_format *fmt)
+{
+	struct v4l2_pix_format *pix = &fmt->fmt.pix;
+	struct v4l2_pix_format *pix_present = &mchp_dscmi->fmt.fmt.pix;
+	struct v4l2_subdev *subdev = mchp_dscmi->current_subdev->subdev;
+	struct mchp_dscmi_framesize *framessize;
+	struct v4l2_subdev_format format = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+	};
+	int ret;
+
+	v4l2_fill_mbus_format(&format.format, pix,
+			      mchp_dscmi_formats[mchp_dscmi->capabilities].mbus_code);
+
+	format.format.width = MCHP_DSCMI_MAX_WIDTH;
+	format.format.height = MCHP_DSCMI_MAX_HEIGHT;
+
+	ret = v4l2_subdev_call(subdev, pad, set_fmt, NULL, &format);
+	if (ret < 0)
+		return ret;
+
+	framessize = v4l2_find_nearest_size(framesize_list,
+					    ARRAY_SIZE(framesize_list),
+					    width, height,
+					    pix->width, pix->height);
+
+	mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_FRAME_WIDTH, framessize->width);
+	mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_FRAME_HIGHT, framessize->height);
+
+	/* Driver supports only fixed format */
+	pix->pixelformat = mchp_dscmi_formats[mchp_dscmi->capabilities].fourcc;
+	pix->width = framessize->width;
+	pix->height = framessize->height;
+	pix->field = pix_present->field;
+	pix->colorspace = pix_present->colorspace;
+	pix->ycbcr_enc = pix_present->ycbcr_enc;
+	pix->quantization = pix_present->quantization;
+	pix->xfer_func = pix_present->xfer_func;
+	pix->sizeimage = pix_present->sizeimage;
+
+	return 0;
+}
+
+static int mchp_dscmi_try_fmt_vid_cap(struct file *file, void *priv,
+				      struct v4l2_format *fmt)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi = video_drvdata(file);
+
+	mchp_dscmi_try_fmt(mchp_dscmi, fmt);
+
+	return 0;
+}
+
+static int mchp_dscmi_s_fmt_vid_cap(struct file *file, void *priv,
+				    struct v4l2_format *fmt)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi = video_drvdata(file);
+
+	if (mchp_dscmi->capabilities == H264)
+		return mchp_dscmi_try_fmt_vid_cap(file, priv, fmt);
+
+	if (vb2_is_streaming(&mchp_dscmi->queue))
+		return -EBUSY;
+
+	return mchp_dscmi_try_fmt_vid_cap(file, priv, fmt);
+}
+
+static int mchp_dscmi_g_fmt_vid_cap(struct file *file, void *priv,
+				    struct v4l2_format *fmt)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi = video_drvdata(file);
+
+	*fmt = mchp_dscmi->fmt;
+
+	return 0;
+}
+
+static int mchp_dscmi_enum_fmt_vid_cap(struct file *file, void *priv,
+				       struct v4l2_fmtdesc *fmt)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi = video_drvdata(file);
+
+	if (fmt->index > 0)
+		return -EINVAL;
+
+	fmt->pixelformat = mchp_dscmi_formats[mchp_dscmi->capabilities].fourcc;
+	return 0;
+}
+
+static int mchp_dscmi_enum_input(struct file *file, void *priv,
+				 struct v4l2_input *input)
+{
+	if (input->index != 0)
+		return -EINVAL;
+
+	input->type = V4L2_INPUT_TYPE_CAMERA;
+	strscpy(input->name, "Camera", sizeof(input->name));
+	return 0;
+}
+
+static int mchp_dscmi_s_input(struct file *file, void *priv, unsigned int index)
+{
+	if (index > 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int mchp_dscmi_g_input(struct file *file, void *priv, unsigned int *index)
+{
+	*index = 0;
+	return 0;
+}
+
+static int mchp_dscmi_enum_framesizes(struct file *file, void *fh,
+				      struct v4l2_frmsizeenum *fsize)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi = video_drvdata(file);
+
+	if (fsize->index > 0)
+		return -EINVAL;
+
+	if (fsize->pixel_format !=
+			mchp_dscmi_formats[mchp_dscmi->capabilities].fourcc)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = MCHP_DSCMI_FIXED_WIDTH;
+	fsize->discrete.height = MCHP_DSCMI_FIXED_HEIGHT;
+
+	return 0;
+}
+
+static int mchp_dscmi_g_parm(struct file *file, void *priv,
+			     struct v4l2_streamparm *parm)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi = video_drvdata(file);
+	struct v4l2_subdev *subdev = mchp_dscmi->current_subdev->subdev;
+
+	return v4l2_g_parm_cap(video_devdata(file), subdev, parm);
+}
+
+static int mchp_dscmi_s_parm(struct file *file, void *priv,
+			     struct v4l2_streamparm *p)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi = video_drvdata(file);
+	struct v4l2_subdev *subdev = mchp_dscmi->current_subdev->subdev;
+
+	return v4l2_s_parm_cap(video_devdata(file), subdev, p);
+}
+
+static int mchp_dscmi_enum_frameintervals(struct file *file, void *fh,
+					  struct v4l2_frmivalenum *fival)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi = video_drvdata(file);
+	struct v4l2_subdev *subdev = mchp_dscmi->current_subdev->subdev;
+	struct v4l2_subdev_frame_interval_enum fie = {
+		.index = fival->index,
+		.width = fival->width,
+		.height = fival->height,
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+	};
+	int ret;
+
+	if (fival->pixel_format !=
+			mchp_dscmi_formats[mchp_dscmi->capabilities].fourcc)
+		return -EINVAL;
+
+	fie.code = mchp_dscmi_formats[mchp_dscmi->capabilities].mbus_code;
+
+	ret = v4l2_subdev_call(subdev, pad, enum_frame_interval, NULL, &fie);
+	if (ret)
+		return ret;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete = fie.interval;
+
+	return 0;
+}
+
+/*
+ * The calculated parameters are used by Image Enhancement IP UG0646 running
+ * in the FPGA logic. The equations used for calculation are explained in
+ * UG0646 page number 2 in the below link
+ *
+ * (https://ww1.microchip.com/downloads/aemDocuments/documents/FPGA/ProductDocuments/UserGuides/microsemi_image_enhancement_ip_user_guide_ug0646_v3.pdf)
+ *
+ * V4l2 controls like brightness, contrast, r_gain, g_gain and b_gain are
+ * calulated based on two functions second_constraint_cal() and
+ * contrast_scale_cal()
+ */
+
+static inline int second_constraint_cal(int brightness, int contrast_scale)
+{
+	return (128 * ((brightness) - ((128 * (contrast_scale)) / 10)));
+}
+
+static inline int contrast_scale_cal(int contrast)
+{
+	return ((325 * (contrast + 128) / (387 - contrast)) >> 5u);
+}
+
+/*
+ * x and y co-ordinates of the OSD, where x is lsb and y is msb
+ */
+
+static void update_osd_coordinates(struct mchp_dscmi_fpga *mchp_dscmi, bool enable)
+{
+	u32 val;
+
+	if (enable) {
+		val = mchp_dscmi->vertical_pos |
+				(mchp_dscmi->horizontal_pos << MCHP_DSCMI_OSD_X_POS_SHIFT);
+	} else {
+		val = MCHP_DSCMI_OSD_DISABLE_MAX_PIX;
+	}
+	mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_OSD_X_Y_POS, val);
+}
+
+static int mchp_dscmi_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi;
+	u32 contrast_scale, second_constraint, r_gain, g_gain, b_gain;
+
+	mchp_dscmi = container_of(ctrl->handler,
+				  struct mchp_dscmi_fpga, ctrl_handler);
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		mchp_dscmi->brightness = ctrl->val;
+		contrast_scale = contrast_scale_cal(mchp_dscmi->contrast);
+		second_constraint = second_constraint_cal(ctrl->val,
+							  contrast_scale);
+		mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_SECOND_CONSTRAINT,
+				     second_constraint);
+		break;
+	case V4L2_CID_CONTRAST:
+		mchp_dscmi->contrast = ctrl->val;
+		contrast_scale = contrast_scale_cal(ctrl->val);
+		second_constraint = second_constraint_cal(mchp_dscmi->brightness,
+							  contrast_scale);
+
+		mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_SECOND_CONSTRAINT,
+				     second_constraint);
+
+		break;
+	case MCHP_DSCMI_CID_RED_GAIN:
+		contrast_scale = contrast_scale_cal(mchp_dscmi->contrast);
+		r_gain = ((ctrl->val * contrast_scale) / 10);
+		mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_R_CONSTRAINT, r_gain);
+		break;
+	case MCHP_DSCMI_CID_GREEN_GAIN:
+		contrast_scale = contrast_scale_cal(mchp_dscmi->contrast);
+		g_gain = ((ctrl->val * contrast_scale) / 10);
+		mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_G_CONSTRAINT, g_gain);
+		break;
+	case MCHP_DSCMI_CID_BLUE_GAIN:
+		contrast_scale = contrast_scale_cal(mchp_dscmi->contrast);
+		b_gain = ((ctrl->val * contrast_scale) / 10);
+		mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_B_CONSTRAINT, b_gain);
+		break;
+	case V4L2_CID_GAIN:
+		contrast_scale = contrast_scale_cal(mchp_dscmi->contrast);
+		r_gain = ((ctrl->val * contrast_scale) / 10);
+		mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_R_CONSTRAINT, r_gain);
+		mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_G_CONSTRAINT, r_gain);
+		mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_B_CONSTRAINT, r_gain);
+		break;
+	case MCHP_DSCMI_CID_Q_FACTOR:
+		mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_FRAME_Q_FACTOR,
+				     ctrl->val);
+		break;
+	case MCHP_DSCMI_CID_OSD_X_POS:
+		mchp_dscmi->horizontal_pos = ctrl->val;
+		update_osd_coordinates(mchp_dscmi, true);
+		break;
+	case MCHP_DSCMI_CID_OSD_Y_POS:
+		mchp_dscmi->vertical_pos = ctrl->val;
+		update_osd_coordinates(mchp_dscmi, true);
+		break;
+	case MCHP_DSCMI_CID_OSD_ENABLE:
+		if (mchp_dscmi->has_hw_osd_enable)
+			mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_OSD_EN, ctrl->val);
+		else
+			update_osd_coordinates(mchp_dscmi, ctrl->val);
+		break;
+	case MCHP_DSCMI_CID_OSD_COLOR:
+		mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_OSD_COLOR, ctrl->val);
+		break;
+	case V4L2_CID_AUTOGAIN:
+		if (ctrl->val)
+			queue_delayed_work(mchp_dscmi->auto_gain_wq,
+					   &mchp_dscmi->auto_gain_dw,
+					   msecs_to_jiffies(MCHP_DSCMI_DELAYED_WORK_TIME_M_SEC));
+		else
+			cancel_delayed_work(&mchp_dscmi->auto_gain_dw);
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops mchp_dscmi_ctrl_ops = {
+	.s_ctrl = mchp_dscmi_s_ctrl,
+};
+
+static const struct v4l2_ioctl_ops mchp_dscmi_ioctl_ops = {
+	.vidioc_querycap = mchp_dscmi_querycap,
+	.vidioc_try_fmt_vid_cap = mchp_dscmi_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap = mchp_dscmi_s_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap = mchp_dscmi_g_fmt_vid_cap,
+	.vidioc_enum_fmt_vid_cap = mchp_dscmi_enum_fmt_vid_cap,
+
+	.vidioc_enum_input = mchp_dscmi_enum_input,
+	.vidioc_g_input = mchp_dscmi_g_input,
+	.vidioc_s_input = mchp_dscmi_s_input,
+
+	.vidioc_g_parm = mchp_dscmi_g_parm,
+	.vidioc_s_parm = mchp_dscmi_s_parm,
+	.vidioc_enum_framesizes = mchp_dscmi_enum_framesizes,
+	.vidioc_enum_frameintervals = mchp_dscmi_enum_frameintervals,
+
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+
+	.vidioc_log_status = v4l2_ctrl_log_status,
+	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+};
+
+static const struct v4l2_file_operations mchp_dscmi_fops = {
+	.owner		= THIS_MODULE,
+	.open		= v4l2_fh_open,
+	.release	= vb2_fop_release,
+	.read		= vb2_fop_read,
+	.mmap		= vb2_fop_mmap,
+	.poll		= vb2_fop_poll,
+	.unlocked_ioctl	= video_ioctl2,
+};
+
+static struct v4l2_format default_fmt[] = {
+	{
+		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
+		.fmt.pix = {
+			.width		= MCHP_DSCMI_FIXED_WIDTH,
+			.height		= MCHP_DSCMI_FIXED_HEIGHT,
+			.pixelformat	= V4L2_PIX_FMT_H264,
+			.bytesperline	= 0,
+			.sizeimage	= MCHP_DSCMI_FRAME_MAX_SIZE,
+			.field		= V4L2_FIELD_NONE,
+			.ycbcr_enc	= V4L2_YCBCR_ENC_DEFAULT,
+			.colorspace	= V4L2_COLORSPACE_RAW,
+			.xfer_func	= V4L2_XFER_FUNC_NONE,
+		},
+	}, {
+		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
+		.fmt.pix = {
+			.width		= MCHP_DSCMI_FIXED_WIDTH,
+			.height		= MCHP_DSCMI_FIXED_HEIGHT,
+			.pixelformat	= V4L2_PIX_FMT_MJPEG,
+			.bytesperline	= 0,
+			.sizeimage	= MCHP_DSCMI_FRAME_MAX_SIZE,
+			.field		= V4L2_FIELD_NONE,
+			.ycbcr_enc	= V4L2_YCBCR_ENC_DEFAULT,
+			.colorspace	= V4L2_COLORSPACE_RAW,
+			.xfer_func	= V4L2_XFER_FUNC_NONE,
+		},
+	},
+};
+
+static const struct v4l2_ctrl_config mchp_dscmi_gain_ctrls[] = {
+	{
+		.ops	= &mchp_dscmi_ctrl_ops,
+		.id	= MCHP_DSCMI_CID_RED_GAIN,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "Gain, Red",
+		.min	= MCHP_DSCMI_CTL_MIN,
+		.max	= MCHP_DSCMI_GAIN_CTL_MAX,
+		.def	= MCHP_DSCMI_GAIN_CTL_DEFAULT,
+		.step	= MCHP_DSCMI_CTL_STEP,
+	}, {
+		.ops	= &mchp_dscmi_ctrl_ops,
+		.id	= MCHP_DSCMI_CID_GREEN_GAIN,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "Gain, Green",
+		.min	= MCHP_DSCMI_CTL_MIN,
+		.max	= MCHP_DSCMI_GAIN_CTL_MAX,
+		.def	= MCHP_DSCMI_GAIN_CTL_DEFAULT,
+		.step	= MCHP_DSCMI_CTL_STEP,
+	}, {
+		.ops	= &mchp_dscmi_ctrl_ops,
+		.id	= MCHP_DSCMI_CID_BLUE_GAIN,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "Gain, Blue",
+		.min	= MCHP_DSCMI_CTL_MIN,
+		.max	= MCHP_DSCMI_GAIN_CTL_MAX,
+		.def	= MCHP_DSCMI_GAIN_CTL_DEFAULT,
+		.step	= MCHP_DSCMI_CTL_STEP,
+	}, {
+		.ops	= &mchp_dscmi_ctrl_ops,
+		.id	= MCHP_DSCMI_CID_Q_FACTOR,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "Quality Factor",
+		.min	= MCHP_DSCMI_Q_FACTOR_CTL_MIN,
+		.max	= MCHP_DSCMI_Q_FACTOR_CTL_MAX,
+		.def	= MCHP_DSCMI_Q_FACTOR_CTL_DEFAULT,
+		.step	= MCHP_DSCMI_CTL_STEP,
+	}, {
+		.ops	= &mchp_dscmi_ctrl_ops,
+		.id	= MCHP_DSCMI_CID_OSD_X_POS,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "OSDx Position",
+		.min	= MCHP_DSCMI_OSD_X_Y_POS_MIN,
+		.max	= MCHP_DSCMI_OSD_X_Y_POS_MAX,
+		.def	= MCHP_DSCMI_OSD_X_Y_POS_DEFAULT,
+		.step	= MCHP_DSCMI_OSD_X_Y_POS_STEP,
+	}, {
+		.ops	= &mchp_dscmi_ctrl_ops,
+		.id	= MCHP_DSCMI_CID_OSD_Y_POS,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "OSDy Position",
+		.min	= MCHP_DSCMI_OSD_X_Y_POS_MIN,
+		.max	= MCHP_DSCMI_OSD_X_Y_POS_MAX,
+		.def	= MCHP_DSCMI_OSD_X_Y_POS_DEFAULT,
+		.step	= MCHP_DSCMI_OSD_X_Y_POS_STEP,
+	}, {
+		.ops	= &mchp_dscmi_ctrl_ops,
+		.id	= MCHP_DSCMI_CID_OSD_ENABLE,
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.name	= "OSD enable",
+		.min	= MCHP_DSCMI_OSD_ENABLE_MIN,
+		.max	= MCHP_DSCMI_OSD_ENABLE_MAX,
+		.def	= MCHP_DSCMI_OSD_ENABLE_DEFAULT,
+		.step	= MCHP_DSCMI_OSD_ENABLE_STEP,
+	}, {
+		.ops	= &mchp_dscmi_ctrl_ops,
+		.id	= MCHP_DSCMI_CID_OSD_COLOR,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "OSD color",
+		.min	= MCHP_DSCMI_OSD_COLOR_MIN,
+		.max	= MCHP_DSCMI_OSD_COLOR_MAX,
+		.def	= MCHP_DSCMI_OSD_COLOR_DEFAULT,
+		.step	= MCHP_DSCMI_OSD_COLOR_STEP,
+	},
+};
+
+static int mchp_dscmi_formats_init(struct mchp_dscmi_fpga *mchp_dscmi)
+{
+	struct v4l2_subdev *subdev = mchp_dscmi->current_subdev->subdev;
+	struct v4l2_subdev_mbus_code_enum mbus_code = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+		.index = 0,
+	};
+
+	/*
+	 * Read all mbus codes supported by the camera sensor and return error
+	 * if it is not matching with mbus codes supported by the driver
+	 */
+
+	while (!v4l2_subdev_call(subdev, pad, enum_mbus_code, NULL, &mbus_code)) {
+		dev_dbg(mchp_dscmi->dev, "mbus_code.index %d\n", mbus_code.index);
+
+		if (mchp_dscmi_formats[0].mbus_code == mbus_code.code)
+			return 0;
+		mbus_code.index++;
+	}
+
+	return -ENXIO;
+}
+
+static int mchp_dscmi_graph_notify_bound(struct v4l2_async_notifier *notifier,
+					 struct v4l2_subdev *subdev,
+					 struct v4l2_async_connection *asc)
+{
+	struct mchp_dscmi_subdev_entity *subdev_entity =
+		container_of(notifier, struct mchp_dscmi_subdev_entity, notifier);
+
+	subdev_entity->subdev = subdev;
+
+	return 0;
+}
+
+static void mchp_dscmi_graph_notify_unbind(struct v4l2_async_notifier *notifier,
+					   struct v4l2_subdev *subdev,
+					   struct v4l2_async_connection *asc)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi = container_of(notifier->v4l2_dev,
+					     struct mchp_dscmi_fpga, v4l2_dev);
+
+	video_unregister_device(&mchp_dscmi->vdev);
+	v4l2_ctrl_handler_free(&mchp_dscmi->ctrl_handler);
+}
+
+static int mchp_dscmi_graph_notify_complete(struct v4l2_async_notifier *notifier)
+{
+	struct mchp_dscmi_fpga	*mchp_dscmi = container_of(notifier->v4l2_dev,
+							   struct mchp_dscmi_fpga,
+							   v4l2_dev);
+	struct vb2_queue *vb2_q;
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	struct video_device *vdev;
+	int ret;
+
+	ret = v4l2_device_register_subdev_nodes(&mchp_dscmi->v4l2_dev);
+	if (ret < 0) {
+		dev_err(mchp_dscmi->dev, "Failed to register subdev nodes\n");
+		return ret;
+	}
+
+	mchp_dscmi->current_subdev = container_of(notifier,
+						  struct mchp_dscmi_subdev_entity,
+						  notifier);
+
+	ctrl_hdlr = &mchp_dscmi->ctrl_handler;
+
+	if (mchp_dscmi->capabilities == H264)
+		v4l2_ctrl_handler_init(ctrl_hdlr, MCHP_DSCMI_H264_NUM_CTRLS);
+	else
+		v4l2_ctrl_handler_init(ctrl_hdlr, MCHP_DSCMI_NUM_CTRLS);
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &mchp_dscmi_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, MCHP_DSCMI_CTL_MIN, MCHP_DSCMI_CTL_MAX,
+			  MCHP_DSCMI_CTL_STEP, MCHP_DSCMI_CTL_MAX / 2);
+	v4l2_ctrl_new_std(ctrl_hdlr, &mchp_dscmi_ctrl_ops,
+			  V4L2_CID_CONTRAST, MCHP_DSCMI_CTL_MIN, MCHP_DSCMI_CTL_MAX,
+			  MCHP_DSCMI_CTL_STEP, MCHP_DSCMI_CTL_MAX / 2);
+	v4l2_ctrl_new_std(ctrl_hdlr, &mchp_dscmi_ctrl_ops,
+			  V4L2_CID_GAIN, MCHP_DSCMI_CTL_MIN, MCHP_DSCMI_CTL_MAX,
+			  MCHP_DSCMI_CTL_STEP, MCHP_DSCMI_GAIN_CTL_DEFAULT);
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &mchp_dscmi_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, MCHP_DSCMI_CTL_MIN, 1, MCHP_DSCMI_CTL_STEP, 0);
+
+	v4l2_ctrl_new_custom(ctrl_hdlr, &mchp_dscmi_gain_ctrls[0], NULL);
+	v4l2_ctrl_new_custom(ctrl_hdlr, &mchp_dscmi_gain_ctrls[1], NULL);
+	v4l2_ctrl_new_custom(ctrl_hdlr, &mchp_dscmi_gain_ctrls[2], NULL);
+	v4l2_ctrl_new_custom(ctrl_hdlr, &mchp_dscmi_gain_ctrls[4], NULL);
+	mchp_dscmi->horizontal_pos = MCHP_DSCMI_OSD_X_Y_POS_MIN;
+
+	v4l2_ctrl_new_custom(ctrl_hdlr, &mchp_dscmi_gain_ctrls[5], NULL);
+	mchp_dscmi->vertical_pos = MCHP_DSCMI_OSD_X_Y_POS_MIN;
+
+	v4l2_ctrl_new_custom(ctrl_hdlr, &mchp_dscmi_gain_ctrls[6], NULL);
+	v4l2_ctrl_new_custom(ctrl_hdlr, &mchp_dscmi_gain_ctrls[7], NULL);
+
+	if (mchp_dscmi->capabilities == H264)
+		v4l2_ctrl_new_custom(ctrl_hdlr, &mchp_dscmi_gain_ctrls[3], NULL);
+
+	if (ctrl_hdlr->error) {
+		ret = ctrl_hdlr->error;
+		return ret;
+	}
+	mchp_dscmi->v4l2_dev.ctrl_handler = ctrl_hdlr;
+
+	ret = mchp_dscmi_formats_init(mchp_dscmi);
+	if (ret) {
+		dev_err(mchp_dscmi->dev, "No supported mediabus format found\n");
+		goto free_ctrl_hdlr;
+	}
+
+	mchp_dscmi->fmt = default_fmt[mchp_dscmi->capabilities];
+
+	vb2_q = &mchp_dscmi->queue;
+	vb2_q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	vb2_q->io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ;
+	vb2_q->dev = mchp_dscmi->dev;
+	vb2_q->drv_priv = mchp_dscmi;
+	vb2_q->buf_struct_size = sizeof(struct mchp_dscmi_buffer);
+	vb2_q->ops = &mchp_dscmi_qops;
+	vb2_q->mem_ops = &vb2_dma_contig_memops;
+	vb2_q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	vb2_q->min_buffers_needed = 2;
+	vb2_q->lock = &mchp_dscmi->lock;
+
+	ret = vb2_queue_init(vb2_q);
+	if (ret) {
+		dev_err(mchp_dscmi->dev, "vb2 queue init failed %d\n", ret);
+		goto free_ctrl_hdlr;
+	}
+
+	INIT_LIST_HEAD(&mchp_dscmi->buf_list);
+	spin_lock_init(&mchp_dscmi->qlock);
+
+	vdev = &mchp_dscmi->vdev;
+	strscpy(vdev->name, KBUILD_MODNAME, sizeof(vdev->name));
+	vdev->release = video_device_release_empty;
+	vdev->fops = &mchp_dscmi_fops,
+	vdev->ioctl_ops = &mchp_dscmi_ioctl_ops,
+	vdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |
+			    V4L2_CAP_STREAMING;
+	vdev->lock = &mchp_dscmi->lock;
+	vdev->queue = vb2_q;
+	vdev->v4l2_dev = &mchp_dscmi->v4l2_dev;
+	video_set_drvdata(vdev, mchp_dscmi);
+
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
+	if (ret) {
+		dev_err(mchp_dscmi->dev, "video register device failed %d\n",
+			ret);
+		goto vb2_queue_free;
+	}
+
+	dev_dbg(mchp_dscmi->dev, "Async_complete\n");
+
+	return 0;
+
+vb2_queue_free:
+	vb2_queue_release(vb2_q);
+free_ctrl_hdlr:
+	v4l2_ctrl_handler_free(ctrl_hdlr);
+
+	return ret;
+}
+
+static const struct v4l2_async_notifier_operations mchp_dscmi_v4l2_async_ops = {
+	.bound = mchp_dscmi_graph_notify_bound,
+	.unbind = mchp_dscmi_graph_notify_unbind,
+	.complete = mchp_dscmi_graph_notify_complete,
+};
+
+static void mchp_dscmi_subdev_cleanup(struct mchp_dscmi_fpga *mchp_dscmi)
+{
+	struct mchp_dscmi_subdev_entity *subdev_entity;
+
+	list_for_each_entry(subdev_entity, &mchp_dscmi->subdev_entities, list) {
+		v4l2_async_nf_unregister(&subdev_entity->notifier);
+		v4l2_async_nf_cleanup(&subdev_entity->notifier);
+	}
+
+	INIT_LIST_HEAD(&mchp_dscmi->subdev_entities);
+}
+
+static void mchp_dscmi_gain_cal(struct mchp_dscmi_fpga *mchp_dscmi,
+				uint32_t total_average)
+{
+	struct v4l2_subdev *subdev = mchp_dscmi->current_subdev->subdev;
+	struct v4l2_control ctrl;
+	const u16 hs_threshold_high = (MCHP_DSCMI_GAIN_AVERAGE + MCHP_DSCMI_HYSTERESIS_GAIN);
+	const u16 hs_threshold_low = (MCHP_DSCMI_GAIN_AVERAGE - MCHP_DSCMI_HYSTERESIS_GAIN);
+	static u16 in_gain = MCHP_DSCMI_GAIN_INIT;
+	static u16 last_step;
+	u16 step;
+
+	/*
+	 * The total_average feed back value from fabric is less than threshold
+	 * value then the gain will be step up by one, if the value is more than
+	 * the threshold value then the gain will be step down by one.
+	 */
+
+	if (total_average < hs_threshold_low)
+		step = 1;
+	else
+		if (total_average > hs_threshold_high)
+			step = -1;
+		else
+			step = 0;
+
+	in_gain = in_gain + step;
+
+	if (in_gain < MCHP_DSCMI_GAIN_MIN)
+		in_gain = MCHP_DSCMI_GAIN_MIN;
+
+	if (in_gain >= MCHP_DSCMI_GAIN_AVERAGE)
+		in_gain = MCHP_DSCMI_GAIN_AVERAGE;
+
+	if (last_step != step && step != 0) {
+		dev_dbg(mchp_dscmi->dev, "average=%d in_gain=%d step=%d\n",
+			total_average, in_gain, step);
+	}
+
+	last_step = step;
+	if (step != 0) {
+		memset(&ctrl, 0, sizeof(ctrl));
+		ctrl.id = V4L2_CID_ANALOGUE_GAIN;
+		ctrl.value = in_gain;
+		v4l2_s_ctrl(NULL, subdev->ctrl_handler, &ctrl);
+	}
+}
+
+static void mchp_dscmi_work_auto_analog_gain(struct work_struct *work)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi = container_of(work,
+							struct mchp_dscmi_fpga,
+							auto_gain_dw.work);
+	int div = MCHP_DSCMI_MAX_WIDTH * MCHP_DSCMI_MAX_HEIGHT * 2;
+	u32 total_sum, total_average;
+
+	total_sum = mchp_dscmi_reg_read(mchp_dscmi, MCHP_DSCMI_RGB_SUM);
+	total_average = total_sum / div;
+	mchp_dscmi_gain_cal(mchp_dscmi, total_average);
+	queue_delayed_work(mchp_dscmi->auto_gain_wq,
+			   &mchp_dscmi->auto_gain_dw,
+			   msecs_to_jiffies(MCHP_DSCMI_DELAYED_WORK_TIME_M_SEC));
+}
+
+static int mchp_dscmi_graph_parse_dt(struct device *dev,
+				     struct mchp_dscmi_fpga *mchp_dscmi)
+{
+	struct device_node *np = dev->of_node;
+	struct device_node *epn;
+	struct mchp_dscmi_subdev_entity *subdev_entity;
+	struct v4l2_fwnode_endpoint v4l2_epn = { .bus_type = 0 };
+	int ret;
+
+	INIT_LIST_HEAD(&mchp_dscmi->subdev_entities);
+
+	epn = of_graph_get_next_endpoint(np, NULL);
+	if (!epn)
+		return 0;
+
+	ret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(epn),
+					 &v4l2_epn);
+	if (ret) {
+		dev_err(dev, "Could not parse the endpoint\n");
+		of_node_put(epn);
+		return -EINVAL;
+	}
+
+	subdev_entity = devm_kzalloc(dev, sizeof(*subdev_entity),
+				     GFP_KERNEL);
+	if (!subdev_entity) {
+		of_node_put(epn);
+		return -ENOMEM;
+	}
+
+	subdev_entity->epn = epn;
+
+	list_add_tail(&subdev_entity->list,
+		      &mchp_dscmi->subdev_entities);
+
+	of_node_put(epn);
+
+	return 0;
+}
+
+static int mchp_dscmi_read_capabilities(struct platform_device *pdev,
+					struct mchp_dscmi_fpga *mchp_dscmi)
+{
+	u32 capabilities;
+	int ret = 0;
+
+	capabilities = mchp_dscmi_reg_read(mchp_dscmi, MCHP_DSCMI_CAPABILITIES_V4L2);
+
+	switch (capabilities) {
+	case MCHP_DSCMI_CAPABILITIES_H264:
+		dev_info(&pdev->dev, "Found H.264 video capabilities\n");
+		mchp_dscmi->capabilities = H264;
+		break;
+	case MCHP_DSCMI_CAPABILITIES_MJPEG:
+		dev_info(&pdev->dev, "Found mJPEG video capabilities\n");
+		mchp_dscmi->capabilities = MJPEG;
+		break;
+	default:
+		dev_err(&pdev->dev, "capabilities not available 0x%x 0x%x\n",
+			capabilities,
+			mchp_dscmi_reg_read(mchp_dscmi, MCHP_DSCMI_CAPABILITIES_V4L2 + 4));
+		ret = -ENODEV;
+		break;
+	}
+
+	return ret;
+}
+
+static int mchp_dscmi_probe(struct platform_device *pdev)
+{
+	struct mchp_dscmi_fpga *mchp_dscmi;
+	struct mchp_dscmi_subdev_entity *subdev_entity;
+	struct device_node *np;
+	struct dma_chan *chan;
+	struct resource *res, r;
+	int ret;
+	const struct mchp_dscmi_driver_platdata *ddata;
+
+	mchp_dscmi = devm_kzalloc(&pdev->dev,
+				  sizeof(struct mchp_dscmi_fpga), GFP_KERNEL);
+	if (!mchp_dscmi)
+		return dev_err_probe(&pdev->dev, PTR_ERR(mchp_dscmi),
+				     "kzalloc failed\n");
+
+	mchp_dscmi->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
+	if (IS_ERR(mchp_dscmi->base))
+		return dev_err_probe(&pdev->dev, PTR_ERR(mchp_dscmi->base),
+				     "could not get mem resource\n");
+
+	ret = mchp_dscmi_read_capabilities(pdev, mchp_dscmi);
+	if (ret < 0)
+		return ret;
+
+	ddata = of_device_get_match_data(&pdev->dev);
+	if (ddata) {
+		if (ddata->quirks & MCHP_DSCMI_OSD_EN_FPGA_RTL)
+			mchp_dscmi->has_hw_osd_enable = true;
+		else
+			mchp_dscmi->has_hw_osd_enable = false;
+	}
+
+	np = of_parse_phandle(pdev->dev.of_node, "memory-region", 0);
+	if (!np)
+		return dev_err_probe(&pdev->dev, PTR_ERR(np),
+				     "No memory-region specified\n");
+
+	ret = of_address_to_resource(np, 0, &r);
+	of_node_put(np);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret,
+				"No memory address assigned to the region\n");
+
+	mchp_dscmi->cambuf.paddr = r.start;
+	mchp_dscmi->cambuf.size = r.end - r.start;
+
+	mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_STREAM_ADDR_LOW,
+			     lower_32_bits(r.start));
+
+	mchp_dscmi_reg_write(mchp_dscmi, MCHP_DSCMI_STREAM_ADDR_HIGH,
+			     upper_32_bits(r.start));
+
+	mchp_dscmi->irq = platform_get_irq(pdev, 0);
+	if (mchp_dscmi->irq <= 0)
+		return dev_err_probe(&pdev->dev, mchp_dscmi->irq,
+				     "could not get irq\n");
+
+	mchp_dscmi->reset_gpio = devm_gpiod_get_optional(&pdev->dev, "reset",
+							 GPIOD_OUT_LOW);
+	if (IS_ERR(mchp_dscmi->reset_gpio))
+		return dev_err_probe(&pdev->dev, PTR_ERR(mchp_dscmi->reset_gpio),
+				     "Failed to get reset gpio");
+
+	if (mchp_dscmi->reset_gpio)
+		gpiod_set_value_cansleep(mchp_dscmi->reset_gpio, 1);
+
+	mchp_dscmi->s_buff_index = 0;
+	mchp_dscmi->s_buff_size = 0;
+
+	chan = dma_request_chan(&pdev->dev, "rx");
+	if (IS_ERR(chan))
+		return dev_err_probe(&pdev->dev, PTR_ERR(chan),
+				     "Failed to request DMA channel\n");
+
+	ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));
+	if (ret) {
+		dev_err_probe(&pdev->dev, ret, "DMA set mask failed");
+		goto dma_free;
+	}
+
+	mutex_init(&mchp_dscmi->dma_lock);
+	mutex_init(&mchp_dscmi->lock);
+	mchp_dscmi->dma_chan = chan;
+
+	mchp_dscmi->pdev = pdev;
+	mchp_dscmi->dev = &pdev->dev;
+
+	ret = v4l2_device_register(&pdev->dev, &mchp_dscmi->v4l2_dev);
+	if (ret)
+		goto dma_free;
+
+	platform_set_drvdata(pdev, mchp_dscmi);
+
+	mchp_dscmi->auto_gain_wq = create_workqueue("auto gain");
+	INIT_DELAYED_WORK(&mchp_dscmi->auto_gain_dw,
+			  mchp_dscmi_work_auto_analog_gain);
+
+	ret = mchp_dscmi_graph_parse_dt(&pdev->dev, mchp_dscmi);
+	if (ret) {
+		dev_err_probe(&pdev->dev, ret, "Fail to parse device tree\n");
+		goto v4l2_unregister;
+	}
+
+	if (list_empty(&mchp_dscmi->subdev_entities)) {
+		ret = -ENODEV;
+		dev_err_probe(&pdev->dev, ret, "No subdev found\n");
+		goto v4l2_unregister;
+	}
+
+	list_for_each_entry(subdev_entity, &mchp_dscmi->subdev_entities, list) {
+		struct v4l2_async_connection *asc;
+
+		v4l2_async_nf_init(&subdev_entity->notifier, &mchp_dscmi->v4l2_dev);
+
+		asc = v4l2_async_nf_add_fwnode_remote(&subdev_entity->notifier,
+							       of_fwnode_handle(subdev_entity
+							       ->epn),
+							       struct v4l2_async_connection);
+		of_node_put(subdev_entity->epn);
+		subdev_entity->epn = NULL;
+
+		if (IS_ERR(asc)) {
+			ret = PTR_ERR(asc);
+			goto cleanup_subdev;
+		}
+
+		subdev_entity->notifier.ops = &mchp_dscmi_v4l2_async_ops;
+
+		ret = v4l2_async_nf_register(&subdev_entity->notifier);
+		if (ret) {
+			dev_err_probe(&pdev->dev, ret,
+				      "Fail to register async notifier\n");
+			goto cleanup_subdev;
+		}
+	}
+
+	dev_info(&pdev->dev, "Version %s loaded\n", MCHP_DSCMI_DRV_VERSION);
+	return 0;
+
+cleanup_subdev:
+	mchp_dscmi_subdev_cleanup(mchp_dscmi);
+v4l2_unregister:
+	v4l2_device_unregister(&mchp_dscmi->v4l2_dev);
+dma_free:
+	dma_release_channel(mchp_dscmi->dma_chan);
+	return ret;
+}
+
+static int mchp_dscmi_remove(struct platform_device *pdev)
+{
+	struct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);
+	struct mchp_dscmi_fpga *mchp_dscmi = container_of(v4l2_dev,
+							struct mchp_dscmi_fpga,
+							v4l2_dev);
+
+	mutex_destroy(&mchp_dscmi->dma_lock);
+	mutex_destroy(&mchp_dscmi->lock);
+	cancel_delayed_work(&mchp_dscmi->auto_gain_dw);
+	flush_workqueue(mchp_dscmi->auto_gain_wq);
+	destroy_workqueue(mchp_dscmi->auto_gain_wq);
+	v4l2_async_nf_unregister(&mchp_dscmi->current_subdev->notifier);
+	v4l2_async_nf_cleanup(&mchp_dscmi->current_subdev->notifier);
+	v4l2_device_unregister(&mchp_dscmi->v4l2_dev);
+	dma_release_channel(mchp_dscmi->dma_chan);
+
+	return 0;
+}
+
+static const struct mchp_dscmi_driver_platdata mpfs_osd = {
+	.quirks = MCHP_DSCMI_OSD_EN_FPGA_RTL,
+};
+
+static const struct of_device_id mchp_dscmi_of_match[] = {
+	{
+		.compatible = "microchip,fpga-dscmi",
+	}, {
+		.compatible = "microchip,fpga-dscmi-rtl-v2306",
+		.data = &mpfs_osd,
+	},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, mchp_dscmi_of_match);
+
+static struct platform_driver mchp_dscmi_driver = {
+	.probe = mchp_dscmi_probe,
+	.remove = mchp_dscmi_remove,
+	.driver = {
+		.name = MCHP_DSCMI_DRV_NAME,
+		.of_match_table = mchp_dscmi_of_match,
+	},
+};
+
+module_platform_driver(mchp_dscmi_driver);
+
+MODULE_DESCRIPTION("Microchip Digital Serial Camera Memory Interface Driver");
+MODULE_AUTHOR("Shravan Chippa <shravan.chippa@microchip.com>");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/microchip/microchip-common.c	2024-12-04 16:41:28.064881300 +0900
@@ -0,0 +1,238 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Microchip Video Common Driver.
+ *
+ * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries
+ * Author: Shravan Chippa <shavan.chippa@microchip.com>
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/export.h>
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include "microchip-common.h"
+
+#include <dt-bindings/media/microchip-common.h>
+
+static const struct mvideo_format mvideo_formats[] = {
+	{ MVCF_YUV_420, 8, NULL, MEDIA_BUS_FMT_UYVY8_2X8, 1,
+		V4L2_PIX_FMT_NV12, 2, 1, 1, 2 },
+	{ MVCF_H264, 8, NULL, MEDIA_BUS_FMT_H264_1X8, 1,
+		V4L2_PIX_FMT_H264, 1, 1, 1, 1 },
+	{ MVCF_YUV_422, 8, NULL, MEDIA_BUS_FMT_UYVY8_1X16, 2,
+		V4L2_PIX_FMT_YUYV, 1, 1, 1, 1 },
+	{ MVCF_YUV_444, 8, NULL, MEDIA_BUS_FMT_VUY8_1X24, 3,
+		V4L2_PIX_FMT_YUV444, 1, 1, 1, 1 },
+	{ MVCF_RBG, 8, NULL, MEDIA_BUS_FMT_RBG888_1X24, 3,
+		V4L2_PIX_FMT_RGB24, 1, 1, 1, 1 },
+	{ MVCF_RGB, 8, NULL, MEDIA_BUS_FMT_RGB888_1X24, 3,
+		V4L2_PIX_FMT_RGB24, 1, 1, 1, 1 },
+	{ MVCF_MJPEG, 8, NULL, MEDIA_BUS_FMT_JPEG_1X8, 3,
+		V4L2_PIX_FMT_MJPEG, 1, 1, 1, 1 },
+	{ MVCF_MONO_SENSOR, 8, "mono", MEDIA_BUS_FMT_Y8_1X8, 1,
+		V4L2_PIX_FMT_GREY, 1, 1, 1, 1 },
+	{ MVCF_MONO_SENSOR, 8, "rggb", MEDIA_BUS_FMT_SRGGB8_1X8, 1,
+		V4L2_PIX_FMT_SRGGB8, 1, 1, 1, 1 },
+	{ MVCF_MONO_SENSOR, 8, "grbg", MEDIA_BUS_FMT_SGRBG8_1X8, 1,
+		V4L2_PIX_FMT_SGRBG8, 1, 1, 1, 1 },
+	{ MVCF_MONO_SENSOR, 8, "gbrg", MEDIA_BUS_FMT_SGBRG8_1X8, 1,
+		V4L2_PIX_FMT_SGBRG8, 1, 1, 1, 1 },
+	{ MVCF_MONO_SENSOR, 8, "bggr", MEDIA_BUS_FMT_SBGGR8_1X8, 1,
+		V4L2_PIX_FMT_SBGGR8, 1, 1, 1, 1 },
+	{ MVCF_MONO_SENSOR, 10, "rggb", MEDIA_BUS_FMT_SRGGB10_1X10, 2,
+		V4L2_PIX_FMT_SRGGB10, 1, 1, 1, 1 },
+	{ MVCF_MONO_SENSOR, 10, "grbg", MEDIA_BUS_FMT_SGRBG10_1X10, 2,
+		V4L2_PIX_FMT_SGRBG10, 1, 1, 1, 1 },
+	{ MVCF_MONO_SENSOR, 10, "gbrg", MEDIA_BUS_FMT_SGBRG10_1X10, 2,
+		V4L2_PIX_FMT_SGBRG10, 1, 1, 1, 1 },
+	{ MVCF_MONO_SENSOR, 10, "bggr", MEDIA_BUS_FMT_SBGGR10_1X10, 2,
+		V4L2_PIX_FMT_SBGGR10, 1, 1, 1, 1 },
+	{ MVCF_MONO_SENSOR, 12, "rggb", MEDIA_BUS_FMT_SRGGB12_1X12, 2,
+		V4L2_PIX_FMT_SRGGB12, 1, 1, 1, 1 },
+	{ MVCF_MONO_SENSOR, 12, "grbg", MEDIA_BUS_FMT_SGRBG12_1X12, 2,
+		V4L2_PIX_FMT_SGRBG12, 1, 1, 1, 1 },
+	{ MVCF_MONO_SENSOR, 12, "gbrg", MEDIA_BUS_FMT_SGBRG12_1X12, 2,
+		V4L2_PIX_FMT_SGBRG12, 1, 1, 1, 1 },
+	{ MVCF_MONO_SENSOR, 12, "bggr", MEDIA_BUS_FMT_SBGGR12_1X12, 2,
+		V4L2_PIX_FMT_SBGGR12, 1, 1, 1, 1 },
+	{ MVCF_MONO_SENSOR, 16, "rggb", MEDIA_BUS_FMT_SRGGB16_1X16, 2,
+		V4L2_PIX_FMT_SRGGB16, 1, 1, 1, 1 },
+	{ MVCF_MONO_SENSOR, 16, "grbg", MEDIA_BUS_FMT_SGRBG16_1X16, 2,
+		V4L2_PIX_FMT_SGRBG16, 1, 1, 1, 1 },
+	{ MVCF_MONO_SENSOR, 16, "gbrg", MEDIA_BUS_FMT_SGBRG16_1X16, 2,
+		V4L2_PIX_FMT_SGBRG16, 1, 1, 1, 1 },
+	{ MVCF_MONO_SENSOR, 16, "bggr", MEDIA_BUS_FMT_SBGGR16_1X16, 2,
+		V4L2_PIX_FMT_SBGGR16, 1, 1, 1, 1 },
+};
+
+const struct mvideo_format *mvc_get_format_by_code(unsigned int code)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(mvideo_formats); ++i) {
+		const struct mvideo_format *format = &mvideo_formats[i];
+
+		if (format->code == code)
+			return format;
+	}
+
+	return ERR_PTR(-EINVAL);
+}
+EXPORT_SYMBOL_GPL(mvc_get_format_by_code);
+
+const struct mvideo_format *mvc_get_format_by_vf_code(unsigned int vf_code)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(mvideo_formats); ++i) {
+		const struct mvideo_format *format = &mvideo_formats[i];
+
+		if (format->vf_code == vf_code)
+			return format;
+	}
+
+	return ERR_PTR(-EINVAL);
+}
+EXPORT_SYMBOL_GPL(mvc_get_format_by_vf_code);
+
+const struct mvideo_format *mvc_get_format_by_fourcc(u32 fourcc)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(mvideo_formats); ++i) {
+		const struct mvideo_format *format = &mvideo_formats[i];
+
+		if (format->fourcc == fourcc)
+			return format;
+	}
+
+	return &mvideo_formats[0];
+}
+EXPORT_SYMBOL_GPL(mvc_get_format_by_fourcc);
+
+const struct mvideo_format *mvc_of_get_format(struct device_node *node)
+{
+	const char *pattern = "mono";
+	unsigned int vf_code;
+	unsigned int i;
+	u32 width;
+	int ret;
+
+	ret = of_property_read_u32(node, "microchip,video-format", &vf_code);
+	if (ret < 0)
+		return ERR_PTR(ret);
+
+	ret = of_property_read_u32(node, "microchip,video-width", &width);
+	if (ret < 0)
+		return ERR_PTR(ret);
+
+	if (vf_code == MVCF_MONO_SENSOR)
+		of_property_read_string(node, "microchip,cfa-pattern", &pattern);
+
+	for (i = 0; i < ARRAY_SIZE(mvideo_formats); ++i) {
+		const struct mvideo_format *format = &mvideo_formats[i];
+
+		if (format->vf_code != vf_code || format->width != width)
+			continue;
+
+		if (vf_code == MVCF_MONO_SENSOR &&
+		    strcmp(pattern, format->pattern))
+			continue;
+
+		return format;
+	}
+
+	return ERR_PTR(-EINVAL);
+}
+EXPORT_SYMBOL_GPL(mvc_of_get_format);
+
+void mvc_set_format_size(struct v4l2_mbus_framefmt *format,
+			 const struct v4l2_subdev_format *fmt)
+{
+	format->width = clamp_t(unsigned int, fmt->format.width,
+				MVC_MIN_WIDTH, MVC_MAX_WIDTH);
+	format->height = clamp_t(unsigned int, fmt->format.height,
+				 MVC_MIN_HEIGHT, MVC_MAX_HEIGHT);
+}
+EXPORT_SYMBOL_GPL(mvc_set_format_size);
+
+int mvc_init_resources(struct mvc_device *mvc)
+{
+	struct platform_device *pdev = to_platform_device(mvc->dev);
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mvc->iomem = devm_ioremap_resource(mvc->dev, res);
+	if (IS_ERR(mvc->iomem))
+		return PTR_ERR(mvc->iomem);
+
+	mvc->clk = devm_clk_get(mvc->dev, NULL);
+	if (IS_ERR(mvc->clk))
+		return PTR_ERR(mvc->clk);
+
+	clk_prepare_enable(mvc->clk);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mvc_init_resources);
+
+void mvc_cleanup_resources(struct mvc_device *mvc)
+{
+	clk_disable_unprepare(mvc->clk);
+}
+EXPORT_SYMBOL_GPL(mvc_cleanup_resources);
+
+int mvc_enum_mbus_code(struct v4l2_subdev *subdev,
+		       struct v4l2_subdev_state *sd_state,
+		       struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	if (code->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	if (code->index)
+		return -EINVAL;
+
+	format = v4l2_subdev_get_try_format(subdev, sd_state, code->pad);
+
+	code->code = format->code;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mvc_enum_mbus_code);
+
+int mvc_enum_frame_size(struct v4l2_subdev *subdev,
+			struct v4l2_subdev_state *sd_state,
+			struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	if (fse->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	format = v4l2_subdev_get_try_format(subdev, sd_state, fse->pad);
+
+	if (fse->index || fse->code != format->code)
+		return -EINVAL;
+
+	if (fse->pad == MVC_PAD_SINK) {
+		fse->min_width = MVC_MIN_WIDTH;
+		fse->max_width = MVC_MAX_WIDTH;
+		fse->min_height = MVC_MIN_HEIGHT;
+		fse->max_height = MVC_MAX_HEIGHT;
+	} else {
+		fse->min_width = format->width;
+		fse->max_width = format->width;
+		fse->min_height = format->height;
+		fse->max_height = format->height;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mvc_enum_frame_size);
+
+MODULE_DESCRIPTION("Microchip Video Common Driver");
+MODULE_AUTHOR("Shravan Chippa <shravan.chippa@microchip.com>");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/microchip/microchip-common.h	2024-12-04 16:41:28.065878700 +0900
@@ -0,0 +1,90 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Microchip Technology Inc. and its subsidiaries
+ * Author: Shravan Chippa <shavan.chippa@microchip.com>
+ *
+ */
+
+#ifndef __MCHP_COMMAN_H__
+#define __MCHP_COMMAN_H__
+
+#include <linux/bitops.h>
+#include <linux/io.h>
+#include <media/v4l2-subdev.h>
+
+#define MVC_PAD_SINK			0
+#define MVC_PAD_SOURCE			1
+
+/* User defined v4l2 control */
+#define MCHP_CID_RED_GAIN		(V4L2_CID_USER_BASE | 0x1001)
+#define MCHP_CID_GREEN_GAIN		(V4L2_CID_USER_BASE | 0x1002)
+#define MCHP_CID_BLUE_GAIN		(V4L2_CID_USER_BASE | 0x1003)
+#define MCHP_CID_Q_FACTOR		(V4L2_CID_USER_BASE | 0x1004)
+#define MCHP_CID_OSD_X_POS		(V4L2_CID_USER_BASE | 0x1005)
+#define MCHP_CID_OSD_Y_POS		(V4L2_CID_USER_BASE | 0x1006)
+#define MCHP_CID_OSD_ENABLE		(V4L2_CID_USER_BASE | 0x1007)
+#define MCHP_CID_OSD_COLOR		(V4L2_CID_USER_BASE | 0x1008)
+#define MCHP_CID_P_COUNT		(V4L2_CID_USER_BASE | 0x1009)
+#define MCHP_CID_COMPRESSION_RATIO	(V4L2_CID_USER_BASE | 0x100A)
+#define MCHP_CID_OSD_NUM		(V4L2_CID_USER_BASE | 0x100B)
+#define MCHP_CID_RGB_SUM		(V4L2_CID_USER_BASE | 0x100C)
+
+/**
+ * struct mvc_device - Microchip Video Capture device structure
+ * @subdev: V4L2 subdevice
+ * @dev: (OF) device
+ * @iomem: device I/O register space remapped to kernel virtual memory
+ * @clk: video core clock
+ */
+struct mvc_device {
+	struct v4l2_subdev subdev;
+	struct device *dev;
+	void __iomem *iomem;
+	struct clk *clk;
+};
+
+/**
+ * struct mvideo_format - Microchip video format description
+ * @vf_code: AXI4 video format code
+ * @width: AXI4 format width in bits per component
+ * @pattern: CFA pattern for Mono/Sensor formats
+ * @code: media bus format code
+ * @bpl_factor: Bytes per line factor
+ * @bpp: bits per pixel
+ * @fourcc: V4L2 pixel format FCC identifier
+ * @num_planes: number of planes w.r.t. color format
+ * @buffers: number of buffers per format
+ * @hsub: Horizontal sampling factor of Chroma
+ * @vsub: Vertical sampling factor of Chroma
+ */
+struct mvideo_format {
+	unsigned int vf_code;
+	unsigned int width;
+	const char *pattern;
+	unsigned int code;
+	unsigned int bpp;
+	u32 fourcc;
+	u8 num_planes;
+	u8 buffers;
+	u8 hsub;
+	u8 vsub;
+};
+
+const struct mvideo_format *mvc_get_format_by_code(unsigned int code);
+const struct mvideo_format *mvc_get_format_by_vf_code(unsigned int vf_code);
+const struct mvideo_format *mvc_get_format_by_fourcc(u32 fourcc);
+const struct mvideo_format *mvc_of_get_format(struct device_node *node);
+void mvc_set_format_size(struct v4l2_mbus_framefmt *format,
+			 const struct v4l2_subdev_format *fmt);
+int mvc_enum_mbus_code(struct v4l2_subdev *subdev,
+		       struct v4l2_subdev_state *sd_state,
+		       struct v4l2_subdev_mbus_code_enum *code);
+int mvc_enum_frame_size(struct v4l2_subdev *subdev,
+			struct v4l2_subdev_state *sd_state,
+			struct v4l2_subdev_frame_size_enum *fse);
+
+int mvc_init_resources(struct mvc_device *mvc);
+void mvc_cleanup_resources(struct mvc_device *mvc);
+
+#endif /* __MICROCHIP_COMMAN_H__ */
+
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/microchip/microchip-gvpc.c	2024-12-04 16:41:28.065878700 +0900
@@ -0,0 +1,323 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Microchip GVPC (Generic Video Pipeline Connector) Driver.
+ *
+ * Copyright (C) 2022-2023 Microchip Technology Inc. and its subsidiaries
+ * Author: Shravan Chippa <shavan.chippa@microchip.com>
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+
+#include "microchip-common.h"
+
+#define MVC_DEF_HEIGHT	1080
+#define MVC_DEF_WIDTH	1920
+
+/**
+ * struct mchp_gvpc_device - Microchip GVPC Core device structure
+ * @dev: device
+ * @subdev: The v4l2 subdev structure
+ * @iomem: Base address of subsystem
+ * @pads: media pads
+ * @formats: active V4L2 media bus formats at the sink and source pads
+ * @default_formats: default V4L2 media bus formats
+ * @vip_formats: format information corresponding to the pads active formats
+ */
+struct mchp_gvpc_device {
+	struct device *dev;
+	struct v4l2_subdev subdev;
+	void __iomem *iomem;
+
+	struct media_pad pads[2];
+
+	struct v4l2_mbus_framefmt formats[2];
+	struct v4l2_mbus_framefmt default_formats[2];
+	const struct mvideo_format *vip_formats[2];
+};
+
+static inline struct mchp_gvpc_device *to_gvpc(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct mchp_gvpc_device, subdev);
+}
+
+static int mchp_gvpc_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	/*
+	 * struct mchp_gvpc_device *mchp_gvpc = to_gvpc(subdev);
+	 * struct v4l2_mbus_framefmt *format = &mchp_gvpc->formats[MVC_PAD_SINK];
+	 */
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__mchp_gvpc_get_pad_format(struct mchp_gvpc_device *mchp_gvpc,
+			   struct v4l2_subdev_state *sd_state,
+			   unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&mchp_gvpc->subdev,
+						    sd_state, pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &mchp_gvpc->formats[pad];
+		break;
+	default:
+		format = NULL;
+		break;
+	}
+
+	return format;
+}
+
+static int mchp_gvpc_get_format(struct v4l2_subdev *subdev,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_subdev_format *fmt)
+{
+	struct mchp_gvpc_device *mchp_gvpc = to_gvpc(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __mchp_gvpc_get_pad_format(mchp_gvpc, sd_state, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int mchp_gvpc_set_format(struct v4l2_subdev *subdev,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_subdev_format *fmt)
+{
+	struct mchp_gvpc_device *mchp_gvpc = to_gvpc(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __mchp_gvpc_get_pad_format(mchp_gvpc, sd_state, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	if (fmt->pad == MVC_PAD_SOURCE) {
+		fmt->format = *format;
+		return 0;
+	}
+
+	mvc_set_format_size(format, fmt);
+
+	fmt->format = *format;
+
+	format = __mchp_gvpc_get_pad_format(mchp_gvpc, sd_state, MVC_PAD_SOURCE,
+					    fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	mvc_set_format_size(format, fmt);
+
+	return 0;
+}
+
+static int mchp_gvpc_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	struct mchp_gvpc_device *mchp_gvpc = to_gvpc(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state, MVC_PAD_SINK);
+	*format = mchp_gvpc->default_formats[MVC_PAD_SINK];
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state, MVC_PAD_SOURCE);
+	*format = mchp_gvpc->default_formats[MVC_PAD_SOURCE];
+
+	return 0;
+}
+
+static int mchp_gvpc_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops mchp_gvpc_video_ops = {
+	.s_stream = mchp_gvpc_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops mchp_gvpc_pad_ops = {
+	.enum_mbus_code = mvc_enum_mbus_code,
+	.get_fmt = mchp_gvpc_get_format,
+	.set_fmt = mchp_gvpc_set_format,
+	.link_validate = v4l2_subdev_link_validate_default,
+};
+
+static const struct v4l2_subdev_ops mchp_gvpc_ops = {
+	.video  = &mchp_gvpc_video_ops,
+	.pad    = &mchp_gvpc_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops mchp_gvpc_internal_ops = {
+	.open = mchp_gvpc_open,
+	.close = mchp_gvpc_close,
+};
+
+static const struct media_entity_operations mchp_gvpc_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static void mchp_gvpc_init_formats(struct mchp_gvpc_device *mchp_gvpc)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	/* Initialize default and active formats */
+	format = &mchp_gvpc->default_formats[MVC_PAD_SINK];
+	format->code = mchp_gvpc->vip_formats[MVC_PAD_SINK]->code;
+	format->field = V4L2_FIELD_NONE;
+	format->colorspace = V4L2_COLORSPACE_SRGB;
+
+	format->width = MVC_DEF_WIDTH;
+	format->height = MVC_DEF_HEIGHT;
+
+	mchp_gvpc->formats[MVC_PAD_SINK] = *format;
+
+	format = &mchp_gvpc->default_formats[MVC_PAD_SOURCE];
+	*format = mchp_gvpc->default_formats[MVC_PAD_SINK];
+	format->code = mchp_gvpc->vip_formats[MVC_PAD_SOURCE]->code;
+
+	mchp_gvpc->formats[MVC_PAD_SOURCE] = *format;
+}
+
+static int mchp_gvpc_parse_of(struct mchp_gvpc_device *mchp_gvpc)
+{
+	struct device *dev = mchp_gvpc->dev;
+	struct device_node *node = mchp_gvpc->dev->of_node;
+	struct device_node *ports;
+	struct device_node *port;
+	u32 port_id;
+	int ret;
+
+	ports = of_get_child_by_name(node, "ports");
+	if (!ports)
+		ports = node;
+
+	for_each_child_of_node(ports, port) {
+		if (port->name && (of_node_cmp(port->name, "port") == 0)) {
+			const struct mvideo_format *vip_format;
+
+			vip_format = mvc_of_get_format(port);
+			if (IS_ERR(vip_format))
+				return dev_err_probe(dev, IS_ERR(vip_format),
+						     "invalid format in DT");
+
+			ret = of_property_read_u32(port, "reg", &port_id);
+			if (ret < 0) {
+				dev_err(dev, "no reg in DT");
+				return ret;
+			}
+
+			if (port_id != 0 && port_id != 1) {
+				dev_err(dev, "invalid reg in DT");
+				return -EINVAL;
+			}
+
+			mchp_gvpc->vip_formats[port_id] = vip_format;
+		}
+	}
+
+	return 0;
+}
+
+static int mchp_gvpc_probe(struct platform_device *pdev)
+{
+	struct v4l2_subdev *subdev;
+	struct mchp_gvpc_device *mchp_gvpc;
+	struct resource *res;
+	int ret;
+
+	mchp_gvpc = devm_kzalloc(&pdev->dev, sizeof(*mchp_gvpc), GFP_KERNEL);
+	if (!mchp_gvpc)
+		return -ENOMEM;
+
+	mchp_gvpc->dev = &pdev->dev;
+
+	ret = mchp_gvpc_parse_of(mchp_gvpc);
+	if (ret < 0)
+		return ret;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mchp_gvpc->iomem = devm_ioremap_resource(mchp_gvpc->dev, res);
+	if (IS_ERR(mchp_gvpc->iomem))
+		return dev_err_probe(&pdev->dev, PTR_ERR(mchp_gvpc->iomem),
+				     "could not get mem resource\n");
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &mchp_gvpc->subdev;
+	v4l2_subdev_init(subdev, &mchp_gvpc_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &mchp_gvpc_internal_ops;
+	strscpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, mchp_gvpc);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	mchp_gvpc_init_formats(mchp_gvpc);
+
+	mchp_gvpc->pads[MVC_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	mchp_gvpc->pads[MVC_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	subdev->entity.ops = &mchp_gvpc_media_ops;
+	ret = media_entity_pads_init(&subdev->entity, 2, mchp_gvpc->pads);
+	if (ret < 0)
+		return ret;
+
+	platform_set_drvdata(pdev, mchp_gvpc);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	return 0;
+
+error:
+	media_entity_cleanup(&subdev->entity);
+	return ret;
+}
+
+static int mchp_gvpc_remove(struct platform_device *pdev)
+{
+	struct mchp_gvpc_device *mchp_gvpc = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &mchp_gvpc->subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	media_entity_cleanup(&subdev->entity);
+
+	return 0;
+}
+
+static const struct of_device_id mchp_gvpc_of_id_table[] = {
+	{ .compatible = "microchip,generic-video-pipeline-connector" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, mchp_gvpc_of_id_table);
+
+static struct platform_driver mchp_gvpc_driver = {
+	.driver = {
+		.name = "microchip-gvpc",
+		.of_match_table = mchp_gvpc_of_id_table,
+	},
+	.probe = mchp_gvpc_probe,
+	.remove = mchp_gvpc_remove,
+};
+
+module_platform_driver(mchp_gvpc_driver);
+
+MODULE_AUTHOR("Shravan Chippa <shravan.chippa@microchip.com>");
+MODULE_DESCRIPTION("Microchip Generic Video Pipeline Connector Driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/microchip/microchip-image-enhancement.c	2024-12-04 16:41:28.066876000 +0900
@@ -0,0 +1,561 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Microchip Video Image Enhancement Driver.
+ *
+ * Copyright (C) 2021-2022 Microchip Technology Inc. and its subsidiaries
+ * Author: Shravan Chippa <shavan.chippa@microchip.com>
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+
+#include <dt-bindings/media/microchip-common.h>
+
+#include "microchip-common.h"
+
+#define MCHP_IMAGE_ENHANCEMENT_IP_VER			0x00
+#define MCHP_IMAGE_ENHANCEMENT_CTRL			0x04
+#define MCHP_IMAGE_ENHANCEMENT_CTRL_START		BIT(0)
+#define MCHP_IMAGE_ENHANCEMENT_CTRL_RESET		BIT(1)
+
+#define MCHP_IMAGE_ENHANCEMENT_R_CONSTRAINT		0x08
+#define MCHP_IMAGE_ENHANCEMENT_G_CONSTRAINT		0x0C
+#define MCHP_IMAGE_ENHANCEMENT_B_CONSTRAINT		0x10
+#define MCHP_IMAGE_ENHANCEMENT_SECOND_CONSTRAINT	0x14
+#define MCHP_IMAGE_ENHANCEMENT_RGB_SUM			0x18
+
+#define MCHP_IMAGE_ENHANCEMENT_GAIN_CTL_DEFAULT		112
+#define MCHP_IMAGE_ENHANCEMENT_GAIN_CTL_MAX		255
+#define MCHP_IMAGE_ENHANCEMENT_CTL_MIN			0
+#define MCHP_IMAGE_ENHANCEMENT_CTL_MAX			255
+#define MCHP_IMAGE_ENHANCEMENT_CTL_STEP			1
+
+#define MCHP_IMAGE_ENHANCEMENT_NUM_CTRLS		6
+
+#define MCHP_IMAGE_ENHANCEMENT_DEF_FORMAT		MVCF_RGB
+
+#define MCHP_IMAGE_ENHANCEMENT_RGB_SUM_MAX		0xF27CB22F
+#define MCHP_IMAGE_ENHANCEMENT_RGB_SUM_MIN		0x100000
+#define MCHP_IMAGE_ENHANCEMENT_RGB_SUM_DEF		0x127CB22F
+
+/**
+ * struct mchp_image_enhancement - Microchip image enhancement device structure
+ * @dev: device
+ * @subdev: The v4l2 subdev structure
+ * @iomem: Base address of subsystem
+ * @pads: media pads
+ * @mutex : mutex lock for hardware reg access
+ * @formats: active V4L2 media bus formats at the sink and source pads
+ * @default_formats: default V4L2 media bus formats
+ * @vip_formats: format information corresponding to the pads active formats
+ * @ctrl_handler: control handler
+ */
+struct mchp_image_enhancement {
+	struct device *dev;
+	struct v4l2_subdev subdev;
+	void __iomem *iomem;
+
+	struct media_pad pads[2];
+
+	struct mutex lock;
+	struct v4l2_mbus_framefmt formats[2];
+	struct v4l2_mbus_framefmt default_formats[2];
+	const struct mvideo_format *vip_formats[2];
+
+	struct v4l2_ctrl_handler ctrl_handler;
+
+	int contrast;
+	int brightness;
+	int r_gain;
+	int b_gain;
+	int g_gain;
+};
+
+static inline struct mchp_image_enhancement *
+to_image_enhancement(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct mchp_image_enhancement, subdev);
+}
+
+static inline u32
+mchp_image_enhancement_reg_read(struct mchp_image_enhancement *image_enhancement,
+				u32 addr)
+{
+	return ioread32(image_enhancement->iomem + addr);
+}
+
+static inline void
+mchp_image_enhancement_reg_write(struct mchp_image_enhancement *image_enhancement,
+				 u32 addr, u32 value)
+{
+	iowrite32(value, image_enhancement->iomem + addr);
+}
+
+static inline void
+mchp_image_enhancement_clr(struct mchp_image_enhancement *image_enhancement,
+			   u32 addr, u32 clr)
+{
+	u32 val;
+
+	val = mchp_image_enhancement_reg_read(image_enhancement, addr) & ~clr;
+	mchp_image_enhancement_reg_write(image_enhancement, addr, val);
+}
+
+static inline void
+mchp_image_enhancement_set(struct mchp_image_enhancement *image_enhancement,
+			   u32 addr, u32 set)
+{
+	u32 val;
+
+	val = mchp_image_enhancement_reg_read(image_enhancement, addr) | set;
+	mchp_image_enhancement_reg_write(image_enhancement, addr, val);
+}
+
+static int mchp_image_enhancement_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct mchp_image_enhancement *image_enhancement = to_image_enhancement(subdev);
+	int ret;
+
+	if (!enable) {
+		mchp_image_enhancement_clr(image_enhancement, MCHP_IMAGE_ENHANCEMENT_CTRL,
+					   MCHP_IMAGE_ENHANCEMENT_CTRL_START);
+		return 0;
+	}
+
+	mchp_image_enhancement_set(image_enhancement, MCHP_IMAGE_ENHANCEMENT_CTRL,
+				   MCHP_IMAGE_ENHANCEMENT_CTRL_RESET);
+
+	ret = __v4l2_ctrl_handler_setup(&image_enhancement->ctrl_handler);
+	if (ret)
+		return ret;
+
+	mchp_image_enhancement_set(image_enhancement, MCHP_IMAGE_ENHANCEMENT_CTRL,
+				   MCHP_IMAGE_ENHANCEMENT_CTRL_START);
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__mchp_image_enhancement_get_pad_format(struct mchp_image_enhancement *image_enhancement,
+					struct v4l2_subdev_state *sd_state,
+					unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&image_enhancement->subdev,
+						    sd_state, pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &image_enhancement->formats[pad];
+		break;
+	default:
+		format = NULL;
+		break;
+	}
+
+	return format;
+}
+
+static int mchp_image_enhancement_get_format(struct v4l2_subdev *subdev,
+					     struct v4l2_subdev_state *sd_state,
+					     struct v4l2_subdev_format *fmt)
+{
+	struct mchp_image_enhancement *image_enhancement = to_image_enhancement(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __mchp_image_enhancement_get_pad_format(image_enhancement, sd_state,
+							 fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int mchp_image_enhancement_set_format(struct v4l2_subdev *subdev,
+					     struct v4l2_subdev_state *sd_state,
+					     struct v4l2_subdev_format *fmt)
+{
+	struct mchp_image_enhancement *image_enhancement = to_image_enhancement(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __mchp_image_enhancement_get_pad_format(image_enhancement, sd_state,
+							 fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	if (fmt->pad == MVC_PAD_SOURCE) {
+		fmt->format = *format;
+		return 0;
+	}
+
+	mvc_set_format_size(format, fmt);
+
+	fmt->format = *format;
+
+	format = __mchp_image_enhancement_get_pad_format(image_enhancement, sd_state,
+							 MVC_PAD_SOURCE,
+							 fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	mvc_set_format_size(format, fmt);
+
+	return 0;
+}
+
+static int mchp_image_enhancement_open(struct v4l2_subdev *subdev,
+				       struct v4l2_subdev_fh *fh)
+{
+	struct mchp_image_enhancement *image_enhancement = to_image_enhancement(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state, MVC_PAD_SINK);
+	*format = image_enhancement->default_formats[MVC_PAD_SINK];
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state, MVC_PAD_SOURCE);
+	*format = image_enhancement->default_formats[MVC_PAD_SOURCE];
+
+	return 0;
+}
+
+static int mchp_image_enhancement_close(struct v4l2_subdev *subdev,
+					struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+/*
+ * The calculated parameters are used by Image Enhancement IP UG0646 running
+ * in the FPGA logic. The equations used for calculation are explained in
+ * UG0646 page number 2 in the below link
+ *
+ * (https://ww1.microchip.com/downloads/aemDocuments/documents/FPGA/ProductDocuments/UserGuides/microsemi_image_enhancement_ip_user_guide_ug0646_v3.pdf)
+ *
+ * V4l2 controls like brightness, contrast, r_gain, g_gain and b_gain are
+ * calulated based on two functions second_constraint_cal() and
+ * contrast_scale_cal()
+ */
+
+static inline int second_constraint_cal(int brightness, int contrast_scale)
+{
+	return (128 * ((brightness) - ((128 * (contrast_scale)) / 10)));
+}
+
+static inline int contrast_scale_cal(int contrast)
+{
+	return ((325 * (contrast + 128) / (387 - contrast)) >> 5u);
+}
+
+static void mchp_image_enhancement_update_ctrls(struct mchp_image_enhancement *image_enhancement)
+{
+	u32 contrast_scale, second_constraint, r_gain_val, g_gain_val, b_gain_val;
+
+	contrast_scale = contrast_scale_cal(image_enhancement->contrast);
+	second_constraint = second_constraint_cal(image_enhancement->brightness,
+						  contrast_scale);
+	r_gain_val = ((image_enhancement->r_gain * contrast_scale) / 10);
+	g_gain_val = ((image_enhancement->g_gain * contrast_scale) / 10);
+	b_gain_val = ((image_enhancement->b_gain * contrast_scale) / 10);
+
+	mutex_lock(&image_enhancement->lock);
+
+	mchp_image_enhancement_reg_write(image_enhancement,
+					 MCHP_IMAGE_ENHANCEMENT_R_CONSTRAINT,
+					 r_gain_val);
+
+	mchp_image_enhancement_reg_write(image_enhancement,
+					 MCHP_IMAGE_ENHANCEMENT_G_CONSTRAINT,
+					 g_gain_val);
+
+	mchp_image_enhancement_reg_write(image_enhancement,
+					 MCHP_IMAGE_ENHANCEMENT_B_CONSTRAINT,
+					 b_gain_val);
+
+	mchp_image_enhancement_reg_write(image_enhancement,
+					 MCHP_IMAGE_ENHANCEMENT_SECOND_CONSTRAINT,
+					 second_constraint);
+	mutex_unlock(&image_enhancement->lock);
+}
+
+static int mchp_image_enhancement_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct mchp_image_enhancement *image_enhancement =
+		container_of(ctrl->handler, struct mchp_image_enhancement,
+			     ctrl_handler);
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		image_enhancement->brightness = ctrl->val;
+		mchp_image_enhancement_update_ctrls(image_enhancement);
+		break;
+	case V4L2_CID_CONTRAST:
+		image_enhancement->contrast = ctrl->val;
+		mchp_image_enhancement_update_ctrls(image_enhancement);
+		break;
+	case MCHP_CID_RED_GAIN:
+		image_enhancement->r_gain = ctrl->val;
+		mchp_image_enhancement_update_ctrls(image_enhancement);
+		break;
+	case MCHP_CID_GREEN_GAIN:
+		image_enhancement->g_gain = ctrl->val;
+		mchp_image_enhancement_update_ctrls(image_enhancement);
+		break;
+	case MCHP_CID_BLUE_GAIN:
+		image_enhancement->b_gain = ctrl->val;
+		mchp_image_enhancement_update_ctrls(image_enhancement);
+		break;
+	case MCHP_CID_RGB_SUM:
+		ctrl->val = mchp_image_enhancement_reg_read(image_enhancement,
+							    MCHP_IMAGE_ENHANCEMENT_RGB_SUM);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops mchp_image_enhancement_ctrl_ops = {
+	.s_ctrl	= mchp_image_enhancement_s_ctrl,
+};
+
+static const struct v4l2_subdev_video_ops mchp_image_enhancement_video_ops = {
+	.s_stream = mchp_image_enhancement_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops mchp_image_enhancement_pad_ops = {
+	.enum_mbus_code = mvc_enum_mbus_code,
+	.get_fmt = mchp_image_enhancement_get_format,
+	.set_fmt = mchp_image_enhancement_set_format,
+	.link_validate = v4l2_subdev_link_validate_default,
+};
+
+static const struct v4l2_subdev_ops mchp_image_enhancement_ops = {
+	.video  = &mchp_image_enhancement_video_ops,
+	.pad    = &mchp_image_enhancement_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops mchp_image_enhancement_internal_ops = {
+	.open = mchp_image_enhancement_open,
+	.close = mchp_image_enhancement_close,
+};
+
+static const struct media_entity_operations mchp_image_enhancement_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static struct v4l2_ctrl_config mchp_image_enhancement_ctrls[] = {
+	{
+		.ops	= &mchp_image_enhancement_ctrl_ops,
+		.id	= MCHP_CID_RED_GAIN,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "Gain, Red",
+		.min	= MCHP_IMAGE_ENHANCEMENT_CTL_MIN,
+		.max	= MCHP_IMAGE_ENHANCEMENT_GAIN_CTL_MAX,
+		.def	= MCHP_IMAGE_ENHANCEMENT_GAIN_CTL_DEFAULT,
+		.step	= MCHP_IMAGE_ENHANCEMENT_CTL_STEP,
+	}, {
+		.ops	= &mchp_image_enhancement_ctrl_ops,
+		.id	= MCHP_CID_GREEN_GAIN,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "Gain, Green",
+		.min	= MCHP_IMAGE_ENHANCEMENT_CTL_MIN,
+		.max	= MCHP_IMAGE_ENHANCEMENT_GAIN_CTL_MAX,
+		.def	= MCHP_IMAGE_ENHANCEMENT_GAIN_CTL_DEFAULT,
+		.step	= MCHP_IMAGE_ENHANCEMENT_CTL_STEP,
+	}, {
+		.ops	= &mchp_image_enhancement_ctrl_ops,
+		.id	= MCHP_CID_BLUE_GAIN,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "Gain, Blue",
+		.min	= MCHP_IMAGE_ENHANCEMENT_CTL_MIN,
+		.max	= MCHP_IMAGE_ENHANCEMENT_GAIN_CTL_MAX,
+		.def	= MCHP_IMAGE_ENHANCEMENT_GAIN_CTL_DEFAULT,
+		.step	= MCHP_IMAGE_ENHANCEMENT_CTL_STEP,
+	}, {
+		.ops	= &mchp_image_enhancement_ctrl_ops,
+		.id	= MCHP_CID_RGB_SUM,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "Rgb, Sum",
+		.min	= MCHP_IMAGE_ENHANCEMENT_RGB_SUM_MIN,
+		.max	= MCHP_IMAGE_ENHANCEMENT_RGB_SUM_MAX,
+		.def	= MCHP_IMAGE_ENHANCEMENT_RGB_SUM_DEF,
+		.step	= MCHP_IMAGE_ENHANCEMENT_CTL_STEP,
+	},
+};
+
+static int mchp_image_enhancement_init_controls(struct mchp_image_enhancement *image_enhancement)
+{
+	struct v4l2_ctrl_handler *ctrl_hdlr = &image_enhancement->ctrl_handler;
+	int ret;
+
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, MCHP_IMAGE_ENHANCEMENT_NUM_CTRLS);
+	if (ret)
+		return ret;
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &mchp_image_enhancement_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, MCHP_IMAGE_ENHANCEMENT_CTL_MIN,
+			  MCHP_IMAGE_ENHANCEMENT_CTL_MAX, MCHP_IMAGE_ENHANCEMENT_CTL_STEP,
+			  MCHP_IMAGE_ENHANCEMENT_CTL_MAX / 2);
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &mchp_image_enhancement_ctrl_ops,
+			  V4L2_CID_CONTRAST, MCHP_IMAGE_ENHANCEMENT_CTL_MIN,
+			  MCHP_IMAGE_ENHANCEMENT_CTL_MAX, MCHP_IMAGE_ENHANCEMENT_CTL_STEP,
+			  MCHP_IMAGE_ENHANCEMENT_CTL_MAX / 2);
+
+	v4l2_ctrl_new_custom(ctrl_hdlr, &mchp_image_enhancement_ctrls[0], NULL);
+	v4l2_ctrl_new_custom(ctrl_hdlr, &mchp_image_enhancement_ctrls[1], NULL);
+	v4l2_ctrl_new_custom(ctrl_hdlr, &mchp_image_enhancement_ctrls[2], NULL);
+	v4l2_ctrl_new_custom(ctrl_hdlr, &mchp_image_enhancement_ctrls[3], NULL);
+
+	if (ctrl_hdlr->error) {
+		dev_err(image_enhancement->dev, "control init failed: %d",
+			ctrl_hdlr->error);
+		v4l2_ctrl_handler_free(ctrl_hdlr);
+		return ctrl_hdlr->error;
+	}
+
+	image_enhancement->subdev.ctrl_handler = ctrl_hdlr;
+
+	return 0;
+}
+
+static int mchp_image_enhancement_init_formats(struct mchp_image_enhancement *image_enhancement)
+{
+	struct device *dev = image_enhancement->dev;
+	struct v4l2_mbus_framefmt *format;
+	const struct mvideo_format *vip_format;
+
+	vip_format = mvc_get_format_by_vf_code(MCHP_IMAGE_ENHANCEMENT_DEF_FORMAT);
+	if (IS_ERR(vip_format))
+		return dev_err_probe(dev, PTR_ERR(vip_format), "invalid format");
+
+	image_enhancement->vip_formats[MVC_PAD_SINK] = vip_format;
+	image_enhancement->vip_formats[MVC_PAD_SOURCE] = vip_format;
+
+	/* Initialize default and active formats */
+	format = &image_enhancement->default_formats[MVC_PAD_SINK];
+	format->code = image_enhancement->vip_formats[MVC_PAD_SINK]->code;
+	format->field = V4L2_FIELD_NONE;
+	format->colorspace = V4L2_COLORSPACE_SRGB;
+
+	format->width = MVC_MAX_WIDTH;
+	format->height = MVC_MAX_HEIGHT;
+
+	image_enhancement->formats[MVC_PAD_SINK] = *format;
+
+	format = &image_enhancement->default_formats[MVC_PAD_SOURCE];
+	*format = image_enhancement->default_formats[MVC_PAD_SINK];
+	format->code = image_enhancement->vip_formats[MVC_PAD_SOURCE]->code;
+
+	image_enhancement->formats[MVC_PAD_SOURCE] = *format;
+
+	return 0;
+}
+
+static int mchp_image_enhancement_probe(struct platform_device *pdev)
+{
+	struct v4l2_subdev *subdev;
+	struct mchp_image_enhancement *image_enhancement;
+	int ret;
+
+	image_enhancement = devm_kzalloc(&pdev->dev, sizeof(*image_enhancement), GFP_KERNEL);
+	if (!image_enhancement)
+		return -ENOMEM;
+
+	image_enhancement->dev = &pdev->dev;
+
+	image_enhancement->iomem = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(image_enhancement->iomem))
+		return PTR_ERR(image_enhancement->iomem);
+
+	mutex_init(&image_enhancement->lock);
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &image_enhancement->subdev;
+	v4l2_subdev_init(subdev, &mchp_image_enhancement_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &mchp_image_enhancement_internal_ops;
+	strscpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, image_enhancement);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	ret = mchp_image_enhancement_init_formats(image_enhancement);
+	if (ret < 0)
+		return ret;
+
+	mchp_image_enhancement_init_controls(image_enhancement);
+
+	mchp_image_enhancement_set(image_enhancement, MCHP_IMAGE_ENHANCEMENT_CTRL,
+				   MCHP_IMAGE_ENHANCEMENT_CTRL_RESET);
+
+	image_enhancement->pads[MVC_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	image_enhancement->pads[MVC_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	subdev->entity.ops = &mchp_image_enhancement_media_ops;
+	ret = media_entity_pads_init(&subdev->entity, 2, image_enhancement->pads);
+	if (ret < 0)
+		goto error;
+
+	platform_set_drvdata(pdev, image_enhancement);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error_media;
+	}
+
+	return 0;
+
+error_media:
+	media_entity_cleanup(&subdev->entity);
+error:
+	v4l2_ctrl_handler_free(&image_enhancement->ctrl_handler);
+
+	return ret;
+}
+
+static int mchp_image_enhancement_remove(struct platform_device *pdev)
+{
+	struct mchp_image_enhancement *image_enhancement = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &image_enhancement->subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	v4l2_ctrl_handler_free(&image_enhancement->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+
+	return 0;
+}
+
+static const struct of_device_id mchp_image_enhancement_of_id_table[] = {
+	{ .compatible = "microchip,image-enhancement-rtl-v1" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, mchp_image_enhancement_of_id_table);
+
+static struct platform_driver mchp_image_enhancement_driver = {
+	.driver = {
+		.name = "microchip-image-enhancement",
+		.of_match_table = mchp_image_enhancement_of_id_table,
+	},
+	.probe = mchp_image_enhancement_probe,
+	.remove = mchp_image_enhancement_remove,
+};
+
+module_platform_driver(mchp_image_enhancement_driver);
+
+MODULE_AUTHOR("Shravan Chippa <shravan.chippa@microchip.com>");
+MODULE_DESCRIPTION("Microchip Video Image Enhancement Driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/microchip/microchip-mipi-csi2rx.c	2024-12-04 16:41:28.068870700 +0900
@@ -0,0 +1,760 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for Microchip MIPI CSI-2 Rx
+ *
+ * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries
+ * Author: Shravan Chippa <shavan.chippa@microchip.com>
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/v4l2-subdev.h>
+#include <media/media-entity.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+#include <media/mipi-csi2.h>
+#include "microchip-common.h"
+
+#define MIPI_CSI_MEDIA_PADS		2
+#define MIPI_CSI_DEFAULT_WIDTH		1920
+#define MIPI_CSI_DEFAULT_HEIGHT		1080
+
+#define MIPI_CSI_MEDIA_PADS		2
+
+#define MIPI_CSI_IP_VER			0x00
+
+#define MIPI_CSI_CTRL			0x04
+#define MIPI_CSI_CTRL_START		BIT(0)
+#define MIPI_CSI_CTRL_RESET		BIT(1)
+
+#define MIPI_CSI_LANE_CONFIG		0x08
+#define MIPI_CSI_LANE_CONFIG_VAL(x)	((x) >> 4)
+
+#define MIPI_CSI_DATA_WIDTH		0x0C
+#define MIPI_CSI_NO_OF_PIXELS		0x10
+#define MIPI_CSI_NO_OF_VC		0x14
+#define MIPI_CSI_INPUT_DATA_INVERT	0x18
+#define MIPI_CSI_FIFO_SIZE		0x1C
+#define MIPI_CSI_FRAME_RESOLUTION	0x20
+#define MIPI_CSI_FRAME_WIDTH_MASK	GENMASK(31, 16)
+#define MIPI_CSI_FRAME_HIGHT_MASK	GENMASK(15, 0)
+
+#define MIPI_CSI_GLOBAL_INTERRUPT	0x24
+#define MIPI_CSI_GLOBAL_IRQ_EN		BIT(0)
+
+#define MIPI_CSI_INTERRUPT_STATUS	0x28
+#define MIPI_CSI_ISR_FR			BIT(0)
+#define MIPI_CSI_ISR_ACTIVE_LANE_ERR	BIT(1)
+#define MIPI_CSI_ISR_SOT_ERR		BIT(2)
+#define MIPI_CSI_ISR_SKEW_ERR		BIT(3)
+#define MIPI_CSI_ISR_ECC_ERR		BIT(4)
+#define MIPI_CSI_ISR_CRC_ERR		BIT(5)
+#define MIPI_CSI_ISR_DATAID_ERR		BIT(6)
+
+#define MIPI_CSI_INTERRUPT_EN		0x2C
+#define MIPI_CSI_INTERRUPT_EN_MASK	0x7F
+
+#define MIPI_CSI_CLK_STATUS		0x30
+#define MIPI_CSI_CLK_STATUS_STOPED	0x00
+#define MIPI_CSI_CLK_STATUS_RUNNING	0x01
+
+#define MIPI_CSI_DATA_LANE_STATUS	0x34
+#define MIPI_CSI_DATA_LANE_STATUS_CLR	0x54
+#define MIPI_CSI_WORD_COUNT		0x58
+#define MIPI_CSI_CAM_DATA_TYPE		0x5C
+#define MIPI_CSI_CAM_LANES_CONFIG	0x60
+
+/**
+ * struct mipi_csi2rx_event - Event log structure
+ * @mask: Event mask
+ * @name: Name of the event
+ */
+struct mipi_csi2rx_event {
+	u32 mask;
+	const char *name;
+};
+
+static const struct mipi_csi2rx_event mipi_csi2rx_events[] = {
+	{ MIPI_CSI_ISR_FR, "Frame Received" },
+	{ MIPI_CSI_ISR_ACTIVE_LANE_ERR, "Active lane mismatch Error" },
+	{ MIPI_CSI_ISR_SOT_ERR, "Start-of-Transmission Error" },
+	{ MIPI_CSI_ISR_SKEW_ERR, "IOD training failure error" },
+	{ MIPI_CSI_ISR_ECC_ERR, "ECC Error" },
+	{ MIPI_CSI_ISR_CRC_ERR, "CRC Error" },
+	{ MIPI_CSI_ISR_DATAID_ERR, "Data Id Error" },
+};
+
+#define MIPI_CSI_NUM_EVENTS		ARRAY_SIZE(mipi_csi2rx_events)
+#define MIPI_CSI2_MAX_RAW_FORMATS	4
+
+/*
+ * This table provides a mapping between CSI-2 Data type
+ * and media bus formats
+ */
+static const u32 mipi_csi2dt_mbus_lut[][2] = {
+	{ MIPI_CSI2_DT_RAW8, MEDIA_BUS_FMT_SRGGB8_1X8 },
+	{ MIPI_CSI2_DT_RAW8, MEDIA_BUS_FMT_SBGGR8_1X8 },
+	{ MIPI_CSI2_DT_RAW8, MEDIA_BUS_FMT_SGBRG8_1X8 },
+	{ MIPI_CSI2_DT_RAW8, MEDIA_BUS_FMT_SGRBG8_1X8 },
+	{ MIPI_CSI2_DT_RAW10, MEDIA_BUS_FMT_SRGGB10_1X10 },
+	{ MIPI_CSI2_DT_RAW10, MEDIA_BUS_FMT_SBGGR10_1X10 },
+	{ MIPI_CSI2_DT_RAW10, MEDIA_BUS_FMT_SGBRG10_1X10 },
+	{ MIPI_CSI2_DT_RAW10, MEDIA_BUS_FMT_SGRBG10_1X10 },
+	{ MIPI_CSI2_DT_RAW12, MEDIA_BUS_FMT_SRGGB12_1X12 },
+	{ MIPI_CSI2_DT_RAW12, MEDIA_BUS_FMT_SBGGR12_1X12 },
+	{ MIPI_CSI2_DT_RAW12, MEDIA_BUS_FMT_SGBRG12_1X12 },
+	{ MIPI_CSI2_DT_RAW12, MEDIA_BUS_FMT_SGRBG12_1X12 },
+	{ MIPI_CSI2_DT_RAW16, MEDIA_BUS_FMT_SRGGB16_1X16 },
+	{ MIPI_CSI2_DT_RAW16, MEDIA_BUS_FMT_SBGGR16_1X16 },
+	{ MIPI_CSI2_DT_RAW16, MEDIA_BUS_FMT_SGBRG16_1X16 },
+	{ MIPI_CSI2_DT_RAW16, MEDIA_BUS_FMT_SGRBG16_1X16 },
+	{ MIPI_CSI2_DT_RGB888, MEDIA_BUS_FMT_RGB888_1X24 },
+	{ MIPI_CSI2_DT_RAW20, 0 },
+};
+
+/**
+ * struct mipi_csi2rx_state - CSI-2 Rx Subsystem device structure
+ * @subdev: The v4l2 subdev structure
+ * @format: Active V4L2 formats on each pad
+ * @default_format: Default V4L2 format
+ * @events: counter for events
+ * @dev: Platform structure
+ * @clks: array of clocks
+ * @iomem: Base address of subsystem
+ * @max_num_lanes: Maximum number of lanes present
+ * @datatype: Data type filter
+ * @lock: mutex for accessing this structure
+ * @pads: media pads
+ * @streaming: Flag for storing streaming state
+ * @csi_fixed_out_raw8: If out put format is fixed to raw8
+ *
+ * This structure contains the device driver related parameters
+ */
+struct mipi_csi2rx_state {
+	struct v4l2_subdev subdev;
+	struct v4l2_mbus_framefmt format[2];
+	struct v4l2_mbus_framefmt default_format[2];
+	struct device *dev;
+	struct clk_bulk_data *clks;
+	void __iomem *iomem;
+	u32 max_num_lanes;
+	u32 datatype;
+	u32 events[MIPI_CSI_NUM_EVENTS];
+	/* used to protect access to this struct */
+	struct mutex lock;
+	struct media_pad pads[MIPI_CSI_MEDIA_PADS];
+	bool streaming;
+	bool csi_fixed_out_raw8;
+};
+
+static const struct clk_bulk_data mipi_csi2rx_clks[] = {
+	{ .id = "axi" },
+	{ .id = "video" },
+};
+
+static inline struct mipi_csi2rx_state *
+to_csi2rxstate(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct mipi_csi2rx_state, subdev);
+}
+
+/*
+ * Register related operations
+ */
+static inline u32 mipi_csi2rx_read(struct mipi_csi2rx_state *csi2rx, u32 addr)
+{
+	return ioread32(csi2rx->iomem + addr);
+}
+
+static inline void mipi_csi2rx_write(struct mipi_csi2rx_state *csi2rx, u32 addr,
+				     u32 value)
+{
+	iowrite32(value, csi2rx->iomem + addr);
+}
+
+static inline void mipi_csi2rx_clr(struct mipi_csi2rx_state *csi2rx, u32 addr,
+				   u32 clr)
+{
+	mipi_csi2rx_write(csi2rx, addr,
+			  mipi_csi2rx_read(csi2rx, addr) & ~clr);
+}
+
+static inline void mipi_csi2rx_set(struct mipi_csi2rx_state *csi2rx, u32 addr,
+				   u32 set)
+{
+	mipi_csi2rx_write(csi2rx, addr, mipi_csi2rx_read(csi2rx, addr) | set);
+}
+
+static u32 mipi_csi2rx_get_nth_mbus(u32 dt, u32 n)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(mipi_csi2dt_mbus_lut); i++) {
+		if (mipi_csi2dt_mbus_lut[i][0] == dt) {
+			if (n-- == 0)
+				return mipi_csi2dt_mbus_lut[i][1];
+		}
+	}
+
+	return 0;
+}
+
+static u32 mipi_csi2rx_get_dt(u32 mbus)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(mipi_csi2dt_mbus_lut); i++) {
+		if (mipi_csi2dt_mbus_lut[i][1] == mbus)
+			return mipi_csi2dt_mbus_lut[i][0];
+	}
+
+	return 0;
+}
+
+static int mipi_csi2rx_soft_reset(struct mipi_csi2rx_state *state)
+{
+	mipi_csi2rx_set(state, MIPI_CSI_CTRL, MIPI_CSI_CTRL_RESET);
+
+	return 0;
+}
+
+static void mipi_csi2rx_reset_event_counters(struct mipi_csi2rx_state *state)
+{
+	unsigned int i;
+
+	for (i = 0; i < MIPI_CSI_NUM_EVENTS; i++)
+		state->events[i] = 0;
+}
+
+static void mipi_csi2rx_log_counters(struct mipi_csi2rx_state *state)
+{
+	struct device *dev = state->dev;
+	unsigned int i;
+
+	for (i = 0; i < MIPI_CSI_NUM_EVENTS; i++) {
+		if (state->events[i] > 0) {
+			dev_info(dev, "%s events: %d\n",
+				 mipi_csi2rx_events[i].name,
+				 state->events[i]);
+		}
+	}
+}
+
+static int mipi_csi2rx_log_status(struct v4l2_subdev *sd)
+{
+	struct mipi_csi2rx_state *csi2rx = to_csi2rxstate(sd);
+	struct device *dev = csi2rx->dev;
+	u32 data;
+
+	mutex_lock(&csi2rx->lock);
+
+	mipi_csi2rx_log_counters(csi2rx);
+
+	dev_info(dev, "***** Core Status *****\n");
+	data = mipi_csi2rx_read(csi2rx, MIPI_CSI_CTRL);
+	dev_info(dev, "Core Status is %s\n",
+		 data & MIPI_CSI_CTRL_START ? "enable" : "disable");
+	data = mipi_csi2rx_read(csi2rx, MIPI_CSI_GLOBAL_INTERRUPT);
+	dev_info(dev, "MIPI_CSI_GLOBAL_IRQ_EN is %s\n",
+		 data & MIPI_CSI_GLOBAL_IRQ_EN ? "enable" : "disable");
+
+	data = mipi_csi2rx_read(csi2rx, MIPI_CSI_INTERRUPT_EN);
+	dev_info(dev, "MIPI_CSI_INTERRUPT_EN value = %x\n", data);
+
+	data = mipi_csi2rx_read(csi2rx, MIPI_CSI_LANE_CONFIG);
+	dev_info(dev, "No of Lanes configured = %x\n", (data & 0xF));
+	dev_info(dev, "Max Lanes supported = %x\n", (data >> 4));
+
+	data = mipi_csi2rx_read(csi2rx, MIPI_CSI_DATA_WIDTH);
+	dev_info(dev, "DATA_WIDTH configured = %x\n", data);
+
+	data = mipi_csi2rx_read(csi2rx, MIPI_CSI_NO_OF_PIXELS);
+	dev_info(dev, "No of output pixels per pixel clock = %x\n", data);
+
+	data = mipi_csi2rx_read(csi2rx, MIPI_CSI_NO_OF_VC);
+	dev_info(dev, "No of Virtual channels supported = %x\n", data & 0xF);
+	dev_info(dev, "Max Virtual channels supported = %x\n", data >> 4);
+
+	data = mipi_csi2rx_read(csi2rx, MIPI_CSI_INPUT_DATA_INVERT);
+	dev_info(dev, "Input data is inverted = %s\n", data ? "true" : "false");
+
+	data = mipi_csi2rx_read(csi2rx, MIPI_CSI_FIFO_SIZE);
+	dev_info(dev, "FIFO size = %x\n", data);
+
+	data = mipi_csi2rx_read(csi2rx, MIPI_CSI_CLK_STATUS);
+	dev_info(dev, "MIPI clock state = %s\n", data ? "Running" : "Stopped");
+
+	data = mipi_csi2rx_read(csi2rx, MIPI_CSI_WORD_COUNT);
+	dev_info(dev, "total packet recvied = %x\n", data);
+
+	data = mipi_csi2rx_read(csi2rx, MIPI_CSI_CAM_DATA_TYPE);
+	dev_info(dev, "MIPI_CAM_DATA_TYPE = %x\n", data);
+
+	data = mipi_csi2rx_read(csi2rx, MIPI_CSI_CAM_LANES_CONFIG);
+	dev_info(dev, "MIPI_CAM_LANES_CONFIG = %x\n", data);
+
+	mutex_unlock(&csi2rx->lock);
+
+	return 0;
+}
+
+static int mipi_csi2rx_start_stream(struct mipi_csi2rx_state *state)
+{
+	int ret = 0;
+
+	ret = mipi_csi2rx_soft_reset(state);
+	if (ret) {
+		state->streaming = false;
+		return ret;
+	}
+
+	mipi_csi2rx_set(state, MIPI_CSI_GLOBAL_INTERRUPT,
+			MIPI_CSI_GLOBAL_IRQ_EN);
+	mipi_csi2rx_set(state, MIPI_CSI_INTERRUPT_EN,
+			MIPI_CSI_INTERRUPT_EN_MASK);
+	mipi_csi2rx_set(state, MIPI_CSI_CTRL, MIPI_CSI_CTRL_START);
+
+	state->streaming = true;
+
+	return ret;
+}
+
+static void mipi_csi2rx_stop_stream(struct mipi_csi2rx_state *state)
+{
+	mipi_csi2rx_clr(state, MIPI_CSI_GLOBAL_INTERRUPT, MIPI_CSI_GLOBAL_IRQ_EN);
+	mipi_csi2rx_clr(state, MIPI_CSI_INTERRUPT_EN, MIPI_CSI_INTERRUPT_EN_MASK);
+	mipi_csi2rx_clr(state, MIPI_CSI_CTRL, MIPI_CSI_CTRL_START);
+
+	state->streaming = false;
+}
+
+static irqreturn_t mipi_csi2rx_irq_handler(int irq, void *data)
+{
+	struct mipi_csi2rx_state *state = (struct mipi_csi2rx_state *)data;
+	struct device *dev = state->dev;
+	u32 status;
+
+	status = mipi_csi2rx_read(state, MIPI_CSI_INTERRUPT_STATUS);
+	mipi_csi2rx_set(state, MIPI_CSI_INTERRUPT_STATUS, status);
+
+	if (status) {
+		unsigned int i;
+
+		for (i = 0; i < MIPI_CSI_NUM_EVENTS; i++) {
+			if (!(status & mipi_csi2rx_events[i].mask))
+				continue;
+			state->events[i]++;
+			dev_dbg_ratelimited(dev, "%s: %u\n",
+					    mipi_csi2rx_events[i].name,
+					    state->events[i]);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int mipi_csi2rx_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct mipi_csi2rx_state *csi2rx = to_csi2rxstate(sd);
+	int ret = 0;
+
+	mutex_lock(&csi2rx->lock);
+
+	if (enable == csi2rx->streaming)
+		goto stream_done;
+
+	if (enable) {
+		mipi_csi2rx_reset_event_counters(csi2rx);
+		ret = mipi_csi2rx_start_stream(csi2rx);
+	} else {
+		mipi_csi2rx_stop_stream(csi2rx);
+	}
+
+stream_done:
+	mutex_unlock(&csi2rx->lock);
+
+	return ret;
+}
+
+static struct v4l2_mbus_framefmt *
+__mipi_csi2rx_get_pad_format(struct mipi_csi2rx_state *csi2rx,
+			     struct v4l2_subdev_state *sd_state,
+			     unsigned int pad, u32 which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(&csi2rx->subdev,
+						  sd_state, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+			return &csi2rx->format[pad];
+	default:
+		return NULL;
+	}
+}
+
+static int mipi_csi2rx_init_cfg(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state)
+{
+	struct mipi_csi2rx_state *csi2rx = to_csi2rxstate(sd);
+	struct v4l2_mbus_framefmt *format;
+	unsigned int i;
+
+	mutex_lock(&csi2rx->lock);
+	for (i = 0; i < MIPI_CSI_MEDIA_PADS; i++) {
+		format = v4l2_subdev_get_try_format(sd, sd_state, i);
+		*format = csi2rx->default_format[i];
+	}
+	mutex_unlock(&csi2rx->lock);
+
+	return 0;
+}
+
+static int mipi_csi2rx_get_format(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_format *fmt)
+{
+	struct mipi_csi2rx_state *csi2rx = to_csi2rxstate(sd);
+
+	mutex_lock(&csi2rx->lock);
+	fmt->format = *__mipi_csi2rx_get_pad_format(csi2rx, sd_state,
+						  fmt->pad,
+						  fmt->which);
+	mutex_unlock(&csi2rx->lock);
+
+	return 0;
+}
+
+static int mipi_csi2rx_set_format(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_format *fmt)
+{
+	struct mipi_csi2rx_state *csi2rx = to_csi2rxstate(sd);
+	struct v4l2_mbus_framefmt *__format, *__format_sync;
+	u32 dt;
+
+	mutex_lock(&csi2rx->lock);
+
+	__format = __mipi_csi2rx_get_pad_format(csi2rx, sd_state,
+						fmt->pad, fmt->which);
+
+	if (fmt->pad == MVC_PAD_SOURCE) {
+		if (csi2rx->csi_fixed_out_raw8) {
+			dev_info(csi2rx->dev, "csi_fixed_out_raw8 is enabled");
+			switch (__format->code) {
+			case MEDIA_BUS_FMT_SBGGR10_1X10:
+			case MEDIA_BUS_FMT_SBGGR12_1X12:
+			case MEDIA_BUS_FMT_SBGGR14_1X14:
+			case MEDIA_BUS_FMT_SBGGR16_1X16:
+				__format->code = MEDIA_BUS_FMT_SBGGR8_1X8;
+				break;
+			case MEDIA_BUS_FMT_SGBRG10_1X10:
+			case MEDIA_BUS_FMT_SGBRG12_1X12:
+			case MEDIA_BUS_FMT_SGBRG14_1X14:
+			case MEDIA_BUS_FMT_SGBRG16_1X16:
+				__format->code = MEDIA_BUS_FMT_SGBRG8_1X8;
+				break;
+			case MEDIA_BUS_FMT_SGRBG10_1X10:
+			case MEDIA_BUS_FMT_SGRBG12_1X12:
+			case MEDIA_BUS_FMT_SGRBG14_1X14:
+			case MEDIA_BUS_FMT_SGRBG16_1X16:
+				__format->code = MEDIA_BUS_FMT_SGRBG8_1X8;
+				break;
+			case MEDIA_BUS_FMT_SRGGB10_1X10:
+			case MEDIA_BUS_FMT_SRGGB12_1X12:
+			case MEDIA_BUS_FMT_SRGGB14_1X14:
+			case MEDIA_BUS_FMT_SRGGB16_1X16:
+				__format->code = MEDIA_BUS_FMT_SRGGB8_1X8;
+				break;
+			}
+		}
+
+		__format_sync = __mipi_csi2rx_get_pad_format(csi2rx, sd_state, 0, fmt->which);
+
+		__format->width = __format_sync->width;
+		__format->height = __format_sync->height;
+		fmt->format = *__format;
+
+		mutex_unlock(&csi2rx->lock);
+
+		return 0;
+	}
+
+	dt = mipi_csi2rx_get_dt(fmt->format.code);
+	if (dt != csi2rx->datatype && dt != MIPI_CSI2_DT_RAW8) {
+		dev_info(csi2rx->dev, "Unsupported media bus format");
+		/* set the default format for the data type */
+		fmt->format.code = mipi_csi2rx_get_nth_mbus(csi2rx->datatype,
+							    0);
+	}
+
+	*__format = fmt->format;
+	mutex_unlock(&csi2rx->lock);
+
+	return 0;
+}
+
+static int mipi_csi2rx_enum_mbus_code(struct v4l2_subdev *sd,
+				      struct v4l2_subdev_state *sd_state,
+				      struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct mipi_csi2rx_state *state = to_csi2rxstate(sd);
+	u32 dt, n;
+	int ret = 0;
+
+	if (code->index < MIPI_CSI2_MAX_RAW_FORMATS) {
+		n = code->index;
+		dt = MIPI_CSI2_DT_RAW8;
+	} else if (state->datatype != MIPI_CSI2_DT_RAW8) {
+		n = code->index - MIPI_CSI2_MAX_RAW_FORMATS;
+		dt = state->datatype;
+	} else {
+		return -EINVAL;
+	}
+
+	code->code = mipi_csi2rx_get_nth_mbus(dt, n);
+	if (!code->code)
+		ret = -EINVAL;
+
+	return ret;
+}
+
+/* -----------------------------------------------------------------------------
+ * Media Operations
+ */
+
+static const struct media_entity_operations mipi_csi2rx_media_ops = {
+	.link_validate = v4l2_subdev_link_validate
+};
+
+static const struct v4l2_subdev_core_ops mipi_csi2rx_core_ops = {
+	.log_status = mipi_csi2rx_log_status,
+};
+
+static const struct v4l2_subdev_video_ops mipi_csi2rx_video_ops = {
+	.s_stream = mipi_csi2rx_s_stream
+};
+
+static const struct v4l2_subdev_pad_ops mipi_csi2rx_pad_ops = {
+	.init_cfg = mipi_csi2rx_init_cfg,
+	.get_fmt = mipi_csi2rx_get_format,
+	.set_fmt = mipi_csi2rx_set_format,
+	.enum_mbus_code = mipi_csi2rx_enum_mbus_code,
+	.link_validate = v4l2_subdev_link_validate_default,
+};
+
+static const struct v4l2_subdev_ops mipi_csi2rx_ops = {
+	.core = &mipi_csi2rx_core_ops,
+	.video = &mipi_csi2rx_video_ops,
+	.pad = &mipi_csi2rx_pad_ops
+};
+
+static int mipi_csi2rx_parse_of(struct mipi_csi2rx_state *csi2rx)
+{
+	struct device *dev = csi2rx->dev;
+	struct device_node *node = dev->of_node;
+
+	struct fwnode_handle *ep;
+	struct v4l2_fwnode_endpoint vep = {
+		.bus_type = V4L2_MBUS_CSI2_DPHY
+	};
+	int ret;
+
+	ret = of_property_read_u32(node, "microchip,csi-pxl-format",
+				   &csi2rx->datatype);
+	if (ret)
+		return dev_err_probe(dev, ret,
+				     "missing microchip,csi-pxl-format property\n");
+
+	switch (csi2rx->datatype) {
+	case MIPI_CSI2_DT_RAW8:
+	case MIPI_CSI2_DT_RAW10:
+	case MIPI_CSI2_DT_RAW12:
+	case MIPI_CSI2_DT_RAW14:
+	case MIPI_CSI2_DT_RAW16:
+		csi2rx->csi_fixed_out_raw8 =
+			of_property_read_bool(node, "microchip,csi-fixed-out-raw8");
+		break;
+	case MIPI_CSI2_DT_RGB888:
+		break;
+	default:
+		return dev_err_probe(dev, -EINVAL, "invalid csi-pxl-format property!\n");
+	}
+
+	ep = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev),
+					     MVC_PAD_SINK, 0,
+					     FWNODE_GRAPH_ENDPOINT_NEXT);
+	if (!ep)
+		return dev_err_probe(dev, -EINVAL, "no sink port found");
+
+	ret = v4l2_fwnode_endpoint_parse(ep, &vep);
+	fwnode_handle_put(ep);
+	if (ret)
+		return dev_err_probe(dev, ret, "error parsing sink port");
+
+	dev_dbg(dev, "mipi number lanes = %d\n",
+		vep.bus.mipi_csi2.num_data_lanes);
+
+	csi2rx->max_num_lanes = vep.bus.mipi_csi2.num_data_lanes;
+
+	ep = fwnode_graph_get_endpoint_by_id(dev_fwnode(dev),
+					     MVC_PAD_SOURCE, 0,
+					     FWNODE_GRAPH_ENDPOINT_NEXT);
+	if (!ep)
+		return dev_err_probe(dev, -EINVAL, "no source port found");
+
+	fwnode_handle_put(ep);
+
+	dev_dbg(dev, "%u data lanes, data type 0x%02x\n",
+		csi2rx->max_num_lanes,
+		csi2rx->datatype);
+
+	return 0;
+}
+
+static int mipi_csi2rx_probe(struct platform_device *pdev)
+{
+	struct v4l2_subdev *subdev;
+	struct mipi_csi2rx_state *csi2rx;
+	int num_clks = ARRAY_SIZE(mipi_csi2rx_clks);
+	struct device *dev = &pdev->dev;
+	int irq, ret;
+
+	csi2rx = devm_kzalloc(dev, sizeof(*csi2rx), GFP_KERNEL);
+	if (!csi2rx)
+		return -ENOMEM;
+
+	csi2rx->dev = dev;
+
+	csi2rx->clks = devm_kmemdup(dev, mipi_csi2rx_clks,
+				    sizeof(mipi_csi2rx_clks), GFP_KERNEL);
+	if (!csi2rx->clks)
+		return -ENOMEM;
+
+	ret = mipi_csi2rx_parse_of(csi2rx);
+	if (ret < 0)
+		return ret;
+
+	csi2rx->iomem = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(csi2rx->iomem))
+		return PTR_ERR(csi2rx->iomem);
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+
+	ret = devm_request_threaded_irq(dev, irq, NULL,
+					mipi_csi2rx_irq_handler, IRQF_ONESHOT,
+					dev_name(dev), csi2rx);
+	if (ret)
+		return dev_err_probe(dev, ret, "Unable to allocate irq\n");
+
+	ret = clk_bulk_get(dev, num_clks, csi2rx->clks);
+	if (ret)
+		return ret;
+
+	ret = clk_bulk_prepare_enable(num_clks, csi2rx->clks);
+	if (ret)
+		goto err_clk_put;
+
+	mutex_init(&csi2rx->lock);
+
+	mipi_csi2rx_soft_reset(csi2rx);
+
+	csi2rx->pads[MVC_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	csi2rx->pads[MVC_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+	/* Initialize the default format */
+	csi2rx->default_format[MVC_PAD_SINK].code =
+		mipi_csi2rx_get_nth_mbus(csi2rx->datatype, 0);
+	csi2rx->default_format[MVC_PAD_SINK].field = V4L2_FIELD_NONE;
+	csi2rx->default_format[MVC_PAD_SINK].colorspace = V4L2_COLORSPACE_SRGB;
+	csi2rx->default_format[MVC_PAD_SINK].width = MIPI_CSI_DEFAULT_WIDTH;
+	csi2rx->default_format[MVC_PAD_SINK].height = MIPI_CSI_DEFAULT_HEIGHT;
+	csi2rx->format[MVC_PAD_SINK] = csi2rx->default_format[MVC_PAD_SINK];
+
+	csi2rx->default_format[MVC_PAD_SOURCE].code =
+		mipi_csi2rx_get_nth_mbus(csi2rx->datatype, 0);
+	csi2rx->default_format[MVC_PAD_SOURCE].field = V4L2_FIELD_NONE;
+	csi2rx->default_format[MVC_PAD_SOURCE].colorspace = V4L2_COLORSPACE_SRGB;
+	csi2rx->default_format[MVC_PAD_SOURCE].width = MIPI_CSI_DEFAULT_WIDTH;
+	csi2rx->default_format[MVC_PAD_SOURCE].height = MIPI_CSI_DEFAULT_HEIGHT;
+	csi2rx->format[MVC_PAD_SOURCE] = csi2rx->default_format[MVC_PAD_SOURCE];
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &csi2rx->subdev;
+	v4l2_subdev_init(subdev, &mipi_csi2rx_ops);
+	subdev->dev = dev;
+	strscpy(subdev->name, dev_name(dev), sizeof(subdev->name));
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_EVENTS | V4L2_SUBDEV_FL_HAS_DEVNODE;
+	subdev->entity.ops = &mipi_csi2rx_media_ops;
+	v4l2_set_subdevdata(subdev, csi2rx);
+
+	ret = media_entity_pads_init(&subdev->entity, MIPI_CSI_MEDIA_PADS,
+				     csi2rx->pads);
+	if (ret < 0)
+		goto error;
+
+	platform_set_drvdata(pdev, csi2rx);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	return 0;
+error:
+	media_entity_cleanup(&subdev->entity);
+	mutex_destroy(&csi2rx->lock);
+	clk_bulk_disable_unprepare(num_clks, csi2rx->clks);
+err_clk_put:
+	clk_bulk_put(num_clks, csi2rx->clks);
+	return ret;
+}
+
+static int mipi_csi2rx_remove(struct platform_device *pdev)
+{
+	struct mipi_csi2rx_state *csi2rx = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &csi2rx->subdev;
+	int num_clks = ARRAY_SIZE(mipi_csi2rx_clks);
+
+	v4l2_async_unregister_subdev(subdev);
+	media_entity_cleanup(&subdev->entity);
+	mutex_destroy(&csi2rx->lock);
+	clk_bulk_disable_unprepare(num_clks, csi2rx->clks);
+	clk_bulk_put(num_clks, csi2rx->clks);
+
+	return 0;
+}
+
+static const struct of_device_id mipi_csi2rx_of_id_table[] = {
+	{ .compatible = "microchip,mipi-csi2-rx-rtl-v0", },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, mipi_csi2rx_of_id_table);
+
+static struct platform_driver mipi_csi2rx_driver = {
+	.driver = {
+		.name		= "microchip-csi2rxss",
+		.of_match_table	= mipi_csi2rx_of_id_table,
+	},
+	.probe			= mipi_csi2rx_probe,
+	.remove			= mipi_csi2rx_remove,
+};
+
+module_platform_driver(mipi_csi2rx_driver);
+
+MODULE_AUTHOR("Shravan Chippa <shravan.chippa@microchip.com>");
+MODULE_DESCRIPTION("Microchip MIPI CSI-2 Rx Subsystem Driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/microchip/microchip-osd.c	2024-12-04 16:41:28.068870700 +0900
@@ -0,0 +1,513 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Microchip Video On Screen Display Driver.
+ *
+ * Copyright (C) 2021-2022 Microchip Technology Inc. and its subsidiaries
+ * Author: Shravan Chippa <shavan.chippa@microchip.com>
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+
+#include <dt-bindings/media/microchip-common.h>
+
+#include "microchip-common.h"
+
+#define MCHP_OSD_IP_VER			0x00
+#define MCHP_OSD_CTRL			0x04
+#define MCHP_OSD_CTRL_START		BIT(0)
+#define MCHP_OSD_CTRL_RESET		BIT(1)
+
+#define MCHP_OSD_X_Y_POS		0x08
+#define MCHP_OSD_COLOR			0x0C
+#define MCHP_OSD_NUM			0x10
+#define MCHP_OSD_H_RES			0x14
+#define MCHP_OSD_V_RES			0x18
+
+/* Text overlay (On Screen Display) */
+#define MCHP_OSD_X_Y_POS_MAX		4096
+#define MCHP_OSD_X_Y_POS_MIN		4
+#define MCHP_OSD_X_Y_POS_DEFAULT	4
+#define MCHP_OSD_X_Y_POS_STEP		2
+#define MCHP_OSD_ENABLE_MAX		1
+#define MCHP_OSD_ENABLE_MIN		0
+#define MCHP_OSD_ENABLE_DEFAULT		1
+#define MCHP_OSD_ENABLE_STEP		1
+#define MCHP_OSD_DISABLE_MAX_PIX	0x2000
+#define MCHP_OSD_X_POS_SHIFT		16
+#define MCHP_OSD_COLOR_MAX		0xFFFFFF
+#define MCHP_OSD_COLOR_MIN		0x000000
+#define MCHP_OSD_COLOR_DEFAULT		0xFFFFFF
+#define MCHP_OSD_COLOR_STEP		1
+#define MCHP_OSD_NUM_MAX		200
+#define MCHP_OSD_NUM_MIN		1
+#define MCHP_OSD_NUM_DEFAULT		30
+#define MCHP_OSD_NUM_STEP		1
+
+#define MCHP_OSD_NUM_CTRLS		5
+
+#define MCHP_OSD_DEF_FORMAT		MVCF_RGB
+
+/**
+ * struct mchp_osd_device - Microchip On Screen Display device structure
+ * @dev: device
+ * @subdev: The v4l2 subdev structure
+ * @iomem: Base address of subsystem
+ * @pads: media pads
+ * @formats: active V4L2 media bus formats at the sink and source pads
+ * @default_formats: default V4L2 media bus formats
+ * @vip_formats: format information corresponding to the pads active formats
+ * @ctrl_handler: control handler
+ * @horizontal_pos:	overlay horizontal position
+ * @vertical_pos:	overlay vertical position
+ */
+struct mchp_osd_device {
+	struct device *dev;
+	struct v4l2_subdev subdev;
+	void __iomem *iomem;
+
+	struct media_pad pads[2];
+
+	struct v4l2_mbus_framefmt formats[2];
+	struct v4l2_mbus_framefmt default_formats[2];
+	const struct mvideo_format *vip_formats[2];
+
+	struct v4l2_ctrl_handler ctrl_handler;
+
+	int horizontal_pos;
+	int vertical_pos;
+};
+
+static inline struct mchp_osd_device *to_osd(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct mchp_osd_device, subdev);
+}
+
+static inline u32 mchp_osd_reg_read(struct mchp_osd_device *osd,
+				    u32 addr)
+{
+	return readl(osd->iomem + addr);
+}
+
+static inline void mchp_osd_reg_write(struct mchp_osd_device *osd,
+				      u32 addr, u32 value)
+{
+	writel(value, osd->iomem + addr);
+}
+
+static inline void mchp_osd_clr(struct mchp_osd_device *osd,
+				u32 addr, u32 clr)
+{
+	mchp_osd_reg_write(osd, addr, mchp_osd_reg_read(osd, addr) & ~clr);
+}
+
+static inline void mchp_osd_set(struct mchp_osd_device *osd,
+				u32 addr, u32 set)
+{
+	mchp_osd_reg_write(osd, addr, mchp_osd_reg_read(osd, addr) | set);
+}
+
+static int mchp_osd_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct mchp_osd_device *osd = to_osd(subdev);
+	struct v4l2_mbus_framefmt *format = &osd->formats[MVC_PAD_SINK];
+
+	if (!enable) {
+		mchp_osd_clr(osd, MCHP_OSD_CTRL, MCHP_OSD_CTRL_START);
+		return 0;
+	}
+
+	mchp_osd_reg_write(osd, MCHP_OSD_V_RES, format->height);
+	mchp_osd_reg_write(osd, MCHP_OSD_H_RES, format->width);
+
+	mchp_osd_set(osd, MCHP_OSD_CTRL, MCHP_OSD_CTRL_START);
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__mchp_osd_get_pad_format(struct mchp_osd_device *osd,
+			  struct v4l2_subdev_state *sd_state,
+			  unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&osd->subdev,
+						    sd_state, pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &osd->formats[pad];
+		break;
+	default:
+		format = NULL;
+		break;
+	}
+
+	return format;
+}
+
+static int mchp_osd_get_format(struct v4l2_subdev *subdev,
+			       struct v4l2_subdev_state *sd_state,
+			       struct v4l2_subdev_format *fmt)
+{
+	struct mchp_osd_device *osd = to_osd(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __mchp_osd_get_pad_format(osd, sd_state,
+					   fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int mchp_osd_set_format(struct v4l2_subdev *subdev,
+			       struct v4l2_subdev_state *sd_state,
+			       struct v4l2_subdev_format *fmt)
+{
+	struct mchp_osd_device *osd = to_osd(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __mchp_osd_get_pad_format(osd, sd_state, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	if (fmt->pad == MVC_PAD_SOURCE) {
+		fmt->format = *format;
+		return 0;
+	}
+
+	mvc_set_format_size(format, fmt);
+
+	fmt->format = *format;
+
+	format = __mchp_osd_get_pad_format(osd, sd_state,
+					   MVC_PAD_SOURCE, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	mvc_set_format_size(format, fmt);
+
+	mchp_osd_reg_write(osd, MCHP_OSD_V_RES, format->height);
+	mchp_osd_reg_write(osd, MCHP_OSD_H_RES, format->width);
+
+	return 0;
+}
+
+static int mchp_osd_open(struct v4l2_subdev *subdev,
+			 struct v4l2_subdev_fh *fh)
+{
+	struct mchp_osd_device *osd = to_osd(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state, MVC_PAD_SINK);
+	*format = osd->default_formats[MVC_PAD_SINK];
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state, MVC_PAD_SOURCE);
+	*format = osd->default_formats[MVC_PAD_SOURCE];
+
+	return 0;
+}
+
+static int mchp_osd_close(struct v4l2_subdev *subdev,
+			  struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+/*
+ * The compression ratio is calculated by the vDMA driver, but overlaid by
+ * the OSD FPGA logic. It is displayed on the streaming video, with the
+ * 4 least significant bits of MCHP_OSD_NUM containing the units, bits 4 to 7
+ * containing the tens etc to be displayed.
+ */
+
+static void mchp_dscmi_osd_text(struct mchp_osd_device *osd,
+				u32 compression_ratio)
+{
+	u32 compression_ratio_osd = ((compression_ratio % 10) |
+				    ((compression_ratio / 10 % 10) << 4) |
+				    ((compression_ratio / 100) << 8));
+
+	mchp_osd_reg_write(osd, MCHP_OSD_NUM, compression_ratio_osd);
+}
+
+static int mchp_osd_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct mchp_osd_device *osd =
+		container_of(ctrl->handler, struct mchp_osd_device,
+			     ctrl_handler);
+	u32 val;
+
+	switch (ctrl->id) {
+	case MCHP_CID_OSD_X_POS:
+		osd->horizontal_pos = ctrl->val;
+		val = osd->vertical_pos | (osd->horizontal_pos << MCHP_OSD_X_POS_SHIFT);
+		mchp_osd_reg_write(osd, MCHP_OSD_X_Y_POS, val);
+		break;
+	case MCHP_CID_OSD_Y_POS:
+		osd->vertical_pos = ctrl->val;
+		val = osd->vertical_pos | (osd->horizontal_pos << MCHP_OSD_X_POS_SHIFT);
+		mchp_osd_reg_write(osd, MCHP_OSD_X_Y_POS, val);
+		break;
+	case MCHP_CID_OSD_ENABLE:
+		if (ctrl->val)
+			mchp_osd_set(osd, MCHP_OSD_CTRL, MCHP_OSD_CTRL_START);
+		else
+			mchp_osd_clr(osd, MCHP_OSD_CTRL, MCHP_OSD_CTRL_START);
+		break;
+	case MCHP_CID_OSD_COLOR:
+		mchp_osd_reg_write(osd, MCHP_OSD_COLOR, ctrl->val);
+		break;
+	case MCHP_CID_OSD_NUM:
+		mchp_dscmi_osd_text(osd, ctrl->val);
+		break;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops mchp_osd_ctrl_ops = {
+	.s_ctrl	= mchp_osd_s_ctrl,
+};
+
+static const struct v4l2_subdev_video_ops mchp_osd_video_ops = {
+	.s_stream = mchp_osd_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops mchp_osd_pad_ops = {
+	.enum_mbus_code = mvc_enum_mbus_code,
+	.get_fmt = mchp_osd_get_format,
+	.set_fmt = mchp_osd_set_format,
+	.link_validate = v4l2_subdev_link_validate_default,
+};
+
+static const struct v4l2_subdev_ops mchp_osd_ops = {
+	.video  = &mchp_osd_video_ops,
+	.pad    = &mchp_osd_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops mchp_osd_internal_ops = {
+	.open = mchp_osd_open,
+	.close = mchp_osd_close,
+};
+
+static const struct media_entity_operations mchp_osd_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static struct v4l2_ctrl_config mchp_osd_ctrls[] = {
+	{
+		.ops	= &mchp_osd_ctrl_ops,
+		.id	= MCHP_CID_OSD_X_POS,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "OSDx Position",
+		.min	= MCHP_OSD_X_Y_POS_MIN,
+		.max	= MCHP_OSD_X_Y_POS_MAX,
+		.def	= MCHP_OSD_X_Y_POS_DEFAULT,
+		.step	= MCHP_OSD_X_Y_POS_STEP,
+	}, {
+		.ops	= &mchp_osd_ctrl_ops,
+		.id	= MCHP_CID_OSD_Y_POS,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "OSDy Position",
+		.min	= MCHP_OSD_X_Y_POS_MIN,
+		.max	= MCHP_OSD_X_Y_POS_MAX,
+		.def	= MCHP_OSD_X_Y_POS_DEFAULT,
+		.step	= MCHP_OSD_X_Y_POS_STEP,
+	}, {
+		.ops	= &mchp_osd_ctrl_ops,
+		.id	= MCHP_CID_OSD_ENABLE,
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.name	= "OSD enable",
+		.min	= MCHP_OSD_ENABLE_MIN,
+		.max	= MCHP_OSD_ENABLE_MAX,
+		.def	= MCHP_OSD_ENABLE_DEFAULT,
+		.step	= MCHP_OSD_ENABLE_STEP,
+	}, {
+		.ops	= &mchp_osd_ctrl_ops,
+		.id	= MCHP_CID_OSD_COLOR,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "OSD color",
+		.min	= MCHP_OSD_COLOR_MIN,
+		.max	= MCHP_OSD_COLOR_MAX,
+		.def	= MCHP_OSD_COLOR_DEFAULT,
+		.step	= MCHP_OSD_COLOR_STEP,
+	}, {
+		.ops	= &mchp_osd_ctrl_ops,
+		.id	= MCHP_CID_OSD_NUM,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "OSD num",
+		.min	= MCHP_OSD_NUM_MIN,
+		.max	= MCHP_OSD_NUM_MAX,
+		.def	= MCHP_OSD_NUM_DEFAULT,
+		.step	= MCHP_OSD_NUM_STEP,
+	},
+};
+
+static int mchp_osd_init_controls(struct mchp_osd_device *osd)
+{
+	struct v4l2_ctrl_handler *ctrl_hdlr = &osd->ctrl_handler;
+	int ret;
+
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, MCHP_OSD_NUM_CTRLS);
+	if (ret)
+		return ret;
+
+	v4l2_ctrl_new_custom(ctrl_hdlr, &mchp_osd_ctrls[0], NULL);
+	osd->horizontal_pos =  MCHP_OSD_X_Y_POS_MIN;
+
+	v4l2_ctrl_new_custom(ctrl_hdlr, &mchp_osd_ctrls[1], NULL);
+	osd->vertical_pos =  MCHP_OSD_X_Y_POS_MIN;
+
+	v4l2_ctrl_new_custom(ctrl_hdlr, &mchp_osd_ctrls[2], NULL);
+	v4l2_ctrl_new_custom(ctrl_hdlr, &mchp_osd_ctrls[3], NULL);
+	v4l2_ctrl_new_custom(ctrl_hdlr, &mchp_osd_ctrls[4], NULL);
+
+	if (ctrl_hdlr->error) {
+		dev_err(osd->dev, "control init failed: %d",
+			ctrl_hdlr->error);
+		v4l2_ctrl_handler_free(ctrl_hdlr);
+		return ctrl_hdlr->error;
+	}
+
+	osd->subdev.ctrl_handler = ctrl_hdlr;
+
+	return 0;
+}
+
+static int mchp_osd_init_formats(struct mchp_osd_device *osd)
+{
+	struct device *dev = osd->dev;
+	struct v4l2_mbus_framefmt *format;
+	const struct mvideo_format *vip_format;
+
+	vip_format = mvc_get_format_by_vf_code(MCHP_OSD_DEF_FORMAT);
+	if (IS_ERR(vip_format))
+		return dev_err_probe(dev, PTR_ERR(vip_format), "invalid format");
+
+	osd->vip_formats[MVC_PAD_SINK] = vip_format;
+	osd->vip_formats[MVC_PAD_SOURCE] = vip_format;
+
+	/* Initialize default and active formats */
+	format = &osd->default_formats[MVC_PAD_SINK];
+	format->code = osd->vip_formats[MVC_PAD_SINK]->code;
+	format->field = V4L2_FIELD_NONE;
+	format->colorspace = V4L2_COLORSPACE_SRGB;
+
+	format->width = MVC_MAX_WIDTH;
+	format->height = MVC_MAX_HEIGHT;
+
+	osd->formats[MVC_PAD_SINK] = *format;
+
+	format = &osd->default_formats[MVC_PAD_SOURCE];
+	*format = osd->default_formats[MVC_PAD_SINK];
+	format->code = osd->vip_formats[MVC_PAD_SOURCE]->code;
+
+	osd->formats[MVC_PAD_SOURCE] = *format;
+
+	return 0;
+}
+
+static int mchp_osd_probe(struct platform_device *pdev)
+{
+	struct v4l2_subdev *subdev;
+	struct mchp_osd_device *osd;
+	int ret;
+
+	osd = devm_kzalloc(&pdev->dev, sizeof(*osd), GFP_KERNEL);
+	if (!osd)
+		return -ENOMEM;
+
+	osd->dev = &pdev->dev;
+
+	osd->iomem = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(osd->iomem))
+		return PTR_ERR(osd->iomem);
+
+	mchp_osd_set(osd, MCHP_OSD_CTRL, MCHP_OSD_CTRL_RESET);
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &osd->subdev;
+	v4l2_subdev_init(subdev, &mchp_osd_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &mchp_osd_internal_ops;
+	strscpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, osd);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	ret = mchp_osd_init_formats(osd);
+	if (ret < 0)
+		return ret;
+
+	mchp_osd_init_controls(osd);
+
+	osd->pads[MVC_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	osd->pads[MVC_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	subdev->entity.ops = &mchp_osd_media_ops;
+	ret = media_entity_pads_init(&subdev->entity, 2, osd->pads);
+	if (ret < 0)
+		goto error;
+
+	platform_set_drvdata(pdev, osd);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error_media;
+	}
+
+	return 0;
+
+error_media:
+	media_entity_cleanup(&subdev->entity);
+error:
+	v4l2_ctrl_handler_free(&osd->ctrl_handler);
+
+	return ret;
+}
+
+static int mchp_osd_remove(struct platform_device *pdev)
+{
+	struct mchp_osd_device *osd = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &osd->subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	v4l2_ctrl_handler_free(&osd->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+
+	return 0;
+}
+
+static const struct of_device_id mchp_osd_of_id_table[] = {
+	{ .compatible = "microchip,osd-rtl-v1" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, mchp_osd_of_id_table);
+
+static struct platform_driver mchp_osd_driver = {
+	.driver = {
+		.name = "microchip-osd",
+		.of_match_table = mchp_osd_of_id_table,
+	},
+	.probe = mchp_osd_probe,
+	.remove = mchp_osd_remove,
+};
+
+module_platform_driver(mchp_osd_driver);
+
+MODULE_AUTHOR("Shravan Chippa <shravan.chippa@microchip.com>");
+MODULE_DESCRIPTION("Microchip Video On Screen Display Driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/microchip/microchip-rgb-scaler.c	2024-12-04 16:41:28.069868000 +0900
@@ -0,0 +1,509 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Microchip RGB Scaler Driver.
+ *
+ * Copyright (C) 2022-2023 Microchip Technology Inc. and its subsidiaries
+ * Author: Shravan Chippa <shavan.chippa@microchip.com>
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/fixp-arith.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-subdev.h>
+
+#include <dt-bindings/media/microchip-common.h>
+
+#include "microchip-common.h"
+
+#define MCHP_RGB_SCALER_MIN_WIDTH		32
+#define MCHP_RGB_SCALER_MAX_WIDTH		4096
+#define MCHP_RGB_SCALER_MIN_HEIGHT		32
+#define MCHP_RGB_SCALER_MAX_HEIGHT		4096
+
+#define MCHP_RGB_SCALER_DEFAULT_WIDTH		1920
+#define MCHP_RGB_SCALER_DEFAULT_HEIGHT		1080
+
+#define MCHP_RGB_SCALER_IP_VER			0x00
+#define MCHP_RGB_SCALER_CTRL			0x04
+#define MCHP_RGB_SCALER_CTRL_START		BIT(0)
+#define MCHP_RGB_SCALER_CTRL_RESET		BIT(1)
+
+#define MCHP_RGB_SCALER_INPUT_HRES		0x08
+#define MCHP_RGB_SCALER_INPUT_VRES		0x0C
+#define MCHP_RGB_SCALER_OUTPUT_HRES		0x10
+#define MCHP_RGB_SCALER_OUTPUT_VRES		0x14
+#define MCHP_RGB_SCALER_FACTOR_H		0x18
+#define MCHP_RGB_SCALER_FACTOR_V		0x1C
+
+#define MCHP_RGB_SCALER_DEF_FORMAT		MVCF_RGB
+
+/**
+ * struct mchp_rgb_scaler_device - Microchip RGB Scaler device structure
+ * @dev: device
+ * @subdev: The v4l2 subdev structure
+ * @iomem: Base address of subsystem
+ * @pads: media pads
+ * @mutex : mutex lock for hardware reg access
+ * @formats: V4L2 media bus formats at the sink and source pads
+ * @default_formats: default V4L2 media bus formats
+ * @vip_formats: Microchi Video IP format
+ * @crop: Active crop rectangle for the sink pad
+ */
+struct mchp_rgb_scaler_device {
+	struct device *dev;
+	struct v4l2_subdev subdev;
+	void __iomem *iomem;
+
+	struct media_pad pads[2];
+
+	struct mutex lock;
+	struct v4l2_mbus_framefmt formats[2];
+	struct v4l2_mbus_framefmt default_formats[2];
+	const struct mvideo_format *vip_formats[2];
+
+	struct v4l2_rect crop;
+};
+
+static inline struct mchp_rgb_scaler_device *to_scaler(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct mchp_rgb_scaler_device, subdev);
+}
+
+static inline u32 mchp_rgb_scaler_read(struct mchp_rgb_scaler_device *rgb_scaler, u32 addr)
+{
+	return readl(rgb_scaler->iomem + addr);
+}
+
+static inline void mchp_rgb_scaler_write(struct mchp_rgb_scaler_device *rgb_scaler,
+					 u32 addr, u32 value)
+{
+	writel(value, rgb_scaler->iomem + addr);
+}
+
+static inline void mchp_rgb_scaler_clr(struct mchp_rgb_scaler_device *rgb_scaler,
+				       u32 addr, u32 clr)
+{
+	mchp_rgb_scaler_write(rgb_scaler, addr,
+			      mchp_rgb_scaler_read(rgb_scaler, addr) & ~clr);
+}
+
+static inline void mchp_rgb_scaler_set(struct mchp_rgb_scaler_device *rgb_scaler,
+				       u32 addr, u32 set)
+{
+	mchp_rgb_scaler_write(rgb_scaler, addr, mchp_rgb_scaler_read(rgb_scaler, addr) | set);
+}
+
+static void mchp_set_scale_factor(struct mchp_rgb_scaler_device *rgb_scaler)
+{
+	u32 in_width, in_height, out_width, out_height;
+	u32 scale_factor_v, scale_factor_h;
+
+	in_width = rgb_scaler->formats[MVC_PAD_SINK].width;
+	in_height = rgb_scaler->formats[MVC_PAD_SINK].height;
+	out_width = rgb_scaler->formats[MVC_PAD_SOURCE].width;
+	out_height = rgb_scaler->formats[MVC_PAD_SOURCE].height;
+
+	scale_factor_h = (((in_width - 1) * 1024) / out_width);
+	scale_factor_v = (((in_height - 1) * 1024) / out_height);
+
+	mutex_lock(&rgb_scaler->lock);
+
+	mchp_rgb_scaler_write(rgb_scaler, MCHP_RGB_SCALER_INPUT_HRES, in_width);
+	mchp_rgb_scaler_write(rgb_scaler, MCHP_RGB_SCALER_INPUT_VRES, in_height);
+	mchp_rgb_scaler_write(rgb_scaler, MCHP_RGB_SCALER_OUTPUT_HRES, out_width);
+	mchp_rgb_scaler_write(rgb_scaler, MCHP_RGB_SCALER_OUTPUT_VRES, out_height);
+	mchp_rgb_scaler_write(rgb_scaler, MCHP_RGB_SCALER_FACTOR_H, scale_factor_h);
+	mchp_rgb_scaler_write(rgb_scaler, MCHP_RGB_SCALER_FACTOR_V, scale_factor_v);
+
+	mutex_unlock(&rgb_scaler->lock);
+}
+
+static int mchp_rgb_scaler_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct mchp_rgb_scaler_device *rgb_scaler = to_scaler(subdev);
+
+	if (!enable) {
+		mchp_rgb_scaler_clr(rgb_scaler, MCHP_RGB_SCALER_CTRL, MCHP_RGB_SCALER_CTRL_START);
+		return 0;
+	}
+
+	mchp_rgb_scaler_set(rgb_scaler, MCHP_RGB_SCALER_CTRL, MCHP_RGB_SCALER_CTRL_RESET);
+
+	mchp_set_scale_factor(rgb_scaler);
+
+	mchp_rgb_scaler_set(rgb_scaler, MCHP_RGB_SCALER_CTRL, MCHP_RGB_SCALER_CTRL_START);
+
+	return 0;
+}
+
+static int mchp_rgb_scaler_enum_frame_size(struct v4l2_subdev *subdev,
+					   struct v4l2_subdev_state *sd_state,
+					   struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	format = v4l2_subdev_get_try_format(subdev, sd_state, fse->pad);
+
+	if (fse->index || fse->code != format->code)
+		return -EINVAL;
+
+	fse->min_width = MCHP_RGB_SCALER_MIN_WIDTH;
+	fse->max_width = MCHP_RGB_SCALER_MAX_WIDTH;
+	fse->min_height = MCHP_RGB_SCALER_MIN_HEIGHT;
+	fse->max_height = MCHP_RGB_SCALER_MAX_HEIGHT;
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__mchp_rgb_scaler_get_pad_format(struct mchp_rgb_scaler_device *rgb_scaler,
+				 struct v4l2_subdev_state *sd_state,
+				 unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&rgb_scaler->subdev,
+						    sd_state, pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &rgb_scaler->formats[pad];
+		break;
+	default:
+		format = NULL;
+		break;
+	}
+
+	return format;
+}
+
+static struct v4l2_rect *
+__mchp_rgb_scaler_get_crop(struct mchp_rgb_scaler_device *rgb_scaler,
+			   struct v4l2_subdev_state *sd_state, u32 which)
+{
+	struct v4l2_rect *crop;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		crop = v4l2_subdev_get_try_crop(&rgb_scaler->subdev,
+						sd_state,
+						MVC_PAD_SINK);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		crop = &rgb_scaler->crop;
+		break;
+	default:
+		crop = NULL;
+		break;
+	}
+
+	return crop;
+}
+
+static int mchp_rgb_scaler_get_format(struct v4l2_subdev *subdev,
+				      struct v4l2_subdev_state *sd_state,
+				      struct v4l2_subdev_format *fmt)
+{
+	struct mchp_rgb_scaler_device *rgb_scaler = to_scaler(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __mchp_rgb_scaler_get_pad_format(rgb_scaler, sd_state, fmt->pad,
+						  fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static void mchp_rgb_scaler_try_crop(const struct v4l2_mbus_framefmt *sink,
+				     struct v4l2_rect *crop)
+{
+	crop->left = min_t(u32, crop->left, sink->width - MCHP_RGB_SCALER_MIN_WIDTH);
+	crop->top = min_t(u32, crop->top, sink->height - MCHP_RGB_SCALER_MIN_HEIGHT);
+	crop->width = clamp_t(u32, crop->width, MCHP_RGB_SCALER_MIN_WIDTH,
+			      sink->width - crop->left);
+	crop->height = clamp_t(u32, crop->height, MCHP_RGB_SCALER_MIN_HEIGHT,
+			       sink->height - crop->top);
+}
+
+static int mchp_rgb_scaler_set_format(struct v4l2_subdev *subdev,
+				      struct v4l2_subdev_state *sd_state,
+				      struct v4l2_subdev_format *fmt)
+{
+	struct mchp_rgb_scaler_device *rgb_scaler = to_scaler(subdev);
+	struct v4l2_mbus_framefmt *format;
+	struct v4l2_rect *crop;
+
+	format = __mchp_rgb_scaler_get_pad_format(rgb_scaler, sd_state, fmt->pad,
+						  fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	format->width = clamp_t(unsigned int, fmt->format.width,
+				MCHP_RGB_SCALER_MIN_WIDTH, MCHP_RGB_SCALER_MAX_WIDTH);
+	format->height = clamp_t(unsigned int, fmt->format.height,
+				 MCHP_RGB_SCALER_MIN_HEIGHT, MCHP_RGB_SCALER_MAX_HEIGHT);
+
+	fmt->format = *format;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		return 0;
+
+	if (fmt->pad == MVC_PAD_SINK) {
+		/* Set the crop rectangle to the full frame */
+		crop = __mchp_rgb_scaler_get_crop(rgb_scaler, sd_state, fmt->which);
+		if (!crop)
+			return -EINVAL;
+		crop->left = 0;
+		crop->top = 0;
+		crop->width = fmt->format.width;
+		crop->height = fmt->format.height;
+		rgb_scaler->formats[MVC_PAD_SOURCE].width = crop->width;
+		rgb_scaler->formats[MVC_PAD_SOURCE].height = crop->height;
+	}
+
+	return 0;
+}
+
+static int mchp_rgb_scaler_get_selection(struct v4l2_subdev *subdev,
+					 struct v4l2_subdev_state *sd_state,
+					 struct v4l2_subdev_selection *sel)
+{
+	struct mchp_rgb_scaler_device *rgb_scaler = to_scaler(subdev);
+	struct v4l2_mbus_framefmt *format;
+	struct v4l2_rect *crop;
+
+	if (sel->pad != MVC_PAD_SINK)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		format = __mchp_rgb_scaler_get_pad_format(rgb_scaler, sd_state,
+							  MVC_PAD_SINK,
+							  sel->which);
+		if (!format)
+			return -EINVAL;
+
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = format->width;
+		sel->r.height = format->height;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		crop = __mchp_rgb_scaler_get_crop(rgb_scaler, sd_state, sel->which);
+		if (!crop)
+			return -EINVAL;
+		sel->r = *crop;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int mchp_rgb_scaler_set_selection(struct v4l2_subdev *subdev,
+					 struct v4l2_subdev_state *sd_state,
+					 struct v4l2_subdev_selection *sel)
+{
+	struct mchp_rgb_scaler_device *rgb_scaler = to_scaler(subdev);
+	struct v4l2_mbus_framefmt *format;
+	struct v4l2_rect *crop;
+
+	if (sel->target != V4L2_SEL_TGT_CROP || sel->pad != MVC_PAD_SINK)
+		return -EINVAL;
+
+	format = __mchp_rgb_scaler_get_pad_format(rgb_scaler, sd_state, MVC_PAD_SINK,
+						  sel->which);
+	if (!format)
+		return -EINVAL;
+
+	mchp_rgb_scaler_try_crop(format, &sel->r);
+	crop = __mchp_rgb_scaler_get_crop(rgb_scaler, sd_state, sel->which);
+	if (!crop)
+		return -EINVAL;
+
+	*crop = sel->r;
+
+	rgb_scaler->formats[MVC_PAD_SOURCE].width = crop->width;
+	rgb_scaler->formats[MVC_PAD_SOURCE].height = crop->height;
+
+	mchp_set_scale_factor(rgb_scaler);
+
+	return 0;
+}
+
+static int mchp_rgb_scaler_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	struct mchp_rgb_scaler_device *rgb_scaler = to_scaler(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	/* Initialize with default formats */
+	format = v4l2_subdev_get_try_format(subdev, fh->state, MVC_PAD_SINK);
+	*format = rgb_scaler->default_formats[MVC_PAD_SINK];
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state, MVC_PAD_SOURCE);
+	*format = rgb_scaler->default_formats[MVC_PAD_SOURCE];
+
+	return 0;
+}
+
+static int mchp_rgb_scaler_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops mchp_rgb_scaler_video_ops = {
+	.s_stream = mchp_rgb_scaler_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops mchp_rgb_scaler_pad_ops = {
+	.enum_mbus_code		= mvc_enum_mbus_code,
+	.enum_frame_size	= mchp_rgb_scaler_enum_frame_size,
+	.get_fmt		= mchp_rgb_scaler_get_format,
+	.set_fmt		= mchp_rgb_scaler_set_format,
+	.get_selection		= mchp_rgb_scaler_get_selection,
+	.set_selection		= mchp_rgb_scaler_set_selection,
+};
+
+static const struct v4l2_subdev_ops mchp_rgb_scaler_ops = {
+	.video  = &mchp_rgb_scaler_video_ops,
+	.pad    = &mchp_rgb_scaler_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops mchp_rgb_scaler_internal_ops = {
+	.open	= mchp_rgb_scaler_open,
+	.close	= mchp_rgb_scaler_close,
+};
+
+static const struct media_entity_operations mchp_rgb_scaler_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int mchp_rgb_scaler_init_formats(struct mchp_rgb_scaler_device *rgb_scaler)
+{
+	struct device *dev = rgb_scaler->dev;
+	const struct mvideo_format *vip_format;
+
+	vip_format = mvc_get_format_by_vf_code(MCHP_RGB_SCALER_DEF_FORMAT);
+	if (IS_ERR(vip_format))
+		return dev_err_probe(dev, PTR_ERR(vip_format), "invalid format");
+
+	rgb_scaler->vip_formats[MVC_PAD_SINK] = vip_format;
+	rgb_scaler->vip_formats[MVC_PAD_SOURCE] = vip_format;
+
+	return 0;
+}
+
+static int mchp_rgb_scaler_probe(struct platform_device *pdev)
+{
+	struct mchp_rgb_scaler_device *rgb_scaler;
+	struct v4l2_subdev *subdev;
+	struct v4l2_mbus_framefmt *default_format;
+	int ret;
+
+	rgb_scaler = devm_kzalloc(&pdev->dev, sizeof(*rgb_scaler), GFP_KERNEL);
+	if (!rgb_scaler)
+		return -ENOMEM;
+
+	rgb_scaler->dev = &pdev->dev;
+
+	ret = mchp_rgb_scaler_init_formats(rgb_scaler);
+	if (ret < 0)
+		return ret;
+
+	rgb_scaler->iomem = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(rgb_scaler->iomem))
+		return PTR_ERR(rgb_scaler->iomem);
+
+	mutex_init(&rgb_scaler->lock);
+	mchp_rgb_scaler_set(rgb_scaler, MCHP_RGB_SCALER_CTRL, MCHP_RGB_SCALER_CTRL_RESET);
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &rgb_scaler->subdev;
+	v4l2_subdev_init(subdev, &mchp_rgb_scaler_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &mchp_rgb_scaler_internal_ops;
+	strscpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, rgb_scaler);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	/* Initialize default and active formats */
+	default_format = &rgb_scaler->default_formats[MVC_PAD_SINK];
+	default_format->code = rgb_scaler->vip_formats[MVC_PAD_SINK]->code;
+	default_format->field = V4L2_FIELD_NONE;
+	default_format->colorspace = V4L2_COLORSPACE_SRGB;
+	default_format->width = MCHP_RGB_SCALER_DEFAULT_WIDTH;
+	default_format->height = MCHP_RGB_SCALER_DEFAULT_HEIGHT;
+
+	rgb_scaler->formats[MVC_PAD_SINK] = *default_format;
+
+	default_format = &rgb_scaler->default_formats[MVC_PAD_SOURCE];
+	*default_format = rgb_scaler->default_formats[MVC_PAD_SINK];
+	default_format->width = MCHP_RGB_SCALER_DEFAULT_WIDTH;
+	default_format->height = MCHP_RGB_SCALER_DEFAULT_HEIGHT;
+
+	rgb_scaler->formats[MVC_PAD_SOURCE] = *default_format;
+
+	rgb_scaler->pads[MVC_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	rgb_scaler->pads[MVC_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	subdev->entity.ops = &mchp_rgb_scaler_media_ops;
+
+	ret = media_entity_pads_init(&subdev->entity, 2, rgb_scaler->pads);
+	if (ret < 0)
+		return ret;
+
+	platform_set_drvdata(pdev, rgb_scaler);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	return 0;
+
+error:
+	media_entity_cleanup(&subdev->entity);
+
+	return ret;
+}
+
+static int mchp_rgb_scaler_remove(struct platform_device *pdev)
+{
+	struct mchp_rgb_scaler_device *rgb_scaler = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &rgb_scaler->subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	media_entity_cleanup(&subdev->entity);
+
+	return 0;
+}
+
+static const struct of_device_id mchp_rgb_scaler_of_id_table[] = {
+	{ .compatible = "microchip,rgb-scaler-rtl-v1" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, mchp_rgb_scaler_of_id_table);
+
+static struct platform_driver mchp_rgb_scaler_driver = {
+	.driver			= {
+		.name		= "microchip-rgb-scaler",
+		.of_match_table	= mchp_rgb_scaler_of_id_table,
+	},
+	.probe			= mchp_rgb_scaler_probe,
+	.remove			= mchp_rgb_scaler_remove,
+};
+
+module_platform_driver(mchp_rgb_scaler_driver);
+
+MODULE_DESCRIPTION("Microchip RGB Scaler Driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/microchip/microchip-vcpp.c	2024-12-04 16:41:28.070865300 +0900
@@ -0,0 +1,1414 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Microchip Video Capture Pipeline Processing (vcpp) Driver.
+ *
+ * Copyright (C) 2022-2023 Microchip Technology Inc. and its subsidiaries
+ * Author: Shravan Chippa <shavan.chippa@microchip.com>
+ *
+ */
+
+#include <linux/bitfield.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/dma-map-ops.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kmod.h>
+#include <linux/mutex.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/of_address.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-mc.h>
+#include <media/videobuf2-v4l2.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "microchip-common.h"
+
+#define MCHP_VCPP_DRV_NAME			"mchp-vcpp"
+
+#define MCHP_VCPP_DEF_WIDTH			1920
+#define MCHP_VCPP_DEF_HEIGHT			1080
+
+/* Minimum and maximum widths are expressed in bytes */
+#define MCHP_VCPP_MIN_WIDTH			256U
+#define MCHP_VCPP_MAX_WIDTH			2048U
+#define MCHP_VCPP_MIN_HEIGHT			256U
+#define MCHP_VCPP_MAX_HEIGHT			1080U
+#define MCHP_VCPP_DEF_FORMAT			V4L2_PIX_FMT_YUYV
+
+#define MCHP_VCPP_IP_VER			0x00
+#define MCHP_VCPP_CTRL_REG			0x04
+#define MCHP_VCPP_CORE_ENABLE			BIT(0)
+#define MCHP_VCPP_CORE_RESET			BIT(1)
+#define MCHP_VCPP_FLASH_FIFO			BIT(2)
+
+#define MCHP_VCPP_GLBL_INT_EN			0x08
+#define MCHP_VCPP_GLBL_INT_EN_BIT		BIT(0)
+
+#define MCHP_VCPP_INT_STATUS			0x0C
+#define MCHP_VCPP_INT_STATUS_EOF		BIT(0)
+
+#define MCHP_VCPP_INT_EN			0x10
+#define MCHP_VCPP_INT_EN_EOF			BIT(0)
+#define MCHP_VCPP_INT_EN_FIFO_MT		(2 << 0)
+#define MCHP_VCPP_INT_EN_FIFO_FULL		(3 << 0)
+
+#define MCHP_VCPP_FRAME_RESOLUTION		0x14
+#define MCHP_VCPP_LINE_GAP			0x18
+#define MCHP_VCPP_BUFF_ADDR_FIFO_DATA		0x1C
+#define MCHP_VCPP_BUFF_ADDR_FIFO_RDATA_COUNT	0x20
+#define MCHP_VCPP_FRAME_SIZE_FIFO_DATA_RD	0x24
+#define MCHP_VCPP_MEDIA_PIPE_START		0x28
+#define MCHP_VCPP_MEDIA_PIPE_START_0		BIT(0)
+
+#define MCHP_VCPP_FRAME_START			0x1
+#define MCHP_VCPP_FRAME_STOP			0x0
+
+#define MCHP_VCPP_MAX_FRAMES			8
+
+/* The compression ratio is calculated for every 60 frames */
+#define MCHP_VCPP_CR_MAX_FRAMES_RESET_COUNT	60
+#define MCHP_VCPP_CR_MAX_FRAMES_INIT		50
+#define MCHP_VCPP_CR_MAX_ARRAY			6
+
+#define MCHP_VCPP_NUM_CTRLS			1
+
+/* Minimum wait time for camera to stabilize */
+#define MCHP_VCPP_DELAYED_CAM_M_SEC		100
+
+enum mchp_vcpp_state {
+	VCPP_STOPPED = 0,
+	VCPP_WAIT_FOR_BUFFER,
+	VCPP_RUNNING,
+};
+
+/**
+ * struct mchp_vcpp_buffer - buffer for one video frame
+ * @vb:		video buffer information struct vb2_v4l2_buffer
+ * @list:	list of all requested buffers from user space
+ * @paddr:	physical address of buffer
+ * @size:	size of buffer
+ * @prepared:	status of buffer
+ */
+struct mchp_vcpp_buffer {
+	struct vb2_v4l2_buffer vb;
+	struct list_head list;
+	dma_addr_t paddr;
+	size_t size;
+	bool prepared;
+};
+
+/**
+ * struct mchp_vcpp_compression_ratio - for compression calculation
+ * @frame_size:		accumulated frames size
+ * @frame_size_index:	accumulated present frames size index
+ * @frame_count:	present frame count
+ */
+struct mchp_vcpp_compression_ratio {
+	u32 frame_size[MCHP_VCPP_CR_MAX_ARRAY];
+	u32 frame_size_index;
+	u32 frame_count;
+};
+
+/**
+ * struct mchp_vcpp_fpga - V4L2 device context
+ * @base:		pointer to control register
+ * @pdev:		platform device
+ * @dev:		device
+ * @active:		current buffer in queue
+ * @reset_gpio:		sensor fabric rest
+ * @v4l2_dev:		top-level v4l2 device struct
+ * @vdev:		video node structure
+ * @format:		active V4L2 pixel format
+ * @fmtinfo:		format information corresponding to the active @format
+ * @queue:		vb2 video capture queue
+ * @lock:		mutex lock for vb2 buffs
+ * @qlock:		spinlock controlling access to buf_list and sequence
+ * @buf_list:		list of buffers queued for DMA
+ * @subdev_entities:	subdevice list
+ * @cambuf:		struct cam_buffer
+ * @notifier:		V4L2 asynchronous subdevs notifier
+ * @mdev:		media device
+ * @vid_cap_pad:	media pad for the video device entity
+ * @h264_ratio		struct mchp_vcpp_compression
+ * @ctrl_handler:	control handler structure
+ * @state:		state of buffers
+ * @irq:		external IRQ for new frame
+ * @sequence:		frame sequence counter
+ */
+struct mchp_vcpp_fpga {
+	void __iomem *base;
+	struct platform_device *pdev;
+	struct device *dev;
+	struct mchp_vcpp_buffer *active;
+	struct gpio_desc *reset_gpio;
+	struct clk_bulk_data *clks;
+	struct v4l2_device v4l2_dev;
+	struct video_device vdev;
+	struct v4l2_format format;
+	const struct mvideo_format *fmtinfo;
+	struct vb2_queue queue;
+	struct mutex lock; /* vb2 buffer lock */
+	spinlock_t qlock;
+	struct list_head buf_list;
+	struct list_head subdev_entities;
+	struct v4l2_async_notifier notifier;
+	struct media_device mdev;
+	struct media_pad vid_cap_pad;
+	struct mchp_vcpp_compression_ratio h264_ratio;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *compression_ratio_ctrl;
+	enum mchp_vcpp_state state;
+	int irq;
+	int sequence;
+};
+
+struct mchp_vcpp_graph_entity {
+	struct v4l2_async_connection asc;
+	struct media_entity *entity;
+	struct v4l2_subdev *subdev;
+};
+
+static const struct clk_bulk_data mchp_vcpp_clks[] = {
+	{ .id = "axi" },
+	{ .id = "video" },
+};
+
+static inline struct mchp_vcpp_graph_entity *
+to_mchp_vcpp_entity(struct v4l2_async_connection *asc)
+{
+	return container_of(asc, struct mchp_vcpp_graph_entity, asc);
+}
+
+static struct mchp_vcpp_graph_entity *
+mchp_vcpp_graph_find_entity(struct mchp_vcpp_fpga *mchp_vcpp,
+			    const struct fwnode_handle *fwnode)
+{
+	struct mchp_vcpp_graph_entity *entity;
+	struct v4l2_async_connection *asc;
+	struct list_head *lists[] = {
+		&mchp_vcpp->notifier.done_list,
+		&mchp_vcpp->notifier.waiting_list
+	};
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(lists); i++) {
+		list_for_each_entry(asc, lists[i], asc_entry) {
+			entity = to_mchp_vcpp_entity(asc);
+			if (entity->asc.match.fwnode == fwnode)
+				return entity;
+		}
+	}
+
+	return NULL;
+}
+
+static struct v4l2_subdev *
+mchp_vcpp_remote_subdev(struct media_pad *local, u32 *pad)
+{
+	struct media_pad *remote;
+
+	remote = media_pad_remote_pad_first(local);
+	if (!remote || !is_media_entity_v4l2_subdev(remote->entity))
+		return NULL;
+
+	if (pad)
+		*pad = remote->index;
+
+	return media_entity_to_v4l2_subdev(remote->entity);
+}
+
+static int mchp_vcpp_verify_format(struct mchp_vcpp_fpga *mchp_vcpp)
+{
+	struct v4l2_subdev_format fmt= {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+	};
+	struct v4l2_subdev *subdev;
+	int ret;
+
+	subdev = mchp_vcpp_remote_subdev(&mchp_vcpp->vid_cap_pad, &fmt.pad);
+	if (!subdev)
+		return -EPIPE;
+
+	ret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);
+	if (ret < 0)
+		return ret == -ENOIOCTLCMD ? -EINVAL : ret;
+
+	if (mchp_vcpp->fmtinfo->code != fmt.format.code ||
+	    mchp_vcpp->format.fmt.pix.height != fmt.format.height ||
+	    mchp_vcpp->format.fmt.pix.width != fmt.format.width)
+		return -EINVAL;
+
+	return 0;
+}
+
+static void mchp_vcpp_buffer_done(struct mchp_vcpp_fpga *mchp_vcpp,
+				  struct mchp_vcpp_buffer *buf,
+				  size_t bytesused,
+				  int err)
+{
+	struct vb2_v4l2_buffer *vbuf;
+
+	if (!buf)
+		return;
+
+	list_del_init(&buf->list);
+	vbuf = &buf->vb;
+	vbuf->sequence = mchp_vcpp->sequence++;
+	vbuf->field = V4L2_FIELD_NONE;
+	vbuf->vb2_buf.timestamp = ktime_get_ns();
+
+	vb2_set_plane_payload(&vbuf->vb2_buf, 0, bytesused);
+
+	vb2_buffer_done(&vbuf->vb2_buf,
+			err ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);
+
+	dev_dbg(mchp_vcpp->dev, "Buffer[%d] done seq=%d, bytesused=%zu\n",
+		vbuf->vb2_buf.index, vbuf->sequence, bytesused);
+
+	mchp_vcpp->active = NULL;
+}
+
+/*
+ * Compression ratio is the percentage of compressed image over the actual image.
+ * The YUV420 requires 3 bytes per 2 pixels, or 1.5 bytes per pixel, because
+ * groups of pixels share a single color value.
+ * The compression ratio can be calculated as:
+ * (width * height * accumulated-frame-count * bytes-per-pixel) / accumulated-frame-size
+ */
+static u32 compression_ratio_calc(u32 hres, u32 vres, u32 accumulated_frame_size)
+{
+	return ((hres * vres * MCHP_VCPP_CR_MAX_FRAMES_RESET_COUNT * 3) /
+		(accumulated_frame_size)) / 2;
+}
+
+static irqreturn_t mchp_vcpp_irq_ext(int irq, void *dev_id)
+{
+	struct mchp_vcpp_fpga *mchp_vcpp = dev_id;
+	u32 irq_status;
+	unsigned long flags;
+
+	irq_status = readl_relaxed(mchp_vcpp->base + MCHP_VCPP_INT_STATUS);
+
+	spin_lock_irqsave(&mchp_vcpp->qlock, flags);
+
+	if (!(irq_status & MCHP_VCPP_INT_STATUS_EOF)) {
+		writel_relaxed(0xFF, mchp_vcpp->base + MCHP_VCPP_INT_STATUS);
+		spin_unlock_irqrestore(&mchp_vcpp->qlock, flags);
+		return IRQ_NONE;
+	} else {
+		writel_relaxed(MCHP_VCPP_INT_EN_EOF, mchp_vcpp->base + MCHP_VCPP_INT_STATUS);
+	}
+
+	if (mchp_vcpp->state != VCPP_RUNNING) {
+		spin_unlock_irqrestore(&mchp_vcpp->qlock, flags);
+		return IRQ_HANDLED;
+	}
+
+	spin_unlock_irqrestore(&mchp_vcpp->qlock, flags);
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t mchp_vcpp_irq_thread_fn(int irq, void *dev_id)
+{
+	struct mchp_vcpp_fpga *mchp_vcpp = dev_id;
+	struct mchp_vcpp_buffer *buf;
+	struct v4l2_pix_format *pix = &mchp_vcpp->format.fmt.pix;
+	struct mchp_vcpp_compression_ratio *h264_ratio = &mchp_vcpp->h264_ratio;
+	struct v4l2_subdev_format fmt = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+	};
+	struct v4l2_subdev *subdev;
+	int ret, buf_size, i;
+	int *frame_size_index = &h264_ratio->frame_size_index;
+
+	spin_lock_irq(&mchp_vcpp->qlock);
+
+	if (list_empty(&mchp_vcpp->buf_list)) {
+		dev_dbg(mchp_vcpp->dev,
+			"Capture restart is deferred to next buffer queue\n");
+		mchp_vcpp->state = VCPP_WAIT_FOR_BUFFER;
+		spin_unlock_irq(&mchp_vcpp->qlock);
+		return IRQ_HANDLED;
+	}
+
+	buf = list_entry(mchp_vcpp->buf_list.next,
+			 struct mchp_vcpp_buffer, list);
+
+	mchp_vcpp->active = buf;
+
+	spin_unlock_irq(&mchp_vcpp->qlock);
+
+	if (mchp_vcpp->fmtinfo->fourcc == V4L2_PIX_FMT_H264) {
+		buf_size = readl_relaxed(mchp_vcpp->base + MCHP_VCPP_FRAME_SIZE_FIFO_DATA_RD);
+		spin_lock_irq(&mchp_vcpp->qlock);
+		mchp_vcpp_buffer_done(mchp_vcpp, buf, buf_size, 0);
+		spin_unlock_irq(&mchp_vcpp->qlock);
+		h264_ratio->frame_count++;
+		h264_ratio->frame_size[*frame_size_index] += buf_size;
+
+		if (h264_ratio->frame_count % 10 == 0)
+			(*frame_size_index)++;
+
+		if (*frame_size_index == MCHP_VCPP_CR_MAX_ARRAY)
+			*frame_size_index = 0;
+
+		if (h264_ratio->frame_count == MCHP_VCPP_CR_MAX_FRAMES_RESET_COUNT) {
+			u32 accumulated_frame_size = 0, compression_ratio, hres, vres;
+
+			for (i = 0; i < MCHP_VCPP_CR_MAX_ARRAY; i++)
+				accumulated_frame_size += h264_ratio->frame_size[i];
+
+			subdev = mchp_vcpp_remote_subdev(&mchp_vcpp->vid_cap_pad, &fmt.pad);
+			if (!subdev)
+				return -EPIPE;
+
+			ret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);
+			if (ret < 0)
+				return ret == -ENOIOCTLCMD ? -EINVAL : ret;
+
+			hres = fmt.format.width;
+			vres = fmt.format.height;
+
+			compression_ratio = compression_ratio_calc(hres, vres,
+								   accumulated_frame_size);
+			__v4l2_ctrl_s_ctrl(mchp_vcpp->compression_ratio_ctrl, compression_ratio);
+
+			h264_ratio->frame_count = MCHP_VCPP_CR_MAX_FRAMES_INIT;
+			h264_ratio->frame_size[*frame_size_index] = 0;
+		}
+	} else {
+		spin_lock_irq(&mchp_vcpp->qlock);
+		mchp_vcpp_buffer_done(mchp_vcpp, buf,
+				      pix->width * pix->height * mchp_vcpp->fmtinfo->bpp, 0);
+		spin_unlock_irq(&mchp_vcpp->qlock);
+	}
+
+	spin_lock_irq(&mchp_vcpp->qlock);
+
+	if (list_empty(&mchp_vcpp->buf_list)) {
+		dev_dbg(mchp_vcpp->dev,
+			"Capture restart is deferred to next buffer queue\n");
+		mchp_vcpp->state = VCPP_WAIT_FOR_BUFFER;
+		spin_unlock_irq(&mchp_vcpp->qlock);
+		return IRQ_HANDLED;
+	}
+
+	spin_unlock_irq(&mchp_vcpp->qlock);
+
+	return IRQ_HANDLED;
+}
+
+static int mchp_vcpp_pipeline_set_stream(struct mchp_vcpp_fpga *mchp_vcpp, bool state)
+{
+	struct media_entity *entity = &mchp_vcpp->vdev.entity;
+	struct v4l2_subdev *subdev;
+	struct media_pad *pad;
+	int ret;
+
+	/* Start/stop all entities within pipeline */
+	while (1) {
+		pad = &entity->pads[0];
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			break;
+
+		pad = media_pad_remote_pad_first(pad);
+		if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+			break;
+
+		entity = pad->entity;
+		subdev = media_entity_to_v4l2_subdev(entity);
+
+		ret = v4l2_subdev_call(subdev, video, s_stream, state);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			dev_err(mchp_vcpp->dev, "%s: \"%s\" failed to %s streaming (%d)\n",
+				__func__, subdev->name,
+				state ? "start" : "stop", ret);
+			return ret;
+		}
+
+		dev_dbg(mchp_vcpp->dev, "\"%s\" is %s\n",
+			subdev->name, state ? "started" : "stopped");
+	}
+
+	return 0;
+}
+
+static int mchp_vcpp_queue_setup(struct vb2_queue *vq,
+				 unsigned int *nbuffers, unsigned int *nplanes,
+				 unsigned int sizes[], struct device *alloc_devs[])
+{
+	struct mchp_vcpp_fpga *mchp_vcpp = vb2_get_drv_priv(vq);
+	unsigned int size;
+
+	if (*nbuffers > MCHP_VCPP_MAX_FRAMES) {
+		dev_dbg(mchp_vcpp->dev,
+			"output frame count too high (%d), cut to %d\n",
+				 *nbuffers, MCHP_VCPP_MAX_FRAMES);
+		*nbuffers = MCHP_VCPP_MAX_FRAMES;
+	}
+
+	size = mchp_vcpp->format.fmt.pix.sizeimage;
+
+	if (*nplanes)
+		return sizes[0] < size ? -EINVAL : 0;
+
+	*nplanes = 1;
+	sizes[0] = size;
+
+	dev_dbg(mchp_vcpp->dev, "Setup queue, count=%d, size=%d\n",
+		*nbuffers, size);
+
+	return 0;
+}
+
+static int mchp_vcpp_buffer_prepare(struct vb2_buffer *vb)
+{
+	struct mchp_vcpp_fpga *mchp_vcpp = vb2_get_drv_priv(vb->vb2_queue);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct mchp_vcpp_buffer *buf =
+			container_of(vbuf, struct mchp_vcpp_buffer, vb);
+	unsigned int size;
+
+	size = mchp_vcpp->format.fmt.pix.sizeimage;
+
+	if (vb2_plane_size(vb, 0) < size) {
+		dev_err(mchp_vcpp->dev,
+			"data will not fit into plane (%lu < %u)\n",
+			vb2_plane_size(vb, 0), size);
+		return -EINVAL;
+	}
+
+	if (!buf->prepared) {
+		buf->paddr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
+		buf->size = vb2_plane_size(&buf->vb.vb2_buf, 0);
+		vb2_set_plane_payload(&buf->vb.vb2_buf, 0, buf->size);
+		buf->prepared = true;
+	}
+
+	return 0;
+}
+
+static void mchp_vcpp_buffer_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct mchp_vcpp_fpga *mchp_vcpp = vb2_get_drv_priv(vb->vb2_queue);
+	struct mchp_vcpp_buffer *buf =
+				container_of(vbuf, struct mchp_vcpp_buffer, vb);
+
+	spin_lock_irq(&mchp_vcpp->qlock);
+	list_add_tail(&buf->list, &mchp_vcpp->buf_list);
+	if (mchp_vcpp->state == VCPP_WAIT_FOR_BUFFER) {
+		mchp_vcpp->state = VCPP_RUNNING;
+		mchp_vcpp->active = buf;
+	}
+
+	writel_relaxed(buf->paddr >> 6, mchp_vcpp->base + MCHP_VCPP_BUFF_ADDR_FIFO_DATA);
+
+	spin_unlock_irq(&mchp_vcpp->qlock);
+}
+
+static void mchp_return_all_buffers(struct mchp_vcpp_fpga *mchp_vcpp,
+				    enum vb2_buffer_state state)
+{
+	struct mchp_vcpp_buffer *buf, *node;
+
+	list_for_each_entry_safe(buf, node, &mchp_vcpp->buf_list, list) {
+		vb2_buffer_done(&buf->vb.vb2_buf, state);
+		list_del(&buf->list);
+	}
+
+	mchp_vcpp->active = NULL;
+}
+
+static int mchp_vcpp_start_streaming(struct vb2_queue *vq, unsigned int count)
+{
+	struct mchp_vcpp_fpga *mchp_vcpp = vb2_get_drv_priv(vq);
+	int ret;
+
+	ret = mchp_vcpp_verify_format(mchp_vcpp);
+	if (ret < 0) {
+		dev_err(mchp_vcpp->dev, "%s: Failed to mchp_vcpp_verify_format (%d)\n",
+			__func__, ret);
+		goto err_free_buffers;
+	}
+
+	ret = v4l2_pipeline_pm_get(&mchp_vcpp->vdev.entity);
+	if (ret) {
+		dev_err(mchp_vcpp->dev, "open cif pipeline failed %d\n", ret);
+		return ret;
+	}
+
+	ret = mchp_vcpp_pipeline_set_stream(mchp_vcpp, true);
+	if (ret < 0) {
+		dev_err(mchp_vcpp->dev, "%s: Failed to mchp_vcpp_pipeline_start (%d)\n",
+			__func__, ret);
+		return ret;
+	}
+
+	writel_relaxed(MCHP_VCPP_MEDIA_PIPE_START_0, mchp_vcpp->base + MCHP_VCPP_MEDIA_PIPE_START);
+	writel_relaxed(MCHP_VCPP_GLBL_INT_EN_BIT, mchp_vcpp->base + MCHP_VCPP_GLBL_INT_EN);
+	writel_relaxed(MCHP_VCPP_INT_EN_EOF, mchp_vcpp->base + MCHP_VCPP_INT_EN);
+
+	writel_relaxed(mchp_vcpp->format.fmt.pix.width,	mchp_vcpp->base + MCHP_VCPP_LINE_GAP);
+
+	writel_relaxed(MCHP_VCPP_FRAME_STOP, mchp_vcpp->base + MCHP_VCPP_CTRL_REG);
+	mdelay(MCHP_VCPP_DELAYED_CAM_M_SEC);
+	writel_relaxed(MCHP_VCPP_FRAME_START, mchp_vcpp->base + MCHP_VCPP_CTRL_REG);
+
+	mchp_vcpp->sequence = 0;
+
+	ret = request_threaded_irq(mchp_vcpp->irq, mchp_vcpp_irq_ext,
+				   mchp_vcpp_irq_thread_fn, IRQF_NO_SUSPEND,
+				   KBUILD_MODNAME, mchp_vcpp);
+
+	if (ret) {
+		dev_err(mchp_vcpp->dev, "request threaded irq failed %d\n",
+			ret);
+		goto err_free_buffers;
+	}
+
+	spin_lock_irq(&mchp_vcpp->qlock);
+
+	if (list_empty(&mchp_vcpp->buf_list)) {
+		dev_dbg(mchp_vcpp->dev,
+			"Start streaming is deferred to next buffer queue\n");
+		mchp_vcpp->state = VCPP_WAIT_FOR_BUFFER;
+		spin_unlock_irq(&mchp_vcpp->qlock);
+		return 0;
+	}
+
+	mchp_vcpp->state = VCPP_RUNNING;
+
+	spin_unlock_irq(&mchp_vcpp->qlock);
+
+	return 0;
+
+err_free_buffers:
+	spin_lock_irq(&mchp_vcpp->qlock);
+	mchp_return_all_buffers(mchp_vcpp, VB2_BUF_STATE_QUEUED);
+	spin_unlock_irq(&mchp_vcpp->qlock);
+
+	return ret;
+}
+
+static void mchp_vcpp_stop_streaming(struct vb2_queue *vq)
+{
+	struct mchp_vcpp_fpga *mchp_vcpp = vb2_get_drv_priv(vq);
+
+	writel_relaxed(MCHP_VCPP_FRAME_STOP, mchp_vcpp->base + MCHP_VCPP_CTRL_REG);
+
+	free_irq(mchp_vcpp->irq, mchp_vcpp);
+
+	spin_lock_irq(&mchp_vcpp->qlock);
+
+	mchp_return_all_buffers(mchp_vcpp, VB2_BUF_STATE_QUEUED);
+
+	mchp_vcpp->active = NULL;
+	mchp_vcpp->state = VCPP_STOPPED;
+
+	spin_unlock_irq(&mchp_vcpp->qlock);
+
+	writel_relaxed(MCHP_VCPP_CORE_RESET, mchp_vcpp->base + MCHP_VCPP_CTRL_REG);
+
+	mchp_vcpp_pipeline_set_stream(mchp_vcpp, false);
+}
+
+static const struct vb2_ops mchp_vcpp_qops = {
+	.queue_setup		= mchp_vcpp_queue_setup,
+	.buf_prepare		= mchp_vcpp_buffer_prepare,
+	.buf_queue		= mchp_vcpp_buffer_queue,
+	.start_streaming	= mchp_vcpp_start_streaming,
+	.stop_streaming		= mchp_vcpp_stop_streaming,
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
+};
+
+static int mchp_vcpp_querycap(struct file *file, void *priv,
+			      struct v4l2_capability *cap)
+{
+	strscpy(cap->driver, MCHP_VCPP_DRV_NAME, sizeof(cap->driver));
+	strscpy(cap->card, "MCHP Camera Media Pipeline", sizeof(cap->card));
+	strscpy(cap->bus_info, "platform:mchp-vcpp", sizeof(cap->bus_info));
+
+	return 0;
+}
+
+static void __mchp_vcpp_try_format(struct mchp_vcpp_fpga *mchp_vcpp,
+				   struct v4l2_pix_format *pix,
+				   const struct mvideo_format **fmtinfo)
+{
+	const struct mvideo_format *info;
+	struct v4l2_subdev_format v4l_fmt = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+	};
+	struct v4l2_subdev *subdev;
+	unsigned int ret;
+
+	subdev = mchp_vcpp_remote_subdev(&mchp_vcpp->vid_cap_pad, &v4l_fmt.pad);
+	if (!subdev)
+		return;
+
+	ret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &v4l_fmt);
+	if (ret < 0)
+		return;
+
+	info = mvc_get_format_by_code(v4l_fmt.format.code);
+	if (IS_ERR(info))
+		return;
+
+	pix->pixelformat = info->fourcc;
+	pix->field = V4L2_FIELD_NONE;
+
+	pix->width = clamp(pix->width, MCHP_VCPP_MIN_WIDTH, MCHP_VCPP_MAX_WIDTH);
+	pix->height = clamp(pix->height, MCHP_VCPP_MIN_HEIGHT, MCHP_VCPP_MAX_HEIGHT);
+
+	pix->bytesperline = info->bpp * pix->width;
+	pix->sizeimage = pix->bytesperline * pix->height;
+	pix->colorspace = mchp_vcpp->format.fmt.pix.colorspace;
+	pix->ycbcr_enc = mchp_vcpp->format.fmt.pix.ycbcr_enc;
+	pix->quantization = mchp_vcpp->format.fmt.pix.quantization;
+
+	if (fmtinfo)
+		*fmtinfo = info;
+}
+
+static int mchp_vcpp_try_fmt_vid_cap(struct file *file, void *priv,
+				     struct v4l2_format *format)
+{
+	struct mchp_vcpp_fpga *mchp_vcpp = video_drvdata(file);
+
+	__mchp_vcpp_try_format(mchp_vcpp, &format->fmt.pix, NULL);
+
+	return 0;
+}
+
+static int mchp_vcpp_s_fmt_vid_cap(struct file *file, void *priv,
+				   struct v4l2_format *format)
+{
+	struct mchp_vcpp_fpga *mchp_vcpp = video_drvdata(file);
+	const struct mvideo_format *info;
+
+	if (vb2_is_streaming(&mchp_vcpp->queue))
+		return -EBUSY;
+
+	__mchp_vcpp_try_format(mchp_vcpp, &format->fmt.pix, &info);
+
+	mchp_vcpp->format.fmt.pix.height = format->fmt.pix.height;
+	mchp_vcpp->format.fmt.pix.width = format->fmt.pix.width;
+	mchp_vcpp->format.fmt.pix.sizeimage = format->fmt.pix.sizeimage;
+	mchp_vcpp->format.fmt.pix.bytesperline = format->fmt.pix.bytesperline;
+	mchp_vcpp->format.fmt.pix.pixelformat = format->fmt.pix.pixelformat;
+	mchp_vcpp->format.fmt.pix.quantization = 0;
+	mchp_vcpp->fmtinfo = info;
+
+	return 0;
+}
+
+static int mchp_vcpp_g_fmt_vid_cap(struct file *file, void *priv,
+				   struct v4l2_format *format)
+{
+	struct mchp_vcpp_fpga *mchp_vcpp = video_drvdata(file);
+
+	*format = mchp_vcpp->format;
+
+	return 0;
+}
+
+static int mchp_vcpp_enum_fmt_vid_cap(struct file *file, void *priv,
+				      struct v4l2_fmtdesc *fmt)
+{
+	struct mchp_vcpp_fpga *mchp_vcpp = video_drvdata(file);
+	struct v4l2_subdev *subdev;
+	struct v4l2_subdev_format v4l_fmt = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+	};
+	const struct mvideo_format *mvideo_fmt;
+	int ret;
+
+	/* Establish media pad format */
+	subdev = mchp_vcpp_remote_subdev(&mchp_vcpp->vid_cap_pad, &v4l_fmt.pad);
+	if (!subdev)
+		return -EPIPE;
+
+	ret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &v4l_fmt);
+	if (ret < 0)
+		return ret == -ENOIOCTLCMD ? -EINVAL : ret;
+
+	if (fmt->index > 0)
+		return -EINVAL;
+
+	mvideo_fmt = mvc_get_format_by_code(v4l_fmt.format.code);
+	if (IS_ERR(mvideo_fmt))
+		return PTR_ERR(mvideo_fmt);
+
+	fmt->pixelformat = mvideo_fmt->fourcc;
+
+	fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	return 0;
+}
+
+static int mchp_vcpp_enum_input(struct file *file, void *priv,
+				struct v4l2_input *input)
+{
+	if (input->index != 0)
+		return -EINVAL;
+
+	input->type = V4L2_INPUT_TYPE_CAMERA;
+	strscpy(input->name, "Camera", sizeof(input->name));
+
+	return 0;
+}
+
+static int mchp_vcpp_s_input(struct file *file, void *priv, unsigned int index)
+{
+	if (index > 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int mchp_vcpp_g_input(struct file *file, void *priv, unsigned int *index)
+{
+	*index = 0;
+
+	return 0;
+}
+
+static int mchp_vb2_ioctl_reqbufs(struct file *file, void *priv,
+				  struct v4l2_requestbuffers *p)
+{
+	struct mchp_vcpp_fpga *mchp_vcpp = video_drvdata(file);
+
+	if (!dev_is_dma_coherent(mchp_vcpp->dev))
+		p->flags |= V4L2_MEMORY_FLAG_NON_COHERENT;
+
+	return vb2_ioctl_reqbufs(file, priv, p);
+}
+
+static int mchp_vcpp_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	if (ctrl->id != MCHP_CID_COMPRESSION_RATIO)
+		return -EINVAL;
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops mchp_vcpp_ctrl_ops = {
+	.s_ctrl = mchp_vcpp_s_ctrl,
+};
+
+static const struct v4l2_ctrl_config mchp_vcpp_ctrls[] = {
+	{
+		.ops	= &mchp_vcpp_ctrl_ops,
+		.id	= MCHP_CID_COMPRESSION_RATIO,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "compression ratio",
+		.min	= 0,
+		.max	= 200,
+		.def	= 30,
+		.step	= 1,
+	},
+};
+
+static const struct v4l2_ioctl_ops mchp_vcpp_ioctl_ops = {
+	.vidioc_querycap = mchp_vcpp_querycap,
+	.vidioc_try_fmt_vid_cap = mchp_vcpp_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap = mchp_vcpp_s_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap = mchp_vcpp_g_fmt_vid_cap,
+	.vidioc_enum_fmt_vid_cap = mchp_vcpp_enum_fmt_vid_cap,
+
+	.vidioc_enum_input = mchp_vcpp_enum_input,
+	.vidioc_g_input = mchp_vcpp_g_input,
+	.vidioc_s_input = mchp_vcpp_s_input,
+
+	.vidioc_reqbufs = mchp_vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+
+	.vidioc_log_status = v4l2_ctrl_log_status,
+	.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+};
+
+static const struct v4l2_file_operations mchp_vcpp_fops = {
+	.owner		= THIS_MODULE,
+	.open		= v4l2_fh_open,
+	.release	= vb2_fop_release,
+	.read		= vb2_fop_read,
+	.mmap		= vb2_fop_mmap,
+	.poll		= vb2_fop_poll,
+	.unlocked_ioctl	= video_ioctl2,
+};
+
+static int mchp_vcpp_graph_notify_bound(struct v4l2_async_notifier *notifier,
+					struct v4l2_subdev *subdev,
+					struct v4l2_async_connection *asc)
+{
+	struct mchp_vcpp_graph_entity *entity = to_mchp_vcpp_entity(asc);
+
+	entity->entity = &subdev->entity;
+	entity->subdev = subdev;
+
+	return 0;
+}
+
+static int mchp_vcpp_graph_build_one(struct mchp_vcpp_fpga *mchp_vcpp,
+				     struct mchp_vcpp_graph_entity *entity)
+{
+	u32 link_flags = MEDIA_LNK_FL_ENABLED;
+	struct media_entity *local = entity->entity;
+	struct media_entity *remote;
+	struct media_pad *local_pad;
+	struct media_pad *remote_pad;
+	struct mchp_vcpp_graph_entity *graph_entity;
+	struct v4l2_fwnode_link link;
+	struct fwnode_handle *ep_fw_handle = NULL;
+	int ret = 0;
+
+	dev_dbg(mchp_vcpp->dev, "creating links for entity %s\n", local->name);
+
+	while (1) {
+		ep_fw_handle = fwnode_graph_get_next_endpoint(entity->asc.match.fwnode,
+							      ep_fw_handle);
+		if (!ep_fw_handle)
+			break;
+
+		ret = v4l2_fwnode_parse_link(ep_fw_handle, &link);
+		if (ret < 0) {
+			dev_err(mchp_vcpp->dev,
+				"failed to parse link for %p\n", ep_fw_handle);
+			continue;
+		}
+
+		if (link.local_port >= local->num_pads) {
+			dev_err(mchp_vcpp->dev,
+				"invalid port number %u for %p\n",
+				link.local_port, link.local_node);
+			v4l2_fwnode_put_link(&link);
+			ret = -EINVAL;
+			break;
+		}
+
+		local_pad = &local->pads[link.local_port];
+
+		if (local_pad->flags & MEDIA_PAD_FL_SINK) {
+			dev_dbg(mchp_vcpp->dev, "skipping sink port %p:%u\n",
+				link.local_node, link.local_port);
+			v4l2_fwnode_put_link(&link);
+			continue;
+		}
+
+		if (link.remote_node == of_fwnode_handle(mchp_vcpp->dev->of_node)) {
+			dev_dbg(mchp_vcpp->dev, "skipping DMA %p:%u\n",
+				link.local_node, link.local_port);
+			v4l2_fwnode_put_link(&link);
+			continue;
+		}
+
+		graph_entity = mchp_vcpp_graph_find_entity(mchp_vcpp, link.remote_node);
+		if (!graph_entity) {
+			dev_dbg(mchp_vcpp->dev, "no entity found for %p\n",
+				link.remote_node);
+			v4l2_fwnode_put_link(&link);
+			ret = -ENODEV;
+			break;
+		}
+
+		remote = graph_entity->entity;
+
+		if (link.remote_port >= remote->num_pads) {
+			dev_err(mchp_vcpp->dev, "invalid port number %u on %p\n",
+				link.remote_port, link.remote_node);
+			v4l2_fwnode_put_link(&link);
+			ret = -EINVAL;
+			break;
+		}
+
+		remote_pad = &remote->pads[link.remote_port];
+
+		v4l2_fwnode_put_link(&link);
+
+		dev_info(mchp_vcpp->dev, "creating %s:%u -> %s:%u link\n",
+			 local->name, local_pad->index,
+			 remote->name, remote_pad->index);
+
+		ret = media_create_pad_link(local, local_pad->index,
+					    remote, remote_pad->index,
+					    link_flags);
+		if (ret < 0) {
+			dev_err(mchp_vcpp->dev,
+				"failed to create %s:%u -> %s:%u link\n",
+				local->name, local_pad->index,
+				remote->name, remote_pad->index);
+			break;
+		}
+	}
+
+	fwnode_handle_put(ep_fw_handle);
+
+	return ret;
+}
+
+static int mchp_vcpp_graph_build_dma(struct mchp_vcpp_fpga *mchp_vcpp)
+{
+	struct device_node *node = mchp_vcpp->dev->of_node;
+	struct media_entity *source;
+	struct media_entity *sink;
+	struct media_pad *source_pad;
+	struct media_pad *sink_pad;
+	struct mchp_vcpp_graph_entity *g_entity;
+	struct v4l2_fwnode_link link;
+	struct device_node *ep_node;
+	int ret = 0;
+	u32 link_flags = MEDIA_LNK_FL_ENABLED;
+
+	ep_node = of_graph_get_next_endpoint(node, NULL);
+	if (!ep_node)
+		goto done;
+
+	ret = v4l2_fwnode_parse_link(of_fwnode_handle(ep_node), &link);
+	if (ret < 0) {
+		dev_err(mchp_vcpp->dev, "failed to parse link for %pOF\n",
+			ep_node);
+		goto done;
+	}
+
+	dev_dbg(mchp_vcpp->dev, "creating link for DMA engine %s\n",
+		mchp_vcpp->vdev.name);
+
+	g_entity = mchp_vcpp_graph_find_entity(mchp_vcpp, link.remote_node);
+	if (!g_entity) {
+		dev_err(mchp_vcpp->dev, "no entity found for %pOF\n",
+			to_of_node(link.remote_node));
+		v4l2_fwnode_put_link(&link);
+		ret = -ENODEV;
+		goto done;
+	}
+
+	if (link.remote_port >= g_entity->entity->num_pads) {
+		dev_err(mchp_vcpp->dev, "invalid port number %u on %pOF\n",
+			link.remote_port, to_of_node(link.remote_node));
+		v4l2_fwnode_put_link(&link);
+		ret = -EINVAL;
+		goto done;
+	}
+
+	source = g_entity->entity;
+	source_pad = &source->pads[link.remote_port];
+	sink = &mchp_vcpp->vdev.entity;
+	sink_pad = &mchp_vcpp->vid_cap_pad;
+
+	v4l2_fwnode_put_link(&link);
+
+	dev_dbg(mchp_vcpp->dev, "creating %s:%u -> %s:%u link\n",
+		source->name, source_pad->index, sink->name, sink_pad->index);
+
+	ret = media_create_pad_link(source, source_pad->index, sink,
+				    sink_pad->index, link_flags);
+	if (ret < 0) {
+		dev_err(mchp_vcpp->dev,
+			"failed to create %s:%u -> %s:%u link\n", source->name,
+			source_pad->index, sink->name, sink_pad->index);
+	}
+
+done:
+	return ret;
+}
+
+static int mchp_vcpp_graph_notify_complete(struct v4l2_async_notifier *notifier)
+{
+	struct mchp_vcpp_fpga	*mchp_vcpp = container_of(notifier->v4l2_dev,
+							  struct mchp_vcpp_fpga,
+							  v4l2_dev);
+	struct mchp_vcpp_graph_entity *entity;
+	struct v4l2_async_connection *asc;
+	int ret;
+
+	dev_info(mchp_vcpp->dev, "notify complete, all subdevices registered\n");
+
+	list_for_each_entry(asc, &mchp_vcpp->notifier.done_list, asc_entry) {
+		entity = to_mchp_vcpp_entity(asc);
+		ret = mchp_vcpp_graph_build_one(mchp_vcpp, entity);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = mchp_vcpp_graph_build_dma(mchp_vcpp);
+	if (ret < 0)
+		return ret;
+
+	ret = v4l2_device_register_subdev_nodes(&mchp_vcpp->v4l2_dev);
+	if (ret < 0)
+		dev_err(mchp_vcpp->dev, "failed to register subdev nodes\n");
+
+	return media_device_register(&mchp_vcpp->mdev);
+}
+
+static const struct v4l2_async_notifier_operations mchp_vcpp_v4l2_async_ops = {
+	.bound = mchp_vcpp_graph_notify_bound,
+	.complete = mchp_vcpp_graph_notify_complete,
+};
+
+static void mchp_vcpp_set_default_format(struct mchp_vcpp_fpga *mchp_vcpp)
+{
+	struct v4l2_pix_format *pix;
+
+	mchp_vcpp->fmtinfo = mvc_get_format_by_fourcc(MCHP_VCPP_DEF_FORMAT);
+	mchp_vcpp->format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	pix = &mchp_vcpp->format.fmt.pix;
+	pix->pixelformat = mchp_vcpp->fmtinfo->fourcc;
+	pix->colorspace = V4L2_COLORSPACE_SRGB;
+	pix->field = V4L2_FIELD_NONE;
+	pix->width = MCHP_VCPP_DEF_WIDTH;
+	pix->height = MCHP_VCPP_DEF_HEIGHT;
+	pix->xfer_func = V4L2_XFER_FUNC_NONE;
+	pix->ycbcr_enc	= V4L2_YCBCR_ENC_DEFAULT;
+	pix->quantization = 0;
+	pix->bytesperline = pix->width * mchp_vcpp->fmtinfo->bpp;
+	pix->sizeimage =
+		pix->width * pix->height * mchp_vcpp->fmtinfo->bpp;
+}
+
+static void mchp_vcpp_graph_cleanup(struct mchp_vcpp_fpga *mchp_vcpp)
+{
+	v4l2_async_nf_unregister(&mchp_vcpp->notifier);
+	v4l2_async_nf_cleanup(&mchp_vcpp->notifier);
+}
+
+static int mchp_vcpp_graph_parse_one(struct mchp_vcpp_fpga *mchp_vcpp,
+				     struct fwnode_handle *fwnode)
+{
+	struct fwnode_handle *remote;
+	struct fwnode_handle *ep_fw_handle = NULL;
+	int ret = 0;
+
+	dev_dbg(mchp_vcpp->dev, "parsing node %p\n", fwnode);
+
+	while (1) {
+		struct mchp_vcpp_graph_entity *graph_entity;
+
+		ep_fw_handle = fwnode_graph_get_next_endpoint(fwnode, ep_fw_handle);
+		if (!ep_fw_handle)
+			break;
+
+		remote = fwnode_graph_get_remote_port_parent(ep_fw_handle);
+		if (!remote) {
+			ret = -EINVAL;
+			goto err_notifier_cleanup;
+		}
+
+		fwnode_handle_put(ep_fw_handle);
+
+		if (remote == of_fwnode_handle(mchp_vcpp->dev->of_node) ||
+		    mchp_vcpp_graph_find_entity(mchp_vcpp, remote)) {
+			fwnode_handle_put(remote);
+			continue;
+		}
+
+		graph_entity = v4l2_async_nf_add_fwnode(&mchp_vcpp->notifier,
+							remote,
+							struct mchp_vcpp_graph_entity);
+		fwnode_handle_put(remote);
+		if (IS_ERR(graph_entity)) {
+			ret = PTR_ERR(graph_entity);
+			goto err_notifier_cleanup;
+		}
+	}
+
+	return 0;
+
+err_notifier_cleanup:
+	v4l2_async_nf_cleanup(&mchp_vcpp->notifier);
+	fwnode_handle_put(ep_fw_handle);
+	return ret;
+}
+
+static int mchp_vcpp_graph_parse(struct mchp_vcpp_fpga *mchp_vcpp)
+{
+	struct mchp_vcpp_graph_entity *entity;
+	struct v4l2_async_connection *asc;
+	int ret;
+
+	ret = mchp_vcpp_graph_parse_one(mchp_vcpp, of_fwnode_handle(mchp_vcpp->dev->of_node));
+	if (ret < 0) {
+		dev_err(mchp_vcpp->dev, "mchp_vcpp_graph_parse_one error %d\n", ret);
+		return 0;
+	}
+
+	list_for_each_entry(asc, &mchp_vcpp->notifier.waiting_list, asc_entry) {
+		entity = to_mchp_vcpp_entity(asc);
+		ret = mchp_vcpp_graph_parse_one(mchp_vcpp, entity->asc.match.fwnode);
+		if (ret < 0) {
+			v4l2_async_nf_cleanup(&mchp_vcpp->notifier);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int mchp_vcpp_graph_init(struct mchp_vcpp_fpga *mchp_vcpp)
+{
+	int ret;
+
+	/* Parse the graph to extract a list of subdevice DT nodes. */
+	ret = mchp_vcpp_graph_parse(mchp_vcpp);
+	if (ret < 0) {
+		dev_err(mchp_vcpp->dev, "graph parsing failed\n");
+		goto err_graph_cleanup;
+	}
+
+	if (list_empty(&mchp_vcpp->notifier.waiting_list)) {
+		dev_err(mchp_vcpp->dev, "no subdev found in graph\n");
+		goto err_graph_cleanup;
+	}
+
+	mchp_vcpp->notifier.ops = &mchp_vcpp_v4l2_async_ops;
+
+	ret = v4l2_async_nf_register(&mchp_vcpp->notifier);
+	if (ret < 0) {
+		dev_err(mchp_vcpp->dev, "Failed to register notifier\n");
+		goto err_graph_cleanup;
+	}
+
+	ret = 0;
+
+err_graph_cleanup:
+	if (ret < 0)
+		mchp_vcpp_graph_cleanup(mchp_vcpp);
+
+	return ret;
+}
+
+static int mchp_vcpp_probe(struct platform_device *pdev)
+{
+	struct mchp_vcpp_fpga *mchp_vcpp;
+	struct vb2_queue *vb2_q;
+	struct resource *res;
+	struct video_device *vdev;
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	int num_clks = ARRAY_SIZE(mchp_vcpp_clks);
+	int ret;
+
+	mchp_vcpp = devm_kzalloc(&pdev->dev,
+				 sizeof(struct mchp_vcpp_fpga), GFP_KERNEL);
+	if (!mchp_vcpp)
+		return dev_err_probe(&pdev->dev, PTR_ERR(mchp_vcpp),
+				     "kzalloc failed\n");
+
+	mchp_vcpp->clks = devm_kmemdup(&pdev->dev, mchp_vcpp_clks,
+				       sizeof(mchp_vcpp_clks), GFP_KERNEL);
+	if (!mchp_vcpp->clks)
+		return dev_err_probe(&pdev->dev, PTR_ERR(mchp_vcpp->clks),
+				     "Failed to get clocks\n");
+
+	mchp_vcpp->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
+	if (IS_ERR(mchp_vcpp->base))
+		return dev_err_probe(&pdev->dev, PTR_ERR(mchp_vcpp->base),
+				     "could not get mem resource\n");
+
+	mchp_vcpp->irq = platform_get_irq(pdev, 0);
+	if (mchp_vcpp->irq <= 0)
+		return dev_err_probe(&pdev->dev, mchp_vcpp->irq,
+				     "could not get irq\n");
+
+	ret = clk_bulk_get(&pdev->dev, num_clks, mchp_vcpp->clks);
+	if (ret)
+		return ret;
+
+	ret = clk_bulk_prepare_enable(num_clks, mchp_vcpp->clks);
+	if (ret)
+		goto err_clk_put;
+
+	mchp_vcpp->reset_gpio = devm_gpiod_get_optional(&pdev->dev, "reset",
+							GPIOD_OUT_LOW);
+	if (IS_ERR(mchp_vcpp->reset_gpio))
+		return dev_err_probe(&pdev->dev, PTR_ERR(mchp_vcpp->reset_gpio),
+				     "Failed to get reset gpio");
+
+	if (mchp_vcpp->reset_gpio)
+		gpiod_set_value_cansleep(mchp_vcpp->reset_gpio, 1);
+
+	writel_relaxed(MCHP_VCPP_CORE_RESET, mchp_vcpp->base + MCHP_VCPP_CTRL_REG);
+
+	mutex_init(&mchp_vcpp->lock);
+
+	mchp_vcpp->pdev = pdev;
+	mchp_vcpp->dev = &pdev->dev;
+
+	mchp_vcpp_set_default_format(mchp_vcpp);
+
+	ret = v4l2_device_register(&pdev->dev, &mchp_vcpp->v4l2_dev);
+	if (ret)
+		return ret;
+
+	ctrl_hdlr = &mchp_vcpp->ctrl_handler;
+
+	v4l2_ctrl_handler_init(ctrl_hdlr, MCHP_VCPP_NUM_CTRLS);
+
+	mchp_vcpp->compression_ratio_ctrl = v4l2_ctrl_new_custom(ctrl_hdlr,
+								 &mchp_vcpp_ctrls[0],
+								 NULL);
+	if (ctrl_hdlr->error) {
+		ret = ctrl_hdlr->error;
+		goto v4l2_unregister;
+	}
+
+	mchp_vcpp->v4l2_dev.ctrl_handler = ctrl_hdlr;
+
+	INIT_LIST_HEAD(&mchp_vcpp->buf_list);
+	spin_lock_init(&mchp_vcpp->qlock);
+
+	vdev = &mchp_vcpp->vdev;
+	strscpy(vdev->name, KBUILD_MODNAME, sizeof(vdev->name));
+	vdev->release = video_device_release_empty;
+	vdev->fops = &mchp_vcpp_fops,
+	vdev->ioctl_ops = &mchp_vcpp_ioctl_ops,
+	vdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |
+			    V4L2_CAP_STREAMING;
+	vdev->lock = &mchp_vcpp->lock;
+	vdev->queue = &mchp_vcpp->queue;
+	vdev->v4l2_dev = &mchp_vcpp->v4l2_dev;
+	vdev->vfl_dir = VFL_DIR_RX;
+	vdev->vfl_type = VFL_TYPE_VIDEO;
+
+	/* Initialize media device */
+	strscpy(mchp_vcpp->mdev.model, MCHP_VCPP_DRV_NAME, sizeof(mchp_vcpp->mdev.model));
+	snprintf(mchp_vcpp->mdev.bus_info, sizeof(mchp_vcpp->mdev.bus_info),
+		 "platform:%s", MCHP_VCPP_DRV_NAME);
+
+	mchp_vcpp->mdev.dev = &mchp_vcpp->pdev->dev;
+	media_device_init(&mchp_vcpp->mdev);
+	mchp_vcpp->v4l2_dev.mdev = &mchp_vcpp->mdev;
+
+	/* Media entity pads */
+	mchp_vcpp->vid_cap_pad.flags = MEDIA_PAD_FL_SINK;
+	ret = media_entity_pads_init(&mchp_vcpp->vdev.entity,
+				     1, &mchp_vcpp->vid_cap_pad);
+	if (ret) {
+		dev_err(mchp_vcpp->dev, "Failed to init media entity pad\n");
+		goto v4l2_unregister;
+	}
+
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
+	if (ret) {
+		dev_err(mchp_vcpp->dev, "video register device failed %d\n",
+			ret);
+		goto v4l2_unregister;
+	}
+
+	vb2_q = &mchp_vcpp->queue;
+	vb2_q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	vb2_q->io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ | VB2_USERPTR;
+	vb2_q->dev = mchp_vcpp->dev;
+	vb2_q->drv_priv = mchp_vcpp;
+	vb2_q->buf_struct_size = sizeof(struct mchp_vcpp_buffer);
+	vb2_q->ops = &mchp_vcpp_qops;
+	vb2_q->mem_ops = &vb2_dma_contig_memops;
+	vb2_q->allow_cache_hints = 1;
+	vb2_q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	vb2_q->min_buffers_needed = 2;
+	vb2_q->lock = &mchp_vcpp->lock;
+
+	ret = vb2_queue_init(vb2_q);
+	if (ret) {
+		dev_err(mchp_vcpp->dev, "vb2 queue init failed %d\n", ret);
+		goto v4l2_unregister;
+	}
+
+	v4l2_async_nf_init(&mchp_vcpp->notifier, &mchp_vcpp->v4l2_dev);
+
+	ret = mchp_vcpp_graph_init(mchp_vcpp);
+	if (ret < 0) {
+		dev_err(mchp_vcpp->dev, "mchp dscmi graph init failed %d\n", ret);
+		goto v4l2_unregister;
+	}
+
+	ret = of_reserved_mem_device_init(&pdev->dev);
+	if (ret)
+		dev_dbg(&pdev->dev, "of_reserved_mem_device_init: %d\n", ret);
+
+	ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));
+	if (ret) {
+		dev_err(&pdev->dev, "dma_set_mask_and_coherent: %d\n", ret);
+		goto v4l2_unregister;
+	}
+
+	platform_set_drvdata(pdev, mchp_vcpp);
+
+	video_set_drvdata(vdev, mchp_vcpp);
+
+	return 0;
+
+v4l2_unregister:
+	mutex_destroy(&mchp_vcpp->lock);
+	v4l2_device_unregister(&mchp_vcpp->v4l2_dev);
+err_clk_put:
+	clk_bulk_put(num_clks, mchp_vcpp->clks);
+
+	return ret;
+}
+
+static int mchp_vcpp_remove(struct platform_device *pdev)
+{
+	struct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);
+	struct mchp_vcpp_fpga *mchp_vcpp = container_of(v4l2_dev,
+							struct mchp_vcpp_fpga,
+							v4l2_dev);
+	int num_clks = ARRAY_SIZE(mchp_vcpp_clks);
+
+	mutex_destroy(&mchp_vcpp->lock);
+	v4l2_async_nf_unregister(&mchp_vcpp->notifier);
+	v4l2_async_nf_cleanup(&mchp_vcpp->notifier);
+	v4l2_device_unregister(&mchp_vcpp->v4l2_dev);
+	clk_bulk_disable_unprepare(num_clks, mchp_vcpp->clks);
+	clk_bulk_put(num_clks, mchp_vcpp->clks);
+
+	return 0;
+}
+
+static const struct of_device_id mchp_vcpp_of_match[] = {
+	{ .compatible = "microchip,video-dma-rtl-v0" },
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, mchp_vcpp_of_match);
+
+static struct platform_driver mchp_vcpp_driver = {
+	.probe = mchp_vcpp_probe,
+	.remove = mchp_vcpp_remove,
+	.driver = {
+		.name = MCHP_VCPP_DRV_NAME,
+		.of_match_table = mchp_vcpp_of_match,
+	},
+};
+
+module_platform_driver(mchp_vcpp_driver);
+
+MODULE_DESCRIPTION("Microchip Video Capture Pipeline Processing (Video DMA) Driver");
+MODULE_AUTHOR("Shravan Chippa <shravan.chippa@microchip.com>");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/media/platform/microchip/microchip-yuv2h264.c	2024-12-04 16:41:28.070865300 +0900
@@ -0,0 +1,450 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Microchip H264 Encoder Driver.
+ *
+ * Copyright (C) 2022-2023 Microchip Technology Inc. and its subsidiaries
+ * Author: Shravan Chippa <shavan.chippa@microchip.com>
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+
+#include "microchip-common.h"
+
+#include <dt-bindings/media/microchip-common.h>
+
+#define MCHP_YUV2H264_MIN_WIDTH		32
+#define MCHP_YUV2H264_MAX_WIDTH		4096
+#define MCHP_YUV2H264_MIN_HEIGHT	32
+#define MCHP_YUV2H264_MAX_HEIGHT	4096
+
+#define MCHP_YUV2H264_IP_VER		0x00
+#define MCHP_YUV2H264_CTRL		0x04
+#define MCHP_YUV2H264_CTRL_START	BIT(0)
+#define MCHP_YUV2H264_CTRL_RESET	BIT(1)
+
+#define MCHP_YUV2H264_IP_TYPE		0x08
+#define MCHP_YUV2H264_Q_FACTOR		0x0C
+#define MCHP_YUV2H264_I_P_FRAME_GAP	0x14
+#define MCHP_YUV2H264_H_RES		0x18
+#define MCHP_YUV2H264_V_RES		0x1C
+
+#define MCHP_CTL_STEP			1
+#define MCHP_Q_FACTOR_CTL_MAX		52
+#define MCHP_Q_FACTOR_CTL_MIN		25
+#define MCHP_Q_FACTOR_CTL_DEFAULT	30
+
+#define MCHP_P_COUNT_CTL_MAX		255
+#define MCHP_P_COUNT_CTL_MIN		0
+#define MCHP_P_COUNT_CTL_DEFAULT	0
+
+#define MCHP_YUV2H264_DEFAULT_WIDTH	1920
+#define MCHP_YUV2H264_DEFAULT_HEIGHT	1080
+
+#define MCHP_YUV2H264_DEF_IN_FORMAT	MVCF_YUV_422
+#define MCHP_YUV2H264_DEF_OUT_FORMAT	MVCF_H264
+
+/**
+ * struct mchp_yuv2h264_device - Microchip YUV2H264 device structure
+ * @dev: device
+ * @subdev: The v4l2 subdev structure
+ * @iomem: Base address of subsystem
+ * @pads: media pads
+ * @formats: V4L2 media bus formats at the sink and source pads
+ * @default_formats: default V4L2 media bus formats
+ * @vip_formats: Microchip Video IP formats
+ * @q_factor: Quality factor
+ * @p_count: P-frame count
+ * @ctrl_handler: control handler
+ */
+struct mchp_yuv2h264_device {
+	struct device *dev;
+	struct v4l2_subdev subdev;
+	void __iomem *iomem;
+
+	struct media_pad pads[2];
+
+	struct v4l2_mbus_framefmt formats[2];
+	struct v4l2_mbus_framefmt default_formats[2];
+	const struct mvideo_format *vip_formats[2];
+	struct v4l2_ctrl *q_factor;
+	struct v4l2_ctrl *p_count;
+
+	struct v4l2_ctrl_handler ctrl_handler;
+};
+
+static inline struct mchp_yuv2h264_device *to_mchp_yuv2h264(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct mchp_yuv2h264_device, subdev);
+}
+
+static inline u32 mchp_yuv2h264_read(struct mchp_yuv2h264_device *yuv2h264,
+				     u32 addr)
+{
+	return readl(yuv2h264->iomem + addr);
+}
+
+static inline void mchp_yuv2h264_write(struct mchp_yuv2h264_device *yuv2h264,
+				       u32 addr, u32 value)
+{
+	writel(value, yuv2h264->iomem + addr);
+}
+
+static inline void mchp_yuv2h264_clr(struct mchp_yuv2h264_device *yuv2h264,
+				     u32 addr, u32 clr)
+{
+	mchp_yuv2h264_write(yuv2h264, addr,
+			    mchp_yuv2h264_read(yuv2h264, addr) & ~clr);
+}
+
+static inline void mchp_yuv2h264_set(struct mchp_yuv2h264_device *yuv2h264,
+				     u32 addr, u32 set)
+{
+	mchp_yuv2h264_write(yuv2h264, addr, mchp_yuv2h264_read(yuv2h264, addr) | set);
+}
+
+static int mchp_yuv2h264_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct mchp_yuv2h264_device *yuv2h264 = to_mchp_yuv2h264(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	mchp_yuv2h264_set(yuv2h264, MCHP_YUV2H264_CTRL, MCHP_YUV2H264_CTRL_RESET);
+
+	if (!enable) {
+		mchp_yuv2h264_clr(yuv2h264, MCHP_YUV2H264_CTRL, MCHP_YUV2H264_CTRL_START);
+		return 0;
+	}
+
+	format = &yuv2h264->formats[MVC_PAD_SINK];
+
+	mchp_yuv2h264_write(yuv2h264, MCHP_YUV2H264_H_RES, format->width);
+	mchp_yuv2h264_write(yuv2h264, MCHP_YUV2H264_V_RES, format->height);
+	mchp_yuv2h264_write(yuv2h264, MCHP_YUV2H264_Q_FACTOR, yuv2h264->q_factor->val);
+	mchp_yuv2h264_write(yuv2h264, MCHP_YUV2H264_I_P_FRAME_GAP, yuv2h264->p_count->val);
+
+	mchp_yuv2h264_set(yuv2h264, MCHP_YUV2H264_CTRL, MCHP_YUV2H264_CTRL_START);
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__mchp_yuv2h264_get_pad_format(struct mchp_yuv2h264_device *yuv2h264,
+			       struct v4l2_subdev_state *sd_state,
+			       unsigned int pad, u32 which)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(&yuv2h264->subdev,
+						    sd_state, pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &yuv2h264->formats[pad];
+		break;
+	default:
+		format = NULL;
+		break;
+	}
+
+	return format;
+}
+
+static int mchp_yuv2h264_get_format(struct v4l2_subdev *subdev,
+				    struct v4l2_subdev_state *sd_state,
+				    struct v4l2_subdev_format *fmt)
+{
+	struct mchp_yuv2h264_device *yuv2h264 = to_mchp_yuv2h264(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __mchp_yuv2h264_get_pad_format(yuv2h264, sd_state, fmt->pad,
+						fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int mchp_yuv2h264_set_format(struct v4l2_subdev *subdev,
+				    struct v4l2_subdev_state *sd_state,
+				    struct v4l2_subdev_format *req_fmt)
+{
+	struct mchp_yuv2h264_device *yuv2h264 = to_mchp_yuv2h264(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __mchp_yuv2h264_get_pad_format(yuv2h264, sd_state, req_fmt->pad,
+						req_fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	if (req_fmt->pad == MVC_PAD_SOURCE) {
+		req_fmt->format = *format;
+		return 0;
+	}
+
+	/* Propagate the format to the source pad. */
+	format = __mchp_yuv2h264_get_pad_format(yuv2h264, sd_state, MVC_PAD_SOURCE,
+						req_fmt->which);
+
+	format->width = req_fmt->format.width;
+	format->height = req_fmt->format.height;
+
+	v4l_bound_align_image(&format->width,
+			      16, MCHP_YUV2H264_MAX_WIDTH, 0,
+			      &format->height,
+			      16, MCHP_YUV2H264_MAX_HEIGHT, 0, 0);
+
+	if (req_fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		return 0;
+
+	yuv2h264->formats[MVC_PAD_SINK].width = format->width;
+	yuv2h264->formats[MVC_PAD_SINK].height = format->height;
+	yuv2h264->formats[MVC_PAD_SOURCE].width = format->width;
+	yuv2h264->formats[MVC_PAD_SOURCE].height = format->height;
+
+	mchp_yuv2h264_write(yuv2h264, MCHP_YUV2H264_H_RES, format->width);
+	mchp_yuv2h264_write(yuv2h264, MCHP_YUV2H264_V_RES, format->height);
+
+	return 0;
+}
+
+static int mchp_yuv2h264_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	struct mchp_yuv2h264_device *yuv2h264 = to_mchp_yuv2h264(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	/* Initialize with default formats */
+	format = v4l2_subdev_get_try_format(subdev, fh->state, MVC_PAD_SINK);
+	*format = yuv2h264->default_formats[MVC_PAD_SINK];
+
+	format = v4l2_subdev_get_try_format(subdev, fh->state, MVC_PAD_SOURCE);
+	*format = yuv2h264->default_formats[MVC_PAD_SOURCE];
+
+	return 0;
+}
+
+static int mchp_yuv2h264_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static int mchp_yuv2h264_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct mchp_yuv2h264_device *yuv2h264 =
+		container_of(ctrl->handler, struct mchp_yuv2h264_device,
+			     ctrl_handler);
+
+	switch (ctrl->id) {
+	case MCHP_CID_Q_FACTOR:
+		mchp_yuv2h264_write(yuv2h264, MCHP_YUV2H264_Q_FACTOR, ctrl->val);
+		return 0;
+	case MCHP_CID_P_COUNT:
+		mchp_yuv2h264_write(yuv2h264, MCHP_YUV2H264_I_P_FRAME_GAP, ctrl->val);
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static const struct v4l2_ctrl_ops mchp_yuv2h264_ctrl_ops = {
+	.s_ctrl	= mchp_yuv2h264_s_ctrl,
+};
+
+static const struct v4l2_subdev_video_ops mchp_yuv2h264_video_ops = {
+	.s_stream = mchp_yuv2h264_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops mchp_yuv2h264_pad_ops = {
+	.enum_mbus_code		= mvc_enum_mbus_code,
+	.enum_frame_size	= mvc_enum_frame_size,
+	.get_fmt		= mchp_yuv2h264_get_format,
+	.set_fmt		= mchp_yuv2h264_set_format,
+};
+
+static const struct v4l2_subdev_ops mchp_yuv2h264_ops = {
+	.video  = &mchp_yuv2h264_video_ops,
+	.pad    = &mchp_yuv2h264_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops mchp_yuv2h264_internal_ops = {
+	.open	= mchp_yuv2h264_open,
+	.close	= mchp_yuv2h264_close,
+};
+
+/*
+ * Control Configs
+ */
+static struct v4l2_ctrl_config mchp_yuv2h264_ctrls[] = {
+	{
+		.ops	= &mchp_yuv2h264_ctrl_ops,
+		.id	= MCHP_CID_Q_FACTOR,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "Quality Factor",
+		.min	= MCHP_Q_FACTOR_CTL_MIN,
+		.max	= MCHP_Q_FACTOR_CTL_MAX,
+		.def	= MCHP_Q_FACTOR_CTL_DEFAULT,
+		.step	= MCHP_CTL_STEP,
+	}, {
+		.ops	= &mchp_yuv2h264_ctrl_ops,
+		.id	= MCHP_CID_P_COUNT,
+		.name	= "P frame count",
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.min	= MCHP_P_COUNT_CTL_MIN,
+		.max	= MCHP_P_COUNT_CTL_MAX,
+		.def	= MCHP_P_COUNT_CTL_DEFAULT,
+		.step	= MCHP_CTL_STEP,
+	},
+};
+
+static const struct media_entity_operations mchp_yuv2h264_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int mchp_yuv2h264_init_formats(struct mchp_yuv2h264_device *yuv2h264)
+{
+	struct device *dev = yuv2h264->dev;
+	const struct mvideo_format *vip_format;
+
+	vip_format = mvc_get_format_by_vf_code(MCHP_YUV2H264_DEF_IN_FORMAT);
+	if (IS_ERR(vip_format))
+		return dev_err_probe(dev, PTR_ERR(vip_format), "invalid format");
+
+	yuv2h264->vip_formats[MVC_PAD_SINK] = vip_format;
+
+	vip_format = mvc_get_format_by_vf_code(MCHP_YUV2H264_DEF_OUT_FORMAT);
+	if (IS_ERR(vip_format))
+		return dev_err_probe(dev, PTR_ERR(vip_format), "invalid format");
+
+	yuv2h264->vip_formats[MVC_PAD_SOURCE] = vip_format;
+
+	return 0;
+}
+
+static int mchp_yuv2h264_probe(struct platform_device *pdev)
+{
+	struct mchp_yuv2h264_device *yuv2h264;
+	struct v4l2_subdev *subdev;
+	struct v4l2_mbus_framefmt *default_format;
+	int ret;
+
+	yuv2h264 = devm_kzalloc(&pdev->dev, sizeof(*yuv2h264), GFP_KERNEL);
+	if (!yuv2h264)
+		return -ENOMEM;
+
+	yuv2h264->dev = &pdev->dev;
+
+	ret = mchp_yuv2h264_init_formats(yuv2h264);
+	if (ret < 0)
+		return ret;
+
+	yuv2h264->iomem = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(yuv2h264->iomem))
+		return dev_err_probe(&pdev->dev, PTR_ERR(yuv2h264->iomem),
+				     "could not get mem resource\n");
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &yuv2h264->subdev;
+	v4l2_subdev_init(subdev, &mchp_yuv2h264_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &mchp_yuv2h264_internal_ops;
+	strscpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, yuv2h264);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	/* Initialize default and active formats */
+	default_format = &yuv2h264->default_formats[MVC_PAD_SINK];
+	default_format->code = yuv2h264->vip_formats[MVC_PAD_SINK]->code;
+	default_format->field = V4L2_FIELD_NONE;
+	default_format->colorspace = V4L2_COLORSPACE_SRGB;
+	default_format->width = MCHP_YUV2H264_DEFAULT_WIDTH;
+	default_format->height = MCHP_YUV2H264_DEFAULT_HEIGHT;
+
+	yuv2h264->formats[MVC_PAD_SINK] = *default_format;
+
+	default_format = &yuv2h264->default_formats[MVC_PAD_SOURCE];
+	*default_format = yuv2h264->default_formats[MVC_PAD_SINK];
+	default_format->code = yuv2h264->vip_formats[MVC_PAD_SOURCE]->code;
+
+	yuv2h264->formats[MVC_PAD_SOURCE] = *default_format;
+
+	yuv2h264->pads[MVC_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	yuv2h264->pads[MVC_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	subdev->entity.ops = &mchp_yuv2h264_media_ops;
+	ret = media_entity_pads_init(&subdev->entity, 2, yuv2h264->pads);
+	if (ret < 0)
+		return ret;
+
+	v4l2_ctrl_handler_init(&yuv2h264->ctrl_handler, 2);
+
+	yuv2h264->q_factor = v4l2_ctrl_new_custom(&yuv2h264->ctrl_handler,
+						  &mchp_yuv2h264_ctrls[0], NULL);
+
+	yuv2h264->p_count = v4l2_ctrl_new_custom(&yuv2h264->ctrl_handler,
+						 &mchp_yuv2h264_ctrls[1], NULL);
+
+	if (yuv2h264->ctrl_handler.error) {
+		dev_err(&pdev->dev, "failed to add controls\n");
+		ret = yuv2h264->ctrl_handler.error;
+		goto media_error;
+	}
+	subdev->ctrl_handler = &yuv2h264->ctrl_handler;
+
+	platform_set_drvdata(pdev, yuv2h264);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&yuv2h264->ctrl_handler);
+media_error:
+	media_entity_cleanup(&subdev->entity);
+	return ret;
+}
+
+static int mchp_yuv2h264_remove(struct platform_device *pdev)
+{
+	struct mchp_yuv2h264_device *yuv2h264 = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &yuv2h264->subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	v4l2_ctrl_handler_free(&yuv2h264->ctrl_handler);
+	media_entity_cleanup(&subdev->entity);
+
+	return 0;
+}
+
+static const struct of_device_id mchp_yuv2h264_of_id_table[] = {
+	{ .compatible = "microchip,yuv2h264-rtl-v1" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, mchp_yuv2h264_of_id_table);
+
+static struct platform_driver mchp_yuv2h264_driver = {
+	.driver			= {
+		.name		= "microchip-yuv2h264",
+		.of_match_table	= mchp_yuv2h264_of_id_table,
+	},
+	.probe			= mchp_yuv2h264_probe,
+	.remove			= mchp_yuv2h264_remove,
+};
+
+module_platform_driver(mchp_yuv2h264_driver);
+
+MODULE_AUTHOR("Shravan Chippa <shravan.chippa@microchip.com>");
+MODULE_DESCRIPTION("Microchip H264 Encoder Driver");
+MODULE_LICENSE("GPL");
+
--- /dev/null
+++ linux4microchip-fpga-2024.09/include/dt-bindings/media/microchip-common.h	2024-12-04 16:41:37.016931100 +0900
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ */
+
+#ifndef __DT_BINDINGS_MICROCHIP_COMMON_H__
+#define __DT_BINDINGS_MICROCHIP_COMMON_H__
+
+/*
+ * Video format codes as defined in "AXI4-Stream Video IP and System Design
+ * Guide".
+ */
+#define MVCF_MONO_SENSOR		0
+#define MVCF_YUV_444			1
+#define MVCF_YUV_422			2
+#define MVCF_YUV_420			3
+#define MVCF_RBG			4
+#define MVCF_H264			5
+#define MVCF_MJPEG			6
+#define MVCF_RGB			7
+
+#define MVC_MIN_WIDTH                  32
+#define MVC_MAX_WIDTH                  7680
+#define MVC_MIN_HEIGHT                 32
+#define MVC_MAX_HEIGHT                 7680
+
+#endif /* __DT_BINDINGS_MICROCHIP_COMMON_H__ */
diff -urN '--label=/dev/null' /dev/null linux4microchip-fpga-2024.09/include/media/dwc/dw-csi-data.h
--- /dev/null
+++ linux4microchip-fpga-2024.09/include/media/dwc/dw-csi-data.h	2024-12-04 16:41:38.210737400 +0900
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018-2019 Synopsys, Inc. and/or its affiliates.
+ *
+ * Synopsys DesignWare MIPI CSI-2 platform data
+ *
+ * Author: Luis Oliveira <Luis.Oliveira@synopsys.com>
+ */
+
+#include <linux/kernel.h>
+#include <media/dwc/dw-mipi-csi-pltfrm.h>
+
+struct dw_csih_pdata {
+	u8 eotp_enabled;
+	u32 hs_freq;
+	u32 lanes;
+	u32 pclk;
+	u32 fps;
+	u32 bpp;
+	u8 id;
+};
+
+static const struct pdata_names csis[] = {
+	{ .name = "dw-csi.0", },
+	{ .name = "dw-csi.1", },
+};
diff -urN '--label=/dev/null' /dev/null linux4microchip-fpga-2024.09/include/media/dwc/dw-dphy-data.h
--- /dev/null
+++ linux4microchip-fpga-2024.09/include/media/dwc/dw-dphy-data.h	2024-12-04 16:41:38.211734600 +0900
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018-2019 Synopsys, Inc. and/or its affiliates.
+ *
+ * Synopsys DesignWare MIPI D-PHY platform data
+ *
+ * Author: Luis Oliveira <Luis.Oliveira@synopsys.com>
+ */
+
+#include <linux/phy/phy.h>
+#include <linux/kernel.h>
+#include <media/dwc/dw-mipi-csi-pltfrm.h>
+
+struct dw_phy_pdata {
+	u32 dphy_frequency;
+	u8 dphy_te_len;
+	u32 config_8l;
+	u8 dphy_gen;
+	u8 phy_type;
+	u8 id;
+};
+
+static const struct pdata_names phys[] = {
+	{ .name = "phy-dw-dphy.0.0", },
+	{ .name = "phy-dw-dphy.1.1", },
+};
+
+struct dw_dphy_rx;
+
+struct plat_dw_dphy {
+	int (*get_resources)(struct device *dev, struct dw_dphy_rx *dphy);
+};
diff -urN '--label=/dev/null' /dev/null linux4microchip-fpga-2024.09/include/media/dwc/dw-mipi-csi-pltfrm.h
--- /dev/null
+++ linux4microchip-fpga-2024.09/include/media/dwc/dw-mipi-csi-pltfrm.h	2024-12-04 16:41:38.211734600 +0900
@@ -0,0 +1,104 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018-2019 Synopsys, Inc. and/or its affiliates.
+ *
+ * Synopsys DesignWare MIPI CSI-2 Host media entities
+ *
+ * Author: Luis Oliveira <Luis.Oliveira@synopsys.com>
+ */
+
+#ifndef __DW_MIPI_CSI_PLTFRM_INCLUDES_H_
+#define __DW_MIPI_CSI_PLTFRM_INCLUDES_H_
+
+#include <media/media-entity.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-mediabus.h>
+#include <media/v4l2-subdev.h>
+
+#define MAX_WIDTH	3280
+#define MAX_HEIGHT	1852
+
+/* The subdevices' group IDs. */
+#define GRP_ID_SENSOR		(10)
+#define GRP_ID_CSI		(20)
+#define GRP_ID_VIF		(30)
+#define GRP_ID_VIDEODEV		(40)
+
+#define CSI_MAX_ENTITIES	(2)
+#define VIF_MAX_ENTITIES	(2)
+#define PLAT_MAX_SENSORS	(2)
+
+struct pdata_names {
+	char *name;
+};
+
+enum video_dev_pads {
+	VIDEO_DEV_SD_PAD_SINK_VIF1,
+	VIDEO_DEV_SD_PAD_SINK_VIF2,
+	VIDEO_DEV_SD_PAD_SOURCE_DMA,
+	VIDEO_DEV_SD_PADS_NUM,
+};
+
+enum vif_pads {
+	VIF_PAD_SINK_CSI,
+	VIF_PAD_SOURCE_DMA,
+	VIF_PADS_NUM,
+};
+
+enum mipi_csi_pads {
+	CSI_PAD_SINK,
+	CSI_PAD_SOURCE,
+	CSI_PADS_NUM,
+};
+
+struct plat_csi_source_info {
+	u16 flags;
+	u16 mux_id;
+};
+
+struct plat_csi_fmt {
+	char *name;
+	u32 mbus_code;
+	u32 fourcc;
+	u8 depth;
+};
+
+struct plat_csi_media_pipeline;
+
+/*
+ * Media pipeline operations to be called from within a video node,  i.e. the
+ * last entity within the pipeline. Implemented by related media device driver.
+ */
+struct plat_csi_media_pipeline_ops {
+	int (*prepare)(struct plat_csi_media_pipeline *p,
+		       struct media_entity *me);
+	int (*unprepare)(struct plat_csi_media_pipeline *p);
+	int (*open)(struct plat_csi_media_pipeline *p, struct media_entity *me,
+		    bool resume);
+	int (*close)(struct plat_csi_media_pipeline *p);
+	int (*set_stream)(struct plat_csi_media_pipeline *p, bool state);
+	int (*set_format)(struct plat_csi_media_pipeline *p,
+			  struct v4l2_subdev_format *fmt);
+};
+
+struct plat_csi_video_entity {
+	struct video_device vdev;
+	struct plat_csi_media_pipeline *pipe;
+};
+
+struct plat_csi_media_pipeline {
+	struct media_pipeline mp;
+	const struct plat_csi_media_pipeline_ops *ops;
+};
+
+static inline struct plat_csi_video_entity
+*vdev_to_plat_csi_video_entity(struct video_device *vdev)
+{
+	return container_of(vdev, struct plat_csi_video_entity, vdev);
+}
+
+#define plat_csi_pipeline_call(ent, op, args...)			  \
+	(!(ent) ? -ENOENT : (((ent)->pipe->ops && (ent)->pipe->ops->op) ? \
+	(ent)->pipe->ops->op(((ent)->pipe), ##args) : -ENOIOCTLCMD))	  \
+
+#endif /* __DW_MIPI_CSI_PLTFRM_INCLUDES_H_ */
--- linux-6.6.51/include/uapi/linux/media-bus-format.h	2024-12-05 13:07:58.418468800 +0900
+++ linux4microchip-fpga-2024.09/include/uapi/linux/media-bus-format.h	2024-12-04 16:41:38.828085600 +0900
@@ -157,11 +157,13 @@
 /* JPEG compressed formats - next is	0x4002 */
 #define MEDIA_BUS_FMT_JPEG_1X8			0x4001
 
-/* Vendor specific formats - next is	0x5002 */
+/* Vendor specific formats - next is	0x5003 */
 
 /* S5C73M3 sensor specific interleaved UYVY and JPEG */
 #define MEDIA_BUS_FMT_S5C_UYVY_JPEG_1X8		0x5001
 
+#define MEDIA_BUS_FMT_H264_1X8			0x5002
+
 /* HSV - next is	0x6002 */
 #define MEDIA_BUS_FMT_AHSV8888_1X32		0x6001
 
--- linux-6.6.51/include/uapi/linux/v4l2-mediabus.h	2024-12-05 13:07:58.568069000 +0900
+++ linux4microchip-fpga-2024.09/include/uapi/linux/v4l2-mediabus.h	2024-12-04 16:41:38.991648000 +0900
@@ -141,6 +141,8 @@
 
 	V4L2_MBUS_FROM_MEDIA_BUS_FMT(S5C_UYVY_JPEG_1X8),
 
+	V4L2_MBUS_FROM_MEDIA_BUS_FMT(H264_1X8),
+
 	V4L2_MBUS_FROM_MEDIA_BUS_FMT(AHSV8888_1X32),
 };
 #endif /* __KERNEL__ */
