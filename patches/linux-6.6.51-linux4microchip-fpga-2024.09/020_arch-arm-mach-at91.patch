--- linux-6.6.51/Documentation/devicetree/bindings/arm/atmel-at91.yaml	2024-12-05 13:07:30.274255200 +0900
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/arm/atmel-at91.yaml	2024-12-04 16:41:09.355673900 +0900
@@ -79,6 +79,13 @@
           - const: atmel,sama5d2
           - const: atmel,sama5
 
+      - description: Microchip SAMA5D29 Curiosity
+        items:
+          - const: microchip,sama5d29-curiosity
+          - const: atmel,sama5d29
+          - const: atmel,sama5d2
+          - const: atmel,sama5
+
       - items:
           - const: atmel,sama5d27
           - const: atmel,sama5d2
@@ -99,6 +106,12 @@
           - const: microchip,sam9x60
           - const: atmel,at91sam9
 
+      - description: SAM9X75-EB board
+        items:
+          - const: microchip,sam9x75eb
+          - const: microchip,sam9x7
+          - const: atmel,at91sam9
+
       - description: Nattis v2 board with Natte v2 power board
         items:
           - const: axentia,nattis-2
@@ -172,6 +185,12 @@
           - const: microchip,sama7g5
           - const: microchip,sama7
 
+      - description: Microchip SAMA7G54 Curiosity Board
+        items:
+          - const: microchip,sama7g54-curiosity
+          - const: microchip,sama7g5
+          - const: microchip,sama7
+
       - description: Microchip LAN9662 Evaluation Boards.
         items:
           - enum:
--- linux-6.6.51/Documentation/devicetree/bindings/arm/atmel-sysregs.txt	2024-12-05 13:07:30.275252500 +0900
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/arm/atmel-sysregs.txt	2024-12-04 16:41:09.355673900 +0900
@@ -1,7 +1,9 @@
 Atmel system registers
 
 Chipid required properties:
-- compatible: Should be "atmel,sama5d2-chipid" or "microchip,sama7g5-chipid"
+- compatible: Should be "atmel,sama5d2-chipid" or
+			"microchip,sama7g5-chipid" or
+			"microchip,sama7d65-chipid".
 - reg : Should contain registers location and length
 
 PIT Timer required properties:
--- linux-6.6.51/arch/arm/mach-at91/Kconfig	2024-12-05 13:07:34.518899300 +0900
+++ linux4microchip-fpga-2024.09/arch/arm/mach-at91/Kconfig	2024-12-04 16:41:13.900514700 +0900
@@ -78,6 +78,13 @@
 	help
 	  This enables support for ARMv7 based Microchip LAN966 SoC family.
 
+config AT91_VDEC_G1
+	bool "Video Decoder for SAMA5D4"
+	depends on SOC_SAMA5D4
+	help
+	  Select this if you are using the G1 video decoder embedded in SAMA5D4
+	  SoC family.
+
 config SOC_AT91RM9200
 	bool "AT91RM9200"
 	depends on ARCH_MULTI_V4T
@@ -141,11 +148,28 @@
 	help
 	  Select this if you are using Microchip's SAM9X60 SoC
 
+config SOC_SAM9X7
+	bool "SAM9X7"
+	depends on ARCH_MULTI_V5
+	select ATMEL_AIC5_IRQ
+	select ATMEL_PM if PM
+	select ATMEL_SDRAMC
+	select CPU_ARM926T
+	select HAVE_AT91_USB_CLK
+	select HAVE_AT91_GENERATED_CLK
+	select HAVE_AT91_SAM9X60_PLL
+	select MEMORY
+	select PINCTRL_AT91
+	select SOC_SAM_V4_V5
+	select SRAM if PM
+	help
+	  Select this if you are using Microchip's SAM9X7 SoC
+
 comment "Clocksource driver selection"
 
 config ATMEL_CLOCKSOURCE_PIT
 	bool "Periodic Interval Timer (PIT) support"
-	depends on SOC_AT91SAM9 || SOC_SAM9X60 || SOC_SAMA5
+	depends on SOC_AT91SAM9 || SOC_SAM9X60 || SOC_SAM9X7 || SOC_SAMA5
 	default SOC_AT91SAM9 || SOC_SAMA5
 	select ATMEL_PIT
 	help
@@ -155,7 +179,7 @@
 
 config ATMEL_CLOCKSOURCE_TCB
 	bool "Timer Counter Blocks (TCB) support"
-	default SOC_AT91RM9200 || SOC_AT91SAM9 || SOC_SAM9X60 || SOC_SAMA5
+	default SOC_AT91RM9200 || SOC_AT91SAM9 || SOC_SAM9X60 || SOC_SAM9X7 || SOC_SAMA5
 	select ATMEL_TCB_CLKSRC
 	help
 	  Select this to get a high precision clocksource based on a
@@ -166,7 +190,7 @@
 
 config MICROCHIP_CLOCKSOURCE_PIT64B
 	bool "64-bit Periodic Interval Timer (PIT64B) support"
-	default SOC_SAM9X60 || SOC_SAMA7
+	default SOC_SAM9X60 || SOC_SAM9X7 || SOC_SAMA7
 	select MICROCHIP_PIT64B
 	help
 	  Select this to get a high resolution clockevent (SAM9X60) or
@@ -220,7 +244,7 @@
 
 config ATMEL_SECURE_PM
 	bool "Atmel Secure PM support"
-	depends on SOC_SAMA5D2 && ATMEL_PM
+	depends on (SOC_SAMA5D2 || SOC_SAMA7G5) && ATMEL_PM
 	select ARM_PSCI
 	help
 	  When running under a TEE, the suspend mode must be requested to be set
--- linux-6.6.51/arch/arm/mach-at91/Makefile	2024-12-05 13:07:34.519896500 +0900
+++ linux4microchip-fpga-2024.09/arch/arm/mach-at91/Makefile	2024-12-04 16:41:13.901512100 +0900
@@ -7,9 +7,11 @@
 obj-$(CONFIG_SOC_AT91RM9200)	+= at91rm9200.o
 obj-$(CONFIG_SOC_AT91SAM9)	+= at91sam9.o
 obj-$(CONFIG_SOC_SAM9X60)	+= sam9x60.o
+obj-$(CONFIG_SOC_SAM9X7)	+= sam9x7.o
 obj-$(CONFIG_SOC_SAMA5)		+= sama5.o sam_secure.o
-obj-$(CONFIG_SOC_SAMA7)		+= sama7.o
+obj-$(CONFIG_SOC_SAMA7)		+= sama7.o sam_secure.o
 obj-$(CONFIG_SOC_SAMV7)		+= samv7.o
+obj-$(CONFIG_AT91_VDEC_G1)	+= memalloc.o vdec_g1.o
 
 # Power Management
 obj-$(CONFIG_ATMEL_PM)		+= pm.o pm_suspend.o
--- /dev/null
+++ linux4microchip-fpga-2024.09/arch/arm/mach-at91/at91_vdec.h	2024-12-04 16:41:13.901512100 +0900
@@ -0,0 +1,43 @@
+/*
+ * Video Decoder (VDEC) - System peripherals registers.
+ *
+ * Copyright (C) 2009  Hantro Products Oy.
+ *
+ * Based on SAMA5D4 datasheet.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef AT91_VDEC_H
+#define AT91_VDEC_H
+
+#define VDEC_IDR      0x00       /* ID Register (read-only) */
+#define   VDEC_IDR_BUILD_VER              0xf /* Build Version is 0x02. */
+#define   VDEC_IDR_MINOR_VER      (0xff << 4) /* Minor Version is 0x88. */
+#define   VDEC_IDR_MAJOR_VER      (0xf << 12) /* Major Version is 0x08. */
+#define   VDEC_IDR_PROD_ID     (0xffff << 16) /* Product ID is 0x6731. */
+
+#define VDEC_DIR      0x04       /* Decoder Interrupt Register */
+#define   VDEC_DIR_DE                       1 /* 1: Enable decoder; 0: Disable decoder. */
+#define   VDEC_DIR_ID                    0x10 /* 1: Disable interrupts for decoder; 0: Enable interrupts. */
+#define   VDEC_DIR_ABORT                 0x20
+#define   VDEC_DIR_ISET                 0x100 /* Decoder Interrupt Set. 0: Clears the Decoder Interrupt. */
+
+#define VDEC_PPIR     0xF0       /* Post Processor Interrupt Register */
+#define   VDEC_PPIR_PPE                     1 /* 1: Enable post-processor; 0: Disable post-processor */
+#define   VDEC_PPIR_ID                   0x10 /* 1: Disable interrupts for post-processor; 0: Enable interrupts. */
+#define   VDEC_PPIR_ISET                0x100 /* Post-processor Interrupt Set. 0: Clears the post-processor Interrupt. */
+
+#endif
--- linux-6.6.51/arch/arm/mach-at91/generic.h	2024-12-05 13:07:34.520893800 +0900
+++ linux4microchip-fpga-2024.09/arch/arm/mach-at91/generic.h	2024-12-04 16:41:13.902509400 +0900
@@ -8,10 +8,11 @@
 #ifndef _AT91_GENERIC_H
 #define _AT91_GENERIC_H
 
-#ifdef CONFIG_PM
+#if defined(CONFIG_ATMEL_PM) || defined(CONFIG_ATMEL_SECURE_PM)
 extern void __init at91rm9200_pm_init(void);
 extern void __init at91sam9_pm_init(void);
 extern void __init sam9x60_pm_init(void);
+extern void __init sam9x7_pm_init(void);
 extern void __init sama5_pm_init(void);
 extern void __init sama5d2_pm_init(void);
 extern void __init sama7_pm_init(void);
@@ -19,6 +20,7 @@
 static inline void __init at91rm9200_pm_init(void) { }
 static inline void __init at91sam9_pm_init(void) { }
 static inline void __init sam9x60_pm_init(void) { }
+static inline void __init sam9x7_pm_init(void) { }
 static inline void __init sama5_pm_init(void) { }
 static inline void __init sama5d2_pm_init(void) { }
 static inline void __init sama7_pm_init(void) { }
--- /dev/null
+++ linux4microchip-fpga-2024.09/arch/arm/mach-at91/hx170dec.h	2024-12-04 16:41:13.902509400 +0900
@@ -0,0 +1,76 @@
+/*
+ * Decoder device driver (kernel module headers)
+ *
+ * Copyright (C) 2009  Hantro Products Oy.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef _HX170DEC_H_
+#define _HX170DEC_H_
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+struct core_desc
+{
+	__u32 id;    /* id of the core */
+	__u32 *regs; /* pointer to user registers */
+	__u32 size;  /* size of register space */
+};
+
+/* Use 'k' as magic number */
+#define HX170DEC_IOC_MAGIC  'k'
+/*
+ * S means "Set" through a ptr,
+ * T means "Tell" directly with the argument value
+ * G means "Get": reply by setting through a pointer
+ * Q means "Query": response is on the return value
+ * X means "eXchange": G and S atomically
+ * H means "sHift": T and Q atomically
+ */
+
+#define HX170DEC_IOCGHWOFFSET		_IOR(HX170DEC_IOC_MAGIC, 3, unsigned long *)
+#define HX170DEC_IOCGHWIOSIZE		_IOR(HX170DEC_IOC_MAGIC, 4, unsigned int *)
+
+#define HX170DEC_IOC_MC_OFFSETS		_IOR(HX170DEC_IOC_MAGIC, 7, unsigned long *)
+#define HX170DEC_IOC_MC_CORES		_IOR(HX170DEC_IOC_MAGIC, 8, unsigned int *)
+#define HX170DEC_IOCS_DEC_PUSH_REG	_IOW(HX170DEC_IOC_MAGIC, 9, struct core_desc *)
+#define HX170DEC_IOCS_PP_PUSH_REG	_IOW(HX170DEC_IOC_MAGIC, 10, struct core_desc *)
+#define HX170DEC_IOCH_DEC_RESERVE	_IO(HX170DEC_IOC_MAGIC, 11)
+#define HX170DEC_IOCT_DEC_RELEASE	_IO(HX170DEC_IOC_MAGIC, 12)
+#define HX170DEC_IOCQ_PP_RESERVE	_IO(HX170DEC_IOC_MAGIC, 13)
+#define HX170DEC_IOCT_PP_RELEASE	_IO(HX170DEC_IOC_MAGIC, 14)
+#define HX170DEC_IOCX_DEC_WAIT		_IOWR(HX170DEC_IOC_MAGIC, 15, struct core_desc *)
+#define HX170DEC_IOCX_PP_WAIT		_IOWR(HX170DEC_IOC_MAGIC, 16, struct core_desc *)
+#define HX170DEC_IOCS_DEC_PULL_REG	_IOWR(HX170DEC_IOC_MAGIC, 17, struct core_desc *)
+#define HX170DEC_IOCS_PP_PULL_REG	_IOWR(HX170DEC_IOC_MAGIC, 18, struct core_desc *)
+
+#define HX170DEC_IOX_ASIC_ID		_IOWR(HX170DEC_IOC_MAGIC, 20, __u32 *)
+
+/*
+ * Following are not used yet:
+ *
+ * #define HX170DEC_PP_INSTANCE		_IO(HX170DEC_IOC_MAGIC, 1)
+ * #define HX170DEC_HW_PERFORMANCE	_IO(HX170DEC_IOC_MAGIC, 2)
+ * #define HX170DEC_IOC_CLI		_IO(HX170DEC_IOC_MAGIC, 5)
+ * #define HX170DEC_IOC_STI		_IO(HX170DEC_IOC_MAGIC, 6)
+ * #define HX170DEC_IOCG_CORE_WAIT	_IOR(HX170DEC_IOC_MAGIC, 19, int *)
+ * #define HX170DEC_DEBUG_STATUS	_IO(HX170DEC_IOC_MAGIC, 29)
+ */
+
+#define HX170DEC_IOC_MAXNR 29
+
+#endif /* !_HX170DEC_H_ */
--- /dev/null
+++ linux4microchip-fpga-2024.09/arch/arm/mach-at91/memalloc.c	2024-12-04 16:41:13.903506800 +0900
@@ -0,0 +1,316 @@
+/*
+ * Physically contiguous memory allocator
+ *
+ * Copyright (C) 2009  Hantro Products Oy.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/dma-mapping.h> /* dma_zalloc_coherent, dma_free_coherent */
+#include <linux/fs.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include "memalloc.h"
+
+struct memalloc_drv {
+	struct class *class;
+	struct device *dev;
+	int major;
+	struct list_head opened; /* list of opened files (memalloc_file_context) */
+	spinlock_t lock;
+};
+
+struct memalloc_file_context {
+	struct list_head n;
+	struct memalloc_drv *parent;
+	struct list_head blocks; /* list of allocated blocks (mem_block) */
+	spinlock_t lock;
+	//unsigned int num_blocks;
+};
+
+struct memalloc_block {
+	struct list_head n;
+	dma_addr_t dma_handle;
+	void *virt_addr;
+	size_t size; /* page aligned */
+	int method;
+};
+
+static struct memalloc_drv memalloc_ing = {
+	.opened = LIST_HEAD_INIT(memalloc_ing.opened),
+	.lock = __SPIN_LOCK_UNLOCKED(memalloc_ing.lock),
+};
+
+/**
+ * allocate_large_block - Allocate a physically contiguous memory area
+ *
+ * @param dev driver device node
+ * @param pp_block Result block struct address
+ * @param p_size Wished size. Output is rounded up to page size (often something like 4k)
+ *
+ * @return 0 on success, negative value on error
+ */
+static int allocate_large_block(struct device *dev, struct memalloc_block **pp_block, size_t *p_size)
+{
+	struct memalloc_block *p;
+
+	p = kmalloc(sizeof(struct memalloc_block), GFP_KERNEL);
+	if (p == NULL) {
+		dev_info(dev, "unable to alloc block struct.\n");
+		return -ENOMEM;
+	}
+
+	p->size = PAGE_ALIGN(*p_size);
+
+	/* Multiple of PAGE_SIZE */
+	p->virt_addr = dma_alloc_coherent(dev, p->size, &p->dma_handle, GFP_KERNEL);
+	if (!p->virt_addr) {
+		dev_err(dev, "large alloc failed (%d)\n", p->size);
+		kfree(p);
+		return -ENOMEM;
+	}
+
+	dev_dbg(dev, "large alloc ok: VA=%p PA=0x%llx SZ=%d (requested %d)\n",
+			p->virt_addr, (unsigned long long)p->dma_handle, p->size, *p_size);
+
+	*p_size = p->size;
+	*pp_block = p;
+	return 0;
+}
+
+static int free_large_block(struct device *dev, struct memalloc_block *p)
+{
+	dev_dbg(dev, "large free: VA=%p\n", p->virt_addr);
+	dma_free_coherent(dev, p->size, p->virt_addr, p->dma_handle);
+	kfree(p);
+	return 0;
+}
+
+static long memalloc_ioctl(struct file *filp, unsigned int cmd,
+	unsigned long arg)
+{
+	struct memalloc_file_context *fc = filp->private_data;
+	struct memalloc_drv *m = fc->parent;
+
+	int ret = -EFAULT;
+	MemallocParams mem_params;
+	struct memalloc_block *p;
+	size_t sz;
+
+	if (!filp || arg == 0)
+		return ret;
+
+	switch (cmd) {
+		case MEMALLOC_IOCXGETBUFFER:
+			spin_lock(&fc->lock);
+			if (copy_from_user(&mem_params, (MemallocParams *)arg, sizeof(mem_params)))
+				dev_dbg(m->dev, "copy_from_user failed\n");
+
+			sz = mem_params.size;
+			ret = allocate_large_block(m->dev, &p, &sz);
+
+			if (!ret) {
+				mem_params.busAddress = (unsigned long)p->dma_handle; /* should be 64-bit! */
+				mem_params.size = sz;
+				if (copy_to_user((MemallocParams *)arg, &mem_params, sizeof(mem_params)))
+					dev_dbg(m->dev, "copy_to_user failed\n");
+
+				list_add(&p->n, &fc->blocks);
+			}
+			spin_unlock(&fc->lock);
+			break;
+
+		case MEMALLOC_IOCSFREEBUFFER:
+			ret = -EINVAL;
+			spin_lock(&fc->lock);
+			__get_user(mem_params.busAddress, (unsigned long *)arg);
+
+			/* find memalloc_block */
+			list_for_each_entry(p, &fc->blocks, n) {
+				if ((unsigned long)p->dma_handle == mem_params.busAddress) {
+					list_del(&p->n);
+					free_large_block(m->dev, p);
+					ret = 0;
+					break;
+				}
+			}
+			spin_unlock(&fc->lock);
+			break;
+
+		default:
+			ret = -ENOIOCTLCMD;
+	}
+	return ret;
+}
+
+static int memalloc_open(struct inode *inode, struct file *filp)
+{
+	struct memalloc_file_context *fc;
+	struct memalloc_drv *m = &memalloc_ing;
+	int dev = iminor(inode);
+
+	if (dev != 0) {
+		dev_warn(m->dev, "unsupported minor (%d).\n", dev);
+		return -EINVAL;
+	}
+
+	fc = kmalloc(sizeof(struct memalloc_file_context), GFP_KERNEL);
+	if (fc == NULL) {
+		dev_err(m->dev, "unable to alloc struct.\n");
+		return -ENOMEM;
+	}
+
+	INIT_LIST_HEAD(&fc->blocks);
+	spin_lock_init(&fc->lock);
+	fc->parent = m;
+
+	filp->private_data = fc;
+
+	spin_lock(&m->lock);
+	list_add_tail(&fc->n, &m->opened);
+	spin_unlock(&m->lock);
+
+	dev_dbg(m->dev, "file open (%p)\n", fc);
+	return 0;
+}
+
+static int memalloc_release(struct inode *inode, struct file *filp)
+{
+	struct memalloc_file_context *fc = filp->private_data;
+	struct memalloc_drv *m = fc->parent;
+	struct memalloc_block *p, *tmp;
+
+	list_for_each_entry_safe(p, tmp, &fc->blocks, n) {
+		list_del(&p->n);
+		free_large_block(m->dev, p);
+	}
+
+	spin_lock(&m->lock);
+	list_del(&fc->n);
+	spin_unlock(&m->lock);
+
+	kfree(fc);
+
+	dev_dbg(m->dev, "file release (%p)\n", fc);
+	return 0;
+}
+
+static const struct vm_operations_struct mmap_mem_ops = {
+#ifdef CONFIG_HAVE_IOREMAP_PROT
+	.access = generic_access_phys
+#endif
+};
+
+/* This function is based on mmap_mem (drivers/char/mem.c) */
+static int memalloc_mmap (struct file *filp, struct vm_area_struct *vma)
+{
+	struct memalloc_file_context *fc = filp->private_data;
+	struct memalloc_block *p;
+
+	int found = 0;
+	size_t size = vma->vm_end - vma->vm_start;
+
+	/* Is this a memory chunk provided by our driver ? */
+	spin_lock(&fc->lock);
+	list_for_each_entry(p, &fc->blocks, n) {
+		if (((u64)p->dma_handle == ((u64)vma->vm_pgoff << PAGE_SHIFT)) &&
+				(size <= p->size)) {
+			found = 1;
+			break;
+		}
+	}
+	spin_unlock(&fc->lock);
+
+	if (!found)
+		return -EPERM;
+
+	vma->vm_page_prot = phys_mem_access_prot(filp, vma->vm_pgoff,
+						 size,
+						 vma->vm_page_prot);
+
+	vma->vm_ops = &mmap_mem_ops;
+
+	/* Remap-pfn-range will mark the range VM_IO */
+	if (remap_pfn_range(vma,
+			    vma->vm_start,
+			    vma->vm_pgoff,
+			    size,
+			    vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+static struct file_operations memalloc_fops = {
+	.owner          =	THIS_MODULE,
+	.open           =	memalloc_open,
+	.release        =	memalloc_release,
+	.unlocked_ioctl =	memalloc_ioctl,
+	.llseek         =	noop_llseek,
+	.mmap           =	memalloc_mmap,
+};
+
+static int memalloc_init(void)
+{
+	struct memalloc_drv *m = &memalloc_ing;
+	int ret;
+
+	m->major = register_chrdev(0, "memalloc", &memalloc_fops);
+	if (m->major < 0) {
+		pr_err("failed to register character device\n");
+		return m->major;
+	}
+
+	/* create /dev/memalloc */
+	m->class = class_create("memalloc-cls");
+	if (IS_ERR(m->class)) {
+		ret = PTR_ERR(m->class);
+		goto err;
+	}
+	m->dev = device_create(m->class, NULL, MKDEV(m->major, 0), NULL, "memalloc");
+	if (IS_ERR(m->dev)) {
+		ret = PTR_ERR(m->dev);
+		class_destroy(m->class);
+		goto err;
+	}
+
+	m->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+	dev_dbg(m->dev, "allocator with major = %d\n", m->major);
+
+	return 0;
+err:
+	unregister_chrdev(m->major, "memalloc");
+	return ret;
+
+}
+module_init(memalloc_init);
+
+static void memalloc_exit(void)
+{
+	struct memalloc_drv *m = &memalloc_ing;
+
+	device_destroy(m->class, MKDEV(m->major, 0));
+	class_destroy(m->class);
+	unregister_chrdev(m->major, "memalloc");
+}
+module_exit(memalloc_exit);
+
+MODULE_AUTHOR("Hantro Products Oy");
+MODULE_DESCRIPTION("Memory allocator for VDEC");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.5");
--- /dev/null
+++ linux4microchip-fpga-2024.09/arch/arm/mach-at91/memalloc.h	2024-12-04 16:41:13.903506800 +0900
@@ -0,0 +1,54 @@
+/*
+ * Memalloc, encoder memory allocation driver (kernel module headers)
+ *
+ * Copyright (C) 2009  Hantro Products Oy.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+
+#ifndef MEMALLOC_H
+#define MEMALLOC_H
+
+#include <linux/ioctl.h>
+
+/* Use 'k' as magic number */
+#define MEMALLOC_IOC_MAGIC  'k'
+/*
+ * S means "Set" through a ptr,
+ * T means "Tell" directly with the argument value
+ * G means "Get": reply by setting through a pointer
+ * Q means "Query": response is on the return value
+ * X means "eXchange": G and S atomically
+ * H means "sHift": T and Q atomically
+ */
+#define MEMALLOC_IOCXGETBUFFER         _IOWR(MEMALLOC_IOC_MAGIC, 1, MemallocParams*)
+#define MEMALLOC_IOCSFREEBUFFER        _IOW(MEMALLOC_IOC_MAGIC,  2, unsigned long)
+
+/*
+ * ... more to come
+ *
+ * debugging tool
+ * #define MEMALLOC_IOCHARDRESET       _IO(MEMALLOC_IOC_MAGIC, 15)
+ * #define MEMALLOC_IOC_MAXNR 15
+ *
+ */
+
+typedef struct {
+    unsigned busAddress;
+    unsigned size;
+} MemallocParams;
+
+#endif /* MEMALLOC_H */
--- linux-6.6.51/arch/arm/mach-at91/pm.c	2024-12-05 13:07:34.520893800 +0900
+++ linux4microchip-fpga-2024.09/arch/arm/mach-at91/pm.c	2024-12-04 16:41:13.903506800 +0900
@@ -116,6 +116,7 @@
  * @config_shdwc_ws: wakeup sources configuration function for SHDWC
  * @config_pmc_ws: wakeup srouces configuration function for PMC
  * @ws_ids: wakup sources of_device_id array
+ * @shdwc_np: pointer to shdwc node
  * @bu: backup unit mapped data (for backup mode)
  * @quirks: PM quirks
  * @data: PM data to be used on last phase of suspend
@@ -126,6 +127,7 @@
 	int (*config_shdwc_ws)(void __iomem *shdwc, u32 *mode, u32 *polarity);
 	int (*config_pmc_ws)(void __iomem *pmc, u32 mode, u32 polarity);
 	const struct of_device_id *ws_ids;
+	struct device_node *shdwc_np;
 	struct at91_pm_bu *bu;
 	struct at91_pm_quirks quirks;
 	struct at91_pm_data data;
@@ -233,6 +235,95 @@
 	{ /* sentinel */ }
 };
 
+static const struct of_device_id sam9x7_ws_ids[] = {
+	{ .compatible = "microchip,sam9x60-rtc",	.data = &ws_info[1] },
+	{ .compatible = "atmel,at91rm9200-ohci",	.data = &ws_info[2] },
+	{ .compatible = "usb-ohci",			.data = &ws_info[2] },
+	{ .compatible = "atmel,at91sam9g45-ehci",	.data = &ws_info[2] },
+	{ .compatible = "usb-ehci",			.data = &ws_info[2] },
+	{ .compatible = "microchip,sam9x60-rtt",	.data = &ws_info[4] },
+	{ .compatible = "microchip,sam9x7-gem",		.data = &ws_info[5] },
+	{ /* sentinel */ }
+};
+
+static int at91_pm_device_in_list(const struct platform_device *pdev,
+				  const struct of_device_id *ids)
+{
+	struct platform_device *local_pdev;
+	const struct of_device_id *match;
+	struct device_node *np;
+	int in_list = 0;
+
+	for_each_matching_node_and_match(np, ids, &match) {
+		local_pdev = of_find_device_by_node(np);
+		if (!local_pdev)
+			continue;
+
+		if (pdev == local_pdev)
+			in_list = 1;
+
+		put_device(&local_pdev->dev);
+		if (in_list)
+			return in_list;
+	}
+
+	return in_list;
+}
+
+static int at91_pm_prepare_lpm(unsigned int pm_mode)
+{
+	struct platform_device *pdev;
+	int ndevices, i, ret;
+	struct of_phandle_args lpmspec;
+
+	if ((pm_mode != AT91_PM_ULP0 && pm_mode != AT91_PM_ULP1) ||
+	    !soc_pm.shdwc_np)
+		return 0;
+
+	ndevices = of_count_phandle_with_args(soc_pm.shdwc_np,
+					      "microchip,lpm-connection", 0);
+	if (ndevices < 0)
+		return 0;
+
+	soc_pm.data.lpm = 1;
+	for (i = 0; i < ndevices; i++) {
+		ret = of_parse_phandle_with_args(soc_pm.shdwc_np,
+						 "microchip,lpm-connection",
+						 NULL, i, &lpmspec);
+		if (ret < 0) {
+			if (ret == -ENOENT) {
+				continue;
+			} else {
+				soc_pm.data.lpm = 0;
+				return ret;
+			}
+		}
+
+		pdev = of_find_device_by_node(lpmspec.np);
+		if (!pdev)
+			continue;
+
+		if (device_may_wakeup(&pdev->dev)) {
+			if (pm_mode == AT91_PM_ULP1) {
+				/*
+				 * ULP1 wake-up sources are limited. Ignore it if not
+				 * in soc_pm.ws_ids.
+				 */
+				if (at91_pm_device_in_list(pdev, soc_pm.ws_ids))
+					soc_pm.data.lpm = 0;
+			} else {
+				soc_pm.data.lpm = 0;
+			}
+		}
+
+		put_device(&pdev->dev);
+		if (!soc_pm.data.lpm)
+			break;
+	}
+
+	return 0;
+}
+
 static int at91_pm_config_ws(unsigned int pm_mode, bool set)
 {
 	const struct wakeup_source_info *wsi;
@@ -471,10 +562,17 @@
 		soc_pm.data.mode = -1;
 	}
 
-	ret = at91_pm_config_ws(soc_pm.data.mode, true);
+	ret = at91_pm_prepare_lpm(soc_pm.data.mode);
 	if (ret)
 		return ret;
 
+	ret = at91_pm_config_ws(soc_pm.data.mode, true);
+	if (ret) {
+		/* Revert LPM if any. */
+		soc_pm.data.lpm = 0;
+		return ret;
+	}
+
 	if (soc_pm.data.mode == AT91_PM_BACKUP)
 		soc_pm.bu->suspended = 1;
 	else if (soc_pm.bu)
@@ -538,11 +636,12 @@
 
 static int at91_suspend_finish(unsigned long val)
 {
-	unsigned char modified_gray_code[] = {
-		0x00, 0x01, 0x02, 0x03, 0x06, 0x07, 0x04, 0x05, 0x0c, 0x0d,
-		0x0e, 0x0f, 0x0a, 0x0b, 0x08, 0x09, 0x18, 0x19, 0x1a, 0x1b,
-		0x1e, 0x1f, 0x1c, 0x1d, 0x14, 0x15, 0x16, 0x17, 0x12, 0x13,
-		0x10, 0x11,
+	/* SYNOPSYS workaround to fix a bug in the calibration logic (SYNOPSYS Case Number 01331341) */
+	unsigned char modified_fix_code[] = {
+		0x00, 0x01, 0x01, 0x06, 0x07, 0x0c, 0x06, 0x07, 0x0b, 0x18,
+		0x0a, 0x0b, 0x0c, 0x0d, 0x0d, 0x0a, 0x13, 0x13, 0x12, 0x13,
+		0x14, 0x15, 0x15, 0x12, 0x18, 0x19, 0x19, 0x1e, 0x1f, 0x14,
+		0x1e, 0x1f,
 	};
 	unsigned int tmp, index;
 	int i;
@@ -553,25 +652,25 @@
 		 * restore the ZQ0SR0 with the value saved here. But the
 		 * calibration is buggy and restoring some values from ZQ0SR0
 		 * is forbidden and risky thus we need to provide processed
-		 * values for these (modified gray code values).
+		 * values for these.
 		 */
 		tmp = readl(soc_pm.data.ramc_phy + DDR3PHY_ZQ0SR0);
 
 		/* Store pull-down output impedance select. */
 		index = (tmp >> DDR3PHY_ZQ0SR0_PDO_OFF) & 0x1f;
-		soc_pm.bu->ddr_phy_calibration[0] = modified_gray_code[index];
+		soc_pm.bu->ddr_phy_calibration[0] = modified_fix_code[index] << DDR3PHY_ZQ0SR0_PDO_OFF;
 
 		/* Store pull-up output impedance select. */
 		index = (tmp >> DDR3PHY_ZQ0SR0_PUO_OFF) & 0x1f;
-		soc_pm.bu->ddr_phy_calibration[0] |= modified_gray_code[index];
+		soc_pm.bu->ddr_phy_calibration[0] |= modified_fix_code[index] << DDR3PHY_ZQ0SR0_PUO_OFF;
 
 		/* Store pull-down on-die termination impedance select. */
 		index = (tmp >> DDR3PHY_ZQ0SR0_PDODT_OFF) & 0x1f;
-		soc_pm.bu->ddr_phy_calibration[0] |= modified_gray_code[index];
+		soc_pm.bu->ddr_phy_calibration[0] |= modified_fix_code[index] << DDR3PHY_ZQ0SR0_PDODT_OFF;
 
 		/* Store pull-up on-die termination impedance select. */
 		index = (tmp >> DDR3PHY_ZQ0SRO_PUODT_OFF) & 0x1f;
-		soc_pm.bu->ddr_phy_calibration[0] |= modified_gray_code[index];
+		soc_pm.bu->ddr_phy_calibration[0] |= modified_fix_code[index] << DDR3PHY_ZQ0SRO_PUODT_OFF;
 
 		/*
 		 * The 1st 8 words of memory might get corrupted in the process
@@ -1098,20 +1197,22 @@
 
 	suspend_mode = soc_pm.data.suspend_mode;
 
-	res = sam_smccc_call(SAMA5_SMC_SIP_SET_SUSPEND_MODE,
+	res = sam_smccc_call(SAM_SMC_SIP_SET_SUSPEND_MODE,
 			     suspend_mode, 0);
 	if (res.a0 == 0) {
 		pr_info("AT91: Secure PM: suspend mode set to %s\n",
 			pm_modes[suspend_mode].pattern);
+		soc_pm.data.mode = suspend_mode;
 		return;
 	}
 
 	pr_warn("AT91: Secure PM: %s mode not supported !\n",
 		pm_modes[suspend_mode].pattern);
 
-	res = sam_smccc_call(SAMA5_SMC_SIP_GET_SUSPEND_MODE, 0, 0);
+	res = sam_smccc_call(SAM_SMC_SIP_GET_SUSPEND_MODE, 0, 0);
 	if (res.a0 == 0) {
 		pr_warn("AT91: Secure PM: failed to get default mode\n");
+		soc_pm.data.mode = -1;
 		return;
 	}
 
@@ -1119,6 +1220,7 @@
 		pm_modes[suspend_mode].pattern);
 
 	soc_pm.data.suspend_mode = res.a1;
+	soc_pm.data.mode = soc_pm.data.suspend_mode;
 }
 static const struct of_device_id atmel_shdwc_ids[] = {
 	{ .compatible = "atmel,sama5d2-shdwc" },
@@ -1132,6 +1234,7 @@
 	{ .compatible = "atmel,sama5d2-gem" },
 	{ .compatible = "atmel,sama5d29-gem" },
 	{ .compatible = "microchip,sama7g5-gem" },
+	{ .compatible = "microchip,sam9x7-gem" },
 	{ },
 };
 
@@ -1237,7 +1340,11 @@
 			AT91_PM_REPLACE_MODES(maps, SHDWC);
 		} else {
 			soc_pm.data.shdwc = of_iomap(np, 0);
-			of_node_put(np);
+			/*
+			 * np is used further on suspend/resume path so we skip the
+			 * of_node_put(np) here.
+			 */
+			soc_pm.shdwc_np = np;
 		}
 	}
 
@@ -1359,6 +1466,7 @@
 	{ .compatible = "atmel,sama5d2-pmc", .data = &pmc_infos[1] },
 	{ .compatible = "microchip,sam9x60-pmc", .data = &pmc_infos[4] },
 	{ .compatible = "microchip,sama7g5-pmc", .data = &pmc_infos[5] },
+	{ .compatible = "microchip,sam9x7-pmc", .data = &pmc_infos[4] },
 	{ /* sentinel */ },
 };
 
@@ -1496,6 +1604,28 @@
 	soc_pm.config_pmc_ws = at91_sam9x60_config_pmc_ws;
 }
 
+void __init sam9x7_pm_init(void)
+{
+	static const int modes[] __initconst = {
+		AT91_PM_STANDBY, AT91_PM_ULP0,
+	};
+
+	int ret;
+
+	if (!IS_ENABLED(CONFIG_SOC_SAM9X7))
+		return;
+
+	at91_pm_modes_validate(modes, ARRAY_SIZE(modes));
+	ret = at91_dt_ramc(false);
+	if (ret)
+		return;
+
+	at91_pm_init(NULL);
+
+	soc_pm.ws_ids = sam9x7_ws_ids;
+	soc_pm.config_pmc_ws = at91_sam9x60_config_pmc_ws;
+}
+
 void __init at91sam9_pm_init(void)
 {
 	int ret;
@@ -1609,7 +1739,8 @@
 		AT91_PM_STANDBY, AT91_PM_ULP0, AT91_PM_ULP1, AT91_PM_BACKUP,
 	};
 	static const u32 iomaps[] __initconst = {
-		[AT91_PM_ULP0]		= AT91_PM_IOMAP(SFRBU),
+		[AT91_PM_ULP0]		= AT91_PM_IOMAP(SFRBU) |
+					  AT91_PM_IOMAP(SHDWC),
 		[AT91_PM_ULP1]		= AT91_PM_IOMAP(SFRBU) |
 					  AT91_PM_IOMAP(SHDWC) |
 					  AT91_PM_IOMAP(ETHC),
@@ -1621,6 +1752,12 @@
 	if (!IS_ENABLED(CONFIG_SOC_SAMA7))
 		return;
 
+	if (IS_ENABLED(CONFIG_ATMEL_SECURE_PM)) {
+		pr_warn("AT91: Secure PM: ignoring standby mode\n");
+		at91_pm_secure_init();
+		return;
+	}
+
 	at91_pm_modes_validate(modes, ARRAY_SIZE(modes));
 
 	ret = at91_dt_ramc(true);
--- linux-6.6.51/arch/arm/mach-at91/pm.h	2024-12-05 13:07:34.520893800 +0900
+++ linux4microchip-fpga-2024.09/arch/arm/mach-at91/pm.h	2024-12-04 16:41:13.904504100 +0900
@@ -39,6 +39,7 @@
 	unsigned int suspend_mode;
 	unsigned int pmc_mckr_offset;
 	unsigned int pmc_version;
+	unsigned int lpm;
 };
 #endif
 
--- linux-6.6.51/arch/arm/mach-at91/pm_data-offsets.c	2024-12-05 13:07:34.521891100 +0900
+++ linux4microchip-fpga-2024.09/arch/arm/mach-at91/pm_data-offsets.c	2024-12-04 16:41:13.904504100 +0900
@@ -18,6 +18,7 @@
 						 pmc_mckr_offset));
 	DEFINE(PM_DATA_PMC_VERSION,	offsetof(struct at91_pm_data,
 						 pmc_version));
+	DEFINE(PM_DATA_LPM,		offsetof(struct at91_pm_data, lpm));
 
 	return 0;
 }
--- linux-6.6.51/arch/arm/mach-at91/pm_suspend.S	2024-12-05 13:07:34.521891100 +0900
+++ linux4microchip-fpga-2024.09/arch/arm/mach-at91/pm_suspend.S	2024-12-04 16:41:13.904504100 +0900
@@ -87,32 +87,30 @@
 
 	.endm
 
-/**
- * Set state for 2.5V low power regulator
- * @ena: 0 - disable regulator
- *	 1 - enable regulator
+/*
+ * Set LPM
+ * @ena: 0 - disable LPM
+ *	 1 - enable LPM
  *
- * Side effects: overwrites r7, r8, r9, r10
+ * Side effects: overwrites r7, r8, r9
  */
-	.macro at91_2_5V_reg_set_low_power ena
-#ifdef CONFIG_SOC_SAMA7
-	ldr	r7, .sfrbu
-	mov	r8, #\ena
-	ldr	r9, [r7, #AT91_SFRBU_25LDOCR]
-	orr	r9, r9, #AT91_SFRBU_25LDOCR_LP
-	cmp	r8, #1
-	beq	lp_done_\ena
-	bic	r9, r9, #AT91_SFRBU_25LDOCR_LP
-lp_done_\ena:
-	ldr	r10, =AT91_SFRBU_25LDOCR_LDOANAKEY
-	orr	r9, r9, r10
-	str	r9, [r7, #AT91_SFRBU_25LDOCR]
-#endif
-	.endm
-
-	.macro at91_backup_set_lpm reg
+	.macro at91_set_lpm ena
 #ifdef CONFIG_SOC_SAMA7
-	orr	\reg, \reg, #0x200000
+	ldr	r7, .lpm
+	cmp	r7, #1
+	bne	21f
+	ldr	r7, .shdwc
+	cmp	r7, #0
+	beq	21f
+	mov	r8, #0xA5000000
+	add	r8, #0x200000
+	mov	r9, #\ena
+	cmp	r9, #1
+	beq	20f
+	add	r8, #0x200000
+20:
+	str	r8, [r7]
+21:
 #endif
 	.endm
 
@@ -502,7 +500,7 @@
 	ldr	tmp1, [pmc, #AT91_PMC_SR]
 	str	tmp1, .saved_osc_status
 	tst	tmp1, #AT91_PMC_MOSCRCS
-	bne	1f
+	bne	7f
 
 	/* Turn off RC oscillator */
 	ldr	tmp1, [pmc, #AT91_CKGR_MOR]
@@ -516,6 +514,9 @@
 	tst	tmp1, #AT91_PMC_MOSCRCS
 	bne	2b
 
+	/* Enable LPM. */
+7:	at91_set_lpm 1
+
 	/* Wait for interrupt */
 1:	at91_cpu_idle
 
@@ -533,8 +534,10 @@
 	wait_mckrdy tmp3
 	b	6f
 
-5:	/* Restore RC oscillator state */
-	ldr	tmp1, .saved_osc_status
+5:	at91_set_lpm 0
+
+	/* Restore RC oscillator state */
+8:	ldr	tmp1, .saved_osc_status
 	tst	tmp1, #AT91_PMC_MOSCRCS
 	beq	4f
 
@@ -611,6 +614,9 @@
 
 	wait_mckrdy tmp3
 
+	/* Enable LPM */
+	at91_set_lpm 1
+
 	/* Enter the ULP1 mode by set WAITMODE bit in CKGR_MOR */
 	ldr	tmp1, [pmc, #AT91_CKGR_MOR]
 	orr	tmp1, tmp1, #AT91_PMC_WAITMODE
@@ -624,6 +630,9 @@
 
 	wait_mckrdy tmp3
 
+	/* Disable LPM. */
+	at91_set_lpm 0
+
 	/* Enable the crystal oscillator */
 	ldr	tmp1, [pmc, #AT91_CKGR_MOR]
 	orr	tmp1, tmp1, #AT91_PMC_MOSCEN
@@ -954,9 +963,6 @@
 
 	at91_plla_disable
 
-	/* Enable low power mode for 2.5V regulator. */
-	at91_2_5V_reg_set_low_power 1
-
 	ldr	tmp3, .pm_mode
 	cmp	tmp3, #AT91_PM_ULP1
 	beq	ulp1_mode
@@ -969,9 +975,6 @@
 	b	ulp_exit
 
 ulp_exit:
-	/* Disable low power mode for 2.5V regulator. */
-	at91_2_5V_reg_set_low_power 0
-
 	ldr	pmc, .pmc_base
 
 	at91_plla_enable
@@ -1014,7 +1017,9 @@
 	ldr	r0, .shdwc
 	mov	tmp1, #0xA5000000
 	add	tmp1, tmp1, #0x1
-	at91_backup_set_lpm tmp1
+#ifdef CONFIG_SOC_SAMA7
+	orr	tmp1, tmp1, #0x200000
+#endif
 	str	tmp1, [r0, #0]
 .endm
 
@@ -1045,6 +1050,10 @@
 	str	tmp1, .memtype
 	ldr	tmp1, [r0, #PM_DATA_MODE]
 	str	tmp1, .pm_mode
+#ifdef CONFIG_SOC_SAMA7
+	ldr	tmp1, [r0, #PM_DATA_LPM]
+	str	tmp1, .lpm
+#endif
 
 	/*
 	 * ldrne below are here to preload their address in the TLB as access
@@ -1132,6 +1141,10 @@
 	.word 0
 .pmc_version:
 	.word 0
+#ifdef CONFIG_SOC_SAMA7
+.lpm:
+	.word 0
+#endif
 .saved_mckr:
 	.word 0
 .saved_pllar:
--- /dev/null
+++ linux4microchip-fpga-2024.09/arch/arm/mach-at91/sam9x7.c	2024-12-04 16:41:13.905501500 +0900
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Setup code for SAM9X7.
+ *
+ * Copyright (C) 2022 Microchip Technology Inc. and its subsidiaries
+ *
+ * Author: Varshini Rajendran <varshini.rajendran@microchip.com>
+ */
+
+#include <linux/of.h>
+#include <linux/of_platform.h>
+
+#include <asm/mach/arch.h>
+#include <asm/system_misc.h>
+
+#include "generic.h"
+
+static void __init sam9x7_init(void)
+{
+	of_platform_default_populate(NULL, NULL, NULL);
+
+	sam9x7_pm_init();
+}
+
+static const char *const sam9x7_dt_board_compat[] __initconst = {
+	"microchip,sam9x7",
+	NULL
+};
+
+DT_MACHINE_START(sam9x7_dt, "Microchip SAM9X7")
+	/* Maintainer: Microchip */
+	.init_machine	= sam9x7_init,
+	.dt_compat	= sam9x7_dt_board_compat,
+MACHINE_END
--- linux-6.6.51/arch/arm/mach-at91/sam_secure.h	2024-12-05 13:07:34.522888400 +0900
+++ linux4microchip-fpga-2024.09/arch/arm/mach-at91/sam_secure.h	2024-12-04 16:41:13.906498700 +0900
@@ -9,8 +9,15 @@
 #include <linux/arm-smccc.h>
 
 /* Secure Monitor mode APIs */
-#define SAMA5_SMC_SIP_SET_SUSPEND_MODE	0x400
-#define SAMA5_SMC_SIP_GET_SUSPEND_MODE	0x401
+#define SAMA5_SMC_SIP_L2X0_WRITE_REG	0x100
+
+#define SAM_SMC_SIP_SET_SUSPEND_MODE	0x400
+#define SAM_SMC_SIP_GET_SUSPEND_MODE	0x401
+
+/* SAMA5 SMC return codes */
+#define SAMA5_SMC_SIP_RETURN_SUCCESS	0x0
+#define SAMA5_SMC_SIP_RETURN_EPERM	0x1
+#define SAMA5_SMC_SIP_RETURN_EINVAL	0x2
 
 void __init sam_secure_init(void);
 struct arm_smccc_res sam_smccc_call(u32 fn, u32 arg0, u32 arg1);
--- linux-6.6.51/arch/arm/mach-at91/sama5.c	2024-12-05 13:07:34.522888400 +0900
+++ linux4microchip-fpga-2024.09/arch/arm/mach-at91/sama5.c	2024-12-04 16:41:13.906498700 +0900
@@ -18,9 +18,23 @@
 #include "generic.h"
 #include "sam_secure.h"
 
+#define SAM_SIP_SMC_VAL(func) ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL, \
+		ARM_SMCCC_SMC_32, ARM_SMCCC_OWNER_SIP, (func))
+
+#define SAM_SMC_SIP_PL310_ENABLE 0x1
+
 static void sama5_l2c310_write_sec(unsigned long val, unsigned reg)
 {
 	/* OP-TEE configures the L2 cache and does not allow modifying it yet */
+#ifdef CONFIG_HAVE_ARM_SMCCC
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(SAM_SIP_SMC_VAL(SAM_SMC_SIP_PL310_ENABLE), val, reg, 0, 0,
+		      0, 0, 0, &res);
+
+	if (res.a0 != 0)
+		pr_err("Failed to write l2c310 0x%x: 0x%lx\n", reg, res.a0);
+#endif
 }
 
 static void __init sama5_secure_cache_init(void)
--- linux-6.6.51/arch/arm/mach-at91/sama7.c	2024-12-05 13:07:34.523886000 +0900
+++ linux4microchip-fpga-2024.09/arch/arm/mach-at91/sama7.c	2024-12-04 16:41:13.906498700 +0900
@@ -13,6 +13,12 @@
 #include <asm/system_misc.h>
 
 #include "generic.h"
+#include "sam_secure.h"
+
+static void __init sama7_secure_cache_init(void)
+{
+	sam_secure_init();
+}
 
 static void __init sama7_dt_device_init(void)
 {
@@ -28,6 +34,7 @@
 DT_MACHINE_START(sama7_dt, "Microchip SAMA7")
 	/* Maintainer: Microchip */
 	.init_machine	= sama7_dt_device_init,
+	.init_early	= sama7_secure_cache_init,
 	.dt_compat	= sama7_dt_board_compat,
 MACHINE_END
 
--- /dev/null
+++ linux4microchip-fpga-2024.09/arch/arm/mach-at91/vdec_g1.c	2024-12-04 16:41:13.908493300 +0900
@@ -0,0 +1,460 @@
+/*
+ * On2/Hantro G1 decoder/pp driver. Single core version.
+ *
+ * Copyright (C) 2009  Hantro Products Oy.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/sched.h>
+
+#include "hx170dec.h"
+#include "at91_vdec.h"
+
+#define VDEC_MAX_CORES                 1 /* number of cores of the hardware IP */
+#define VDEC_NUM_REGS_DEC             60 /* number of registers of the Decoder part */
+#define VDEC_NUM_REGS_PP              41 /* number of registers of the Post Processor part */
+#define VDEC_DEC_FIRST_REG             0 /* first register (0-based) index */
+#define VDEC_DEC_LAST_REG             59 /* last register (0-based) index */
+#define VDEC_PP_FIRST_REG             60
+#define VDEC_PP_LAST_REG             100
+
+struct vdec_device {
+	void __iomem *mmio_base;
+	struct clk *clk;
+	struct device *dev;
+	int irq;
+	int num_cores;
+	unsigned long iobaseaddr;
+	unsigned long iosize;
+	wait_queue_head_t dec_wq;
+	wait_queue_head_t pp_wq;
+	bool dec_irq_done;
+	bool pp_irq_done;
+	struct semaphore dec_sem;
+	struct semaphore pp_sem;
+	struct file *dec_owner;
+	struct file *pp_owner;
+	u32 regs[VDEC_NUM_REGS_DEC + VDEC_NUM_REGS_PP];
+};
+static struct vdec_device *vdec6731_global;
+
+static inline void vdec_writel(const struct vdec_device *p, unsigned offset, u32 val)
+{
+	writel(val, p->mmio_base + offset);
+}
+
+static inline u32 vdec_readl(const struct vdec_device *p, unsigned offset)
+{
+	return readl(p->mmio_base + offset);
+}
+
+/**
+ * Write a range of registers. First register is assumed to be
+ * "Interrupt Register" and will be written last.
+ */
+static int vdec_regs_write(struct vdec_device *p, int begin, int end,
+		const struct core_desc *core)
+{
+	int i;
+
+	if (copy_from_user(&p->regs[begin], core->regs, (end - begin + 1) * 4))
+	{
+		dev_err(p->dev, "%s: copy_from_user failed\n", __func__);
+		return -EFAULT;
+	}
+
+	for (i = end; i >= begin; i--)
+		vdec_writel(p, 4 * i, p->regs[i]);
+
+	return 0;
+}
+
+/**
+ * Read a range of registers [begin..end]
+ */
+static int vdec_regs_read(struct vdec_device *p, int begin, int end,
+		const struct core_desc *core)
+{
+	int i;
+
+	for (i = end; i >= begin; i--)
+		p->regs[i] = vdec_readl(p, 4 * i);
+
+	if (copy_to_user(core->regs, &p->regs[begin], (end - begin + 1) * 4))
+	{
+		dev_err(p->dev, "%s: copy_to_user failed\n", __func__);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/**
+ * Misc driver related
+ */
+
+static int vdec_misc_open(struct inode *inode, struct file *filp)
+{
+	struct vdec_device *p = vdec6731_global;
+	filp->private_data = p;
+
+	dev_dbg(p->dev, "open\n");
+	clk_prepare_enable(p->clk);
+	return 0;
+}
+
+static int vdec_misc_release(struct inode *inode, struct file *filp)
+{
+	struct vdec_device *p = filp->private_data;
+
+	if (p->dec_owner == filp) {
+		p->dec_irq_done = false;
+		init_waitqueue_head(&p->dec_wq);
+		sema_init(&p->dec_sem, VDEC_MAX_CORES);
+		p->dec_owner = NULL;
+	}
+
+	if (p->pp_owner == filp) {
+		p->pp_irq_done = false;
+		init_waitqueue_head(&p->pp_wq);
+		sema_init(&p->pp_sem, 1);
+		p->pp_owner = NULL;
+	}
+
+	clk_disable_unprepare(p->clk);
+	dev_dbg(p->dev, "release\n");
+	return 0;
+}
+
+static long vdec_misc_ioctl(struct file *filp, unsigned int cmd,
+    unsigned long arg)
+{
+	int ret = 0;
+	void __user *argp = (void __user *)arg;
+	struct vdec_device *p = vdec6731_global;
+	struct core_desc core;
+	u32 reg;
+
+	switch (cmd) {
+		case HX170DEC_IOX_ASIC_ID:
+			reg = vdec_readl(p, VDEC_IDR);
+			if (copy_to_user(argp, &reg, sizeof(u32)))
+				ret = -EFAULT;
+			break;
+
+		case HX170DEC_IOC_MC_OFFSETS:
+		case HX170DEC_IOCGHWOFFSET:
+			if (copy_to_user(argp, &p->iobaseaddr, sizeof(p->iobaseaddr)))
+				ret = -EFAULT;
+			break;
+		case HX170DEC_IOCGHWIOSIZE: /* in bytes */
+			if (copy_to_user(argp, &p->iosize, sizeof(p->iosize)))
+				ret = -EFAULT;
+			break;
+		case HX170DEC_IOC_MC_CORES:
+			if (copy_to_user(argp, &p->num_cores, sizeof(p->num_cores)))
+				ret = -EFAULT;
+			break;
+
+		case HX170DEC_IOCS_DEC_PUSH_REG:
+			if (copy_from_user(&core, (void *)arg, sizeof(struct core_desc))) {
+				dev_err(p->dev, "copy_from_user (dec push reg) failed\n");
+				ret = -EFAULT;
+			} else {
+				/* Skip VDEC_IDR (ID Register, ro) */
+				core.regs++; // core.size -= 4;
+				ret = vdec_regs_write(p, VDEC_DEC_FIRST_REG + 1, VDEC_DEC_LAST_REG, &core);
+			}
+			break;
+		case HX170DEC_IOCS_PP_PUSH_REG:
+			if (copy_from_user(&core, (void *)arg, sizeof(struct core_desc))) {
+				dev_err(p->dev, "copy_from_user (pp push reg) failed\n");
+				ret = -EFAULT;
+			} else {
+				/* Don't consider the 5 lastest registers (ro or unused) */
+				ret = vdec_regs_write(p, VDEC_PP_FIRST_REG, VDEC_PP_LAST_REG - 5, &core);
+			}
+			break;
+
+		case HX170DEC_IOCS_DEC_PULL_REG:
+			if (copy_from_user(&core, (void *)arg, sizeof(struct core_desc))) {
+				dev_err(p->dev, "copy_from_user (dec pull reg) failed\n");
+				ret = -EFAULT;
+			} else {
+				ret = vdec_regs_read(p, VDEC_DEC_FIRST_REG, VDEC_DEC_LAST_REG, &core);
+			}
+			break;
+
+		case HX170DEC_IOCS_PP_PULL_REG:
+			if (copy_from_user(&core, (void*)arg, sizeof(struct core_desc))) {
+				dev_err(p->dev, "copy_from_user (pp pull reg) failed\n");
+				ret = -EFAULT;
+			} else {
+				ret = vdec_regs_read(p, VDEC_PP_FIRST_REG, VDEC_PP_LAST_REG, &core);
+			}
+			break;
+
+		case HX170DEC_IOCX_DEC_WAIT:
+			if (copy_from_user(&core, (void *)arg, sizeof(struct core_desc))) {
+				dev_err(p->dev, "copy_from_user (dec wait) failed\n");
+				ret = -EFAULT;
+			} else {
+				ret = wait_event_interruptible(p->dec_wq, p->dec_irq_done);
+				p->dec_irq_done = false;
+				if (unlikely(ret != 0)) {
+					dev_err(p->dev, "wait_event_interruptible dec error %d\n", ret);
+				} else {
+					/* Update dec registers */
+					ret = vdec_regs_read(p, VDEC_DEC_FIRST_REG, VDEC_DEC_LAST_REG, &core);
+				}
+			}
+			break;
+		case HX170DEC_IOCX_PP_WAIT:
+			if (copy_from_user(&core, (void *)arg, sizeof(struct core_desc))) {
+				dev_err(p->dev, "copy_from_user (pp wait) failed\n");
+				ret = -EFAULT;
+			} else {
+				ret = wait_event_interruptible(p->pp_wq, p->pp_irq_done);
+				p->pp_irq_done = false;
+				if (unlikely(ret != 0)) {
+					dev_err(p->dev, "wait_event_interruptible pp error %d\n", ret);
+				} else {
+					/* Update pp registers */
+					ret = vdec_regs_read(p, VDEC_PP_FIRST_REG, VDEC_PP_LAST_REG, &core);
+				}
+			}
+			break;
+
+		case HX170DEC_IOCH_DEC_RESERVE:
+			if (likely(down_interruptible(&p->dec_sem) == 0)) {
+				p->dec_owner = filp;
+				ret = 0; /* core id */
+				dev_dbg(p->dev, "down dec_sem (core id %d)\n", ret);
+			} else {
+				dev_err(p->dev, "down_interruptible dec error\n");
+				ret = -ERESTARTSYS;
+			}
+			break;
+		case HX170DEC_IOCT_DEC_RELEASE:
+			dev_dbg(p->dev, "up dec_sem\n");
+			p->dec_owner = NULL;
+			up(&p->dec_sem);
+			break;
+
+		case HX170DEC_IOCQ_PP_RESERVE:
+			if (likely(down_interruptible(&p->pp_sem) == 0)) {
+				p->pp_owner = filp;
+				ret = 0; /* core id */
+				dev_dbg(p->dev, "down pp_sem (core id %d)\n", ret);
+			} else {
+				dev_err(p->dev, "down_interruptible pp error\n");
+				ret = -ERESTARTSYS;
+			}
+			break;
+		case HX170DEC_IOCT_PP_RELEASE:
+			dev_dbg(p->dev, "up pp_sem\n");
+			p->pp_owner = NULL;
+			up(&p->pp_sem);
+			break;
+
+		default:
+			dev_warn(p->dev, "unknown ioctl %x\n", cmd);
+			ret = -EINVAL;
+	}
+	return ret;
+}
+
+const struct file_operations vdec_misc_fops = {
+	.owner          =	THIS_MODULE,
+	.llseek         =	no_llseek,
+	.open           =	vdec_misc_open,
+	.release        =	vdec_misc_release,
+	.unlocked_ioctl =	vdec_misc_ioctl,
+};
+
+static struct miscdevice vdec_misc_device = {
+	MISC_DYNAMIC_MINOR,
+	"vdec",
+	&vdec_misc_fops
+};
+
+/*
+ * Platform driver related
+ */
+
+/* Should we use spin_lock_irqsave here? */
+static irqreturn_t vdec_isr(int irq, void *dev_id)
+{
+	struct vdec_device *p = dev_id;
+	u32 irq_status_dec, irq_status_pp;
+	int handled = 0;
+
+	/* interrupt status register read */
+	irq_status_dec = vdec_readl(p, VDEC_DIR);
+	if (irq_status_dec & VDEC_DIR_ISET) {
+		/* Clear IRQ */
+		vdec_writel(p, VDEC_DIR, irq_status_dec & ~VDEC_DIR_ISET);
+
+		p->dec_irq_done = true;
+		wake_up_interruptible(&p->dec_wq);
+		handled++;
+	}
+
+	irq_status_pp = vdec_readl(p, VDEC_PPIR);
+	if (irq_status_pp & VDEC_PPIR_ISET) {
+		/* Clear IRQ */
+		vdec_writel(p, VDEC_PPIR, irq_status_pp & ~VDEC_PPIR_ISET);
+
+		p->pp_irq_done = true;
+		wake_up_interruptible(&p->pp_wq);
+		handled++;
+	}
+
+	if (handled == 0) {
+		dev_warn(p->dev, "Spurious IRQ (DIR=%08x PPIR=%08x)\n", \
+				irq_status_dec, irq_status_pp);
+		return IRQ_NONE;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int __init vdec_probe(struct platform_device *pdev)
+{
+	struct vdec_device *p;
+	struct resource *res;
+	int ret;
+	u32 hwid;
+
+	/* Allocate private data */
+	p = devm_kzalloc(&pdev->dev, sizeof(struct vdec_device), GFP_KERNEL);
+	if (!p) {
+		dev_dbg(&pdev->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	p->dev = &pdev->dev;
+	platform_set_drvdata(pdev, p);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	p->mmio_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(p->mmio_base))
+		return PTR_ERR(p->mmio_base);
+
+	p->clk = devm_clk_get(&pdev->dev, "vdec_clk");
+	if (IS_ERR(p->clk)) {
+		dev_err(&pdev->dev, "no vdec_clk clock defined\n");
+		return -ENXIO;
+	}
+
+	p->irq = platform_get_irq(pdev, 0);
+	if (!p->irq) {
+		dev_err(&pdev->dev, "could not get irq\n");
+		return -ENXIO;
+	}
+
+	ret = devm_request_irq(&pdev->dev, p->irq, vdec_isr,
+			0, pdev->name, p);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request VDEC irq\n");
+		return ret;
+	}
+
+	/* Register the miscdevice */
+	ret = misc_register(&vdec_misc_device);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to register miscdevice\n");
+		return ret;
+	}
+
+	p->num_cores = VDEC_MAX_CORES;
+	p->iosize = resource_size(res);
+	p->iobaseaddr = res->start;
+	vdec6731_global = p;
+
+	p->dec_irq_done = false;
+	p->pp_irq_done = false;
+	p->dec_owner = NULL;
+	p->pp_owner = NULL;
+	init_waitqueue_head(&p->dec_wq);
+	init_waitqueue_head(&p->pp_wq);
+	sema_init(&p->dec_sem, VDEC_MAX_CORES);
+	sema_init(&p->pp_sem, 1);
+
+	ret = clk_prepare_enable(p->clk);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to prepare and enable clock\n");
+		misc_deregister(&vdec_misc_device);
+		return ret;
+	}
+
+	dev_info(&pdev->dev, "VDEC controller at 0x%p, irq = %d, misc_minor = %d\n",
+			p->mmio_base, p->irq, vdec_misc_device.minor);
+
+	/* Reset Asic (just in case..) */
+	vdec_writel(p, VDEC_DIR, VDEC_DIR_ID | VDEC_DIR_ABORT);
+	vdec_writel(p, VDEC_PPIR, VDEC_PPIR_ID);
+
+	hwid = vdec_readl(p, VDEC_IDR);
+	clk_disable_unprepare(p->clk);
+
+	dev_warn(&pdev->dev, "Product ID: %#x (revision %d.%d.%d)\n", \
+			(hwid & VDEC_IDR_PROD_ID) >> 16,
+			(hwid & VDEC_IDR_MAJOR_VER) >> 12,
+			(hwid & VDEC_IDR_MINOR_VER) >> 4,
+			(hwid & VDEC_IDR_BUILD_VER));
+	return 0;
+}
+
+static int __exit vdec_remove(struct platform_device *pdev)
+{
+	platform_set_drvdata(pdev, NULL);
+	misc_deregister(&vdec_misc_device);
+	return 0;
+}
+
+static const struct of_device_id vdec_of_match[] = {
+	{ .compatible = "on2,sama5d4-g1", .data = NULL },
+	{},
+};
+MODULE_DEVICE_TABLE(of, vdec_of_match);
+
+static struct platform_driver vdec_of_driver = {
+	.driver		= {
+		.name	= "atmel-vdec",
+		.owner	= THIS_MODULE,
+		.of_match_table	= vdec_of_match,
+	},
+	.remove		= vdec_remove,
+};
+
+module_platform_driver_probe(vdec_of_driver, vdec_probe);
+
+MODULE_AUTHOR("Hantro Products Oy");
+MODULE_DESCRIPTION("G1 decoder/pp driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.4");
+MODULE_ALIAS("platform:vdec");
--- linux-6.6.51/include/linux/platform_data/atmel.h	2024-12-05 13:07:57.497932100 +0900
+++ linux4microchip-fpga-2024.09/include/linux/platform_data/atmel.h	2024-12-04 16:41:37.816791200 +0900
@@ -7,7 +7,7 @@
 #define __ATMEL_H__
 
 /* FIXME: this needs a better location, but gets stuff building again */
-#ifdef CONFIG_ATMEL_PM
+#if defined(CONFIG_ATMEL_PM) || defined(CONFIG_ATMEL_SECURE_PM)
 extern int at91_suspend_entering_slow_clock(void);
 #else
 static inline int at91_suspend_entering_slow_clock(void)
--- linux-6.6.51/include/linux/regmap.h	2024-12-05 13:07:57.623595900 +0900
+++ linux4microchip-fpga-2024.09/include/linux/regmap.h	2024-12-04 16:41:37.940460300 +0900
@@ -646,11 +646,17 @@
 				      const struct regmap_config *config,
 				      struct lock_class_key *lock_key,
 				      const char *lock_name);
+
 struct regmap *__regmap_init_fsi(struct fsi_device *fsi_dev,
 				 const struct regmap_config *config,
 				 struct lock_class_key *lock_key,
 				 const char *lock_name);
 
+struct regmap *__regmap_init_smccc(struct device *dev, u32 regmap_smc_id,
+				   const struct regmap_config *config,
+				   struct lock_class_key *lock_key,
+				   const char *lock_name);
+
 struct regmap *__devm_regmap_init(struct device *dev,
 				  const struct regmap_bus *bus,
 				  void *bus_context,
@@ -715,11 +721,16 @@
 					   const struct regmap_config *config,
 					   struct lock_class_key *lock_key,
 					   const char *lock_name);
+
 struct regmap *__devm_regmap_init_fsi(struct fsi_device *fsi_dev,
 				      const struct regmap_config *config,
 				      struct lock_class_key *lock_key,
 				      const char *lock_name);
 
+struct regmap *__devm_regmap_init_smccc(struct device *dev, u32 regmap_smc_id,
+					const struct regmap_config *config,
+					struct lock_class_key *lock_key,
+					const char *lock_name);
 /*
  * Wrapper for regmap_init macros to include a unique lockdep key and name
  * for each call. No-op if CONFIG_LOCKDEP is not set.
@@ -959,6 +970,20 @@
 	__regmap_lockdep_wrapper(__regmap_init_fsi, #config, fsi_dev,	\
 				 config)
 
+/*
+ * regmap_init_smccc() - Initialize register map for ARM SMCCC
+ *
+ * @dev: Device that will be interacted with
+ * @smc_id: SMC id to used for calls
+ * @config: Configuration for register map
+ *
+ * The return value will be an ERR_PTR() on error or a valid pointer
+ * to a struct regmap.
+ */
+#define regmap_init_smccc(dev, smc_id, config)			\
+	__regmap_lockdep_wrapper(__regmap_init_smccc, #config,	\
+				 dev, smc_id, config)
+
 /**
  * devm_regmap_init() - Initialise managed register map
  *
@@ -1202,6 +1227,21 @@
 	__regmap_lockdep_wrapper(__devm_regmap_init_fsi, #config,	\
 				 fsi_dev, config)
 
+/*
+ * devm_regmap_init_smccc() - Initialize register map for ARM SMCCC
+ *
+ * @dev: Device that will be interacted with
+ * @smc_id: SMC id to used for calls
+ * @config: Configuration for register map
+ *
+ * The return value will be an ERR_PTR() on error or a valid pointer
+ * to a struct regmap.  The map will be automatically freed by the
+ * device management code.
+ */
+#define devm_regmap_init_smccc(dev, smc_id, config)			\
+	__regmap_lockdep_wrapper(__devm_regmap_init_smccc, #config,	\
+				 dev, smc_id, config)
+
 int regmap_mmio_attach_clk(struct regmap *map, struct clk *clk);
 void regmap_mmio_detach_clk(struct regmap *map);
 void regmap_exit(struct regmap *map);
