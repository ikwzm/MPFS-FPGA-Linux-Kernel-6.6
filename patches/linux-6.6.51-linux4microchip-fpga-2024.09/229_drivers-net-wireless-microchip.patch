--- linux-6.6.51/drivers/net/wireless/microchip/Makefile	2024-12-05 13:07:51.226709500 +0900
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/Makefile	2024-12-04 16:41:31.552550600 +0900
@@ -1,2 +1,2 @@
 # SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_WILC1000)		+= wilc1000/
+obj-$(CONFIG_WILC)		+= wilc1000/
--- linux-6.6.51/drivers/net/wireless/microchip/wilc1000/Kconfig	2024-12-05 13:07:51.227706800 +0900
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/Kconfig	2024-12-04 16:41:31.552550600 +0900
@@ -1,48 +1,45 @@
 # SPDX-License-Identifier: GPL-2.0
-config WILC1000
+config WILC
 	tristate
-	help
-	  Add support for the Atmel WILC1000 802.11 b/g/n SoC.
-	  This provides Wi-FI over an SDIO or SPI interface, and
-	  is usually found in IoT devices.
-
-	  This module only support IEEE 802.11n WiFi.
 
-config WILC1000_SDIO
-	tristate "Atmel WILC1000 SDIO (WiFi only)"
+config WILC_SDIO
+	tristate "WILC SDIO"
 	depends on CFG80211 && INET && MMC
-	select WILC1000
+	select WILC
 	help
 	  This module adds support for the SDIO interface of adapters using
-	  WILC1000 chipset. The Atmel WILC1000 SDIO is a full speed interface.
+	  WILC1000 & WILC3000 chipset. The Atmel WILC1000 SDIO is a full speed interface.
 	  It meets SDIO card specification version 2.0. The interface supports
 	  the 1-bit/4-bit SD transfer mode at the clock range of 0-50 MHz.
 	  The host can use this interface to read and write from any register
 	  within the chip as well as configure the WILC1000 for data DMA.
 	  To use this interface, pin9 (SDIO_SPI_CFG) must be grounded. Select
 	  this if your platform is using the SDIO bus.
+	  WILC3000 additionally supports BT 4.0 and BLE modes.
 
-config WILC1000_SPI
-	tristate "Atmel WILC1000 SPI (WiFi only)"
+config WILC_SPI
+	tristate "WILC SPI"
 	depends on CFG80211 && INET && SPI
-	select WILC1000
+	select WILC
 	select CRC7
 	select CRC_ITU_T
 	help
 	  This module adds support for the SPI interface of adapters using
-	  WILC1000 chipset. The Atmel WILC1000 has a Serial Peripheral
+	  WILC1000 & WILC3000 chipset. The Atmel WILC1000 has a Serial Peripheral
 	  Interface (SPI) that operates as a SPI slave. This SPI interface can
 	  be used for control and for serial I/O of 802.11 data. The SPI is a
 	  full-duplex slave synchronous serial interface that is available
 	  immediately following reset when pin 9 (SDIO_SPI_CFG) is tied to
 	  VDDIO. Select this if your platform is using the SPI bus.
+	  WILC3000 additionally supports BT 4.0 and BLE modes.
 
-config WILC1000_HW_OOB_INTR
-	bool "WILC1000 out of band interrupt"
-	depends on WILC1000_SDIO
+config WILC_HW_OOB_INTR
+	bool "WILC out of band interrupt"
+	depends on WILC_SDIO
+	default n
 	help
-	  This option enables out-of-band interrupt support for the WILC1000
-	  chipset. This OOB interrupt is intended to provide a faster interrupt
-	  mechanism for SDIO host controllers that don't support SDIO interrupt.
-	  Select this option If the SDIO host controller in your platform
-	  doesn't support SDIO time division interrupt.
+	  This option enables out-of-band interrupt support for the WILC1000 &
+	  WILC3000 chipset. This OOB interrupt is intended to provide a faster
+	  interrupt mechanism for SDIO host controllers that don't support SDIO
+	  interrupt. Select this option If the SDIO host controller in your
+	  platform doesn't support SDIO time division interrupt.
--- linux-6.6.51/drivers/net/wireless/microchip/wilc1000/Makefile	2024-12-05 13:07:51.227706800 +0900
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/Makefile	2024-12-04 16:41:31.553548000 +0900
@@ -1,11 +1,13 @@
 # SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_WILC1000) += wilc1000.o
+ccflags-y += -I$(src)/ -DWILC_DEBUGFS
 
-wilc1000-objs := cfg80211.o netdev.o mon.o \
-			hif.o wlan_cfg.o wlan.o
+wilc-objs := cfg80211.o netdev.o mon.o \
+			hif.o wlan_cfg.o wlan.o sysfs.o power.o bt.o debugfs.o wilcs02_loopback.o
 
-obj-$(CONFIG_WILC1000_SDIO) += wilc1000-sdio.o
-wilc1000-sdio-objs += sdio.o
+obj-$(CONFIG_WILC_SDIO) += wilc-sdio.o
+wilc-sdio-objs += $(wilc-objs)
+wilc-sdio-objs += sdio.o
 
-obj-$(CONFIG_WILC1000_SPI) += wilc1000-spi.o
-wilc1000-spi-objs += spi.o
+obj-$(CONFIG_WILC_SPI) += wilc-spi.o
+wilc-spi-objs += $(wilc-objs)
+wilc-spi-objs += spi.o
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/bt.c	2024-12-04 16:41:31.553548000 +0900
@@ -0,0 +1,700 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/firmware.h>
+
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/host.h>
+
+#include "netdev.h"
+
+static struct wilc *wilc_bt;
+static dev_t chc_dev_no; /* Global variable for the first device number */
+static struct cdev str_chc_dev; /* Global variable for the character */
+static struct device *dev;
+static struct class *chc_dev_class; /* Global variable for the device class */
+static bool device_created;
+static int bt_init_done;
+
+typedef void (wilc_cmd_handler)(char *);
+
+static void handle_cmd_bt_enable(char *param);
+static void handle_cmd_pwr_up(char *param);
+static void handle_cmd_pwr_down(char *param);
+static void handle_cmd_chip_wake_up(char *param);
+static void handle_cmd_chip_allow_sleep(char *param);
+static void handle_cmd_download_fw(char *param);
+static void handle_cmd_cca_thrshld(char *param);
+
+static void wilc_bt_firmware_download(struct wilc *);
+static void wilc_bt_start(struct wilc *);
+static int wilc_bt_dev_open(struct inode *i, struct file *f);
+static int wilc_bt_dev_close(struct inode *i, struct file *f);
+static ssize_t wilc_bt_dev_read(struct file *f, char __user *buf, size_t len,
+				loff_t *off);
+static ssize_t wilc_bt_dev_write(struct file *f, const char __user *buff,
+				 size_t len, loff_t *off);
+
+static const struct file_operations pugs_fops = {
+	.owner = THIS_MODULE,
+	.open = wilc_bt_dev_open,
+	.release = wilc_bt_dev_close,
+	.read = wilc_bt_dev_read,
+	.write = wilc_bt_dev_write
+};
+
+struct cmd_entry {
+	const char *str;
+	wilc_cmd_handler *wilc_handle_cmd;
+};
+
+static const struct cmd_entry cmd_table[] = {
+	{"BT_DOWNLOAD_FW", handle_cmd_download_fw},
+	{"BT_POWER_UP", handle_cmd_pwr_up},
+	{"BT_POWER_DOWN", handle_cmd_pwr_down},
+	{"BT_FW_CHIP_WAKEUP", handle_cmd_chip_wake_up},
+	{"BT_FW_CHIP_ALLOW_SLEEP", handle_cmd_chip_allow_sleep},
+	{"BT_ENABLE", handle_cmd_bt_enable},
+	{"CCA_THRESHOLD", handle_cmd_cca_thrshld},
+	/* Keep the NULL handler at the end of the table */
+	{(const char *)NULL, NULL},
+};
+
+static int wilc_bt_dev_open(struct inode *i, struct file *f)
+{
+	pr_info("at_pwr_dev: open()\n");
+	return 0;
+}
+
+static int wilc_bt_dev_close(struct inode *i, struct file *f)
+{
+	pr_info("at_pwr_dev: close()\n");
+	return 0;
+}
+
+static ssize_t wilc_bt_dev_read(struct file *f, char __user *buf, size_t len,
+				loff_t *off)
+{
+	pr_debug("at_pwr_dev: read()\n");
+	return 0;
+}
+
+static ssize_t wilc_bt_dev_write(struct file *f, const char __user *buff,
+				 size_t len, loff_t *off)
+{
+	struct cmd_entry *cmd;
+	char *usr_str;
+
+
+	if (len == 0) {
+		pr_debug("received invalid size <=0: %zu\n", len);
+		return len;
+	}
+
+	usr_str = kmalloc(len, GFP_KERNEL);
+
+	if (copy_from_user(usr_str, buff, len))
+		return -EIO;
+
+	pr_debug("received %s, len %zu\n", usr_str, len);
+	/* call the appropriate command handler */
+	cmd = (struct cmd_entry *)cmd_table;
+	while (cmd->wilc_handle_cmd != NULL) {
+		if (strncmp(cmd->str, usr_str, strlen(cmd->str)) == 0) {
+			pr_debug("param len: %zu, string: %s\n",
+				 len - strlen(cmd->str), usr_str);
+			cmd->wilc_handle_cmd(usr_str + strlen(cmd->str));
+			break;
+		}
+		cmd++;
+	}
+
+	kfree(usr_str);
+	return len;
+}
+
+static void wilc_bt_create_device(void)
+{
+	int ret = 0;
+
+	if (device_created)
+		return;
+
+	ret = alloc_chrdev_region(&chc_dev_no, 0, 1, "atmel");
+	if (ret < 0)
+		return;
+#if KERNEL_VERSION(6, 4, 0) <= LINUX_VERSION_CODE
+	chc_dev_class = class_create("atmel");
+#else
+	chc_dev_class = class_create(THIS_MODULE, "atmel");
+#endif
+	if (IS_ERR(chc_dev_class)) {
+		unregister_chrdev_region(chc_dev_no, 1);
+		return;
+	}
+	dev = device_create(chc_dev_class, NULL, chc_dev_no, NULL,
+			    "wilc_bt");
+	if (IS_ERR(dev)) {
+		class_destroy(chc_dev_class);
+		unregister_chrdev_region(chc_dev_no, 1);
+		return;
+	}
+
+	cdev_init(&str_chc_dev, &pugs_fops);
+	ret = cdev_add(&str_chc_dev, chc_dev_no, 1);
+	if (ret < 0) {
+		device_destroy(chc_dev_class, chc_dev_no);
+		class_destroy(chc_dev_class);
+		unregister_chrdev_region(chc_dev_no, 1);
+		return;
+	}
+	mutex_init(&wilc_bt->cs);
+	device_created = 1;
+}
+
+static void handle_cmd_cca_thrshld(char *param)
+{
+	int carrier_thrshld, noise_thrshld;
+	unsigned int carr_thrshld_frac, noise_thrshld_frac, carr_thrshld_int,
+		noise_thrshld_int, reg;
+
+	if (param == NULL) {
+		pr_err("Invalid parameter\n");
+		return;
+	}
+
+	if (sscanf(param, " %d %d", &noise_thrshld, &carrier_thrshld) != 2) {
+		pr_err("Failed to parse input parameters. Usage:\n");
+		pr_err("echo CCA_THRESHOLD NOISE_THRESHOLD CARRIER_THRESHOLD > /dev/at_pwr_dev\n");
+		pr_err("where threshold values are in dB * 10\n");
+		pr_err("e.g. echo CCA_THRESHOLD -625 -826 > /dev/at_pwr_dev to set thresholds to -62.5 and -82.6\n\n");
+		return;
+	}
+
+	pr_info("Changing CCA noise threshold to %d and carrier thresholds to %d\n",
+		noise_thrshld, carrier_thrshld);
+
+	carr_thrshld_int = carrier_thrshld/10;
+	if (carrier_thrshld < 0)
+		carr_thrshld_frac = (carr_thrshld_int * 10) - carrier_thrshld;
+	else
+		carr_thrshld_frac = carrier_thrshld - (carr_thrshld_int * 10);
+
+	noise_thrshld_int = noise_thrshld/10;
+	if (noise_thrshld < 0)
+		noise_thrshld_frac = (noise_thrshld_int * 10) - noise_thrshld;
+	else
+		noise_thrshld_frac = noise_thrshld - (noise_thrshld_int * 10);
+
+	wilc_bt->hif_func->hif_read_reg(wilc_bt, CCA_CTL_2, &reg);
+	reg &= ~(0x7FF0000);
+	reg |= ((noise_thrshld_frac & 0x7) | ((noise_thrshld_int & 0x1FF)
+					      << 3)) << 16;
+	wilc_bt->hif_func->hif_write_reg(wilc_bt, CCA_CTL_2, reg);
+
+	wilc_bt->hif_func->hif_read_reg(wilc_bt, CCA_CTL_7, &reg);
+	reg &= ~(0x7FF0000);
+	reg |= ((carr_thrshld_frac & 0x7) | ((carr_thrshld_int & 0x1FF) << 3))
+		<< 16;
+	wilc_bt->hif_func->hif_write_reg(wilc_bt, CCA_CTL_7, reg);
+}
+
+int wilc_bt_power_down(struct wilc *wilc, int source)
+{
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+	int ret;
+
+	if (source == DEV_BT) {
+		u32 reg;
+
+		pr_info("AT PWR: bt_power_down\n");
+
+		/* Adjust coexistence module. This should be done from the FW
+		 * in the future
+		 */
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+		ret = hif_func->hif_read_reg(wilc, GLOBAL_MODE_CONTROL,
+					     &reg);
+		if (ret) {
+			pr_err("[wilc start]: fail read reg %x\n",
+			       GLOBAL_MODE_CONTROL);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		/* Clear BT mode*/
+		reg &= ~BIT(1);
+		ret = hif_func->hif_write_reg(wilc, GLOBAL_MODE_CONTROL,
+					      reg);
+		if (ret) {
+			pr_err("[wilc start]: fail write reg %x\n",
+			       GLOBAL_MODE_CONTROL);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+
+
+		/*TicketId1115*/
+		/*Disable awake coex null frames*/
+		ret = hif_func->hif_read_reg(wilc, COE_AUTO_PS_ON_NULL_PKT,
+					     &reg);
+		if (ret) {
+			pr_err("[wilc start]: fail read reg %x\n",
+			       COE_AUTO_PS_ON_NULL_PKT);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		reg &= ~BIT(30);
+		ret = hif_func->hif_write_reg(wilc, COE_AUTO_PS_ON_NULL_PKT,
+					      reg);
+		if (ret) {
+			pr_err("[wilc start]: fail write reg %x\n",
+			       COE_AUTO_PS_ON_NULL_PKT);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+
+		/*TicketId1115*/
+		/*Disable doze coex null frames*/
+		ret = hif_func->hif_read_reg(wilc, COE_AUTO_PS_OFF_NULL_PKT,
+					     &reg);
+		if (ret) {
+			pr_err("[wilc start]: fail read reg %x\n",
+			       COE_AUTO_PS_OFF_NULL_PKT);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		reg &= ~BIT(30);
+		ret = hif_func->hif_write_reg(wilc, COE_AUTO_PS_OFF_NULL_PKT,
+					      reg);
+		if (ret) {
+			pr_err("[wilc start]: fail write reg %x\n",
+			       COE_AUTO_PS_OFF_NULL_PKT);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		/* Disable BT wakeup */
+		ret = hif_func->hif_read_reg(wilc, PWR_SEQ_MISC_CTRL,
+					     &reg);
+		if (ret) {
+			pr_err("[wilc start]: fail read reg %x\n",
+			       PWR_SEQ_MISC_CTRL);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		reg &= ~BIT(29);
+		ret = hif_func->hif_write_reg(wilc, PWR_SEQ_MISC_CTRL,
+					      reg);
+		if (ret) {
+			pr_err("[wilc start]: fail write reg %x\n",
+			       PWR_SEQ_MISC_CTRL);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+
+		bt_init_done = 0;
+	}
+
+	mutex_lock(&wilc->cs);
+
+	pr_info("source: %s, current bus status Wifi: %d, BT: %d\n",
+		 (source == DEV_WIFI ? "Wifi" : "BT"),
+		 wilc->power.status[DEV_WIFI],
+		 wilc->power.status[DEV_BT]);
+
+	if (wilc->power.status[source] == false) {
+		pr_err("power down request for already powered down source %s\n",
+		       (source == DEV_WIFI ? "Wifi" : "BT"));
+	} else if (((source == DEV_WIFI) &&
+		  (wilc->power.status[DEV_BT] == true)) ||
+		  ((source == DEV_BT) &&
+		  (wilc->power.status[DEV_WIFI] == true))) {
+		pr_warn("Another device is preventing power down. request source is %s\n",
+			(source == DEV_WIFI ? "Wifi" : "BT"));
+	} else {
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY, source);
+		ret = wilc->hif_func->hif_deinit(wilc);
+		release_bus(wilc, WILC_BUS_RELEASE_ONLY, source);
+		if (ret) {
+			mutex_unlock(&wilc->cs);
+			return ret;
+		}
+	}
+	wilc->power.status[source] = false;
+
+	mutex_unlock(&wilc->cs);
+
+	return 0;
+}
+
+int wilc_bt_power_up(struct wilc *wilc, int source)
+{
+	int count = 0;
+	int ret;
+	int reg;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+
+	mutex_lock(&wilc->cs);
+
+	pr_debug("source: %s, current bus status Wifi: %d, BT: %d\n",
+		 (source == DEV_WIFI ? "Wifi" : "BT"),
+		 wilc->power.status[DEV_WIFI],
+		 wilc->power.status[DEV_BT]);
+
+	if (wilc->power.status[source] == true) {
+		pr_err("power up request for already powered up source %s\n",
+			 (source == DEV_WIFI ? "Wifi" : "BT"));
+	} else {
+		/*Bug 215*/
+		/*Avoid overlapping between BT and Wifi intialization*/
+		if (wilc->power.status[DEV_WIFI] == true) {
+			while (!wilc->initialized) {
+				msleep(100);
+				if (++count > 20) {
+					pr_warn("Wifi initialize timeout\n");
+					break;
+				}
+			}
+		} else if (wilc->power.status[DEV_BT] == true) {
+			while (!bt_init_done) {
+				msleep(200);
+				if (++count > 30) {
+					pr_warn("BT initialize timeout\n");
+					break;
+				}
+			}
+			/* An additional wait to give BT firmware time to do
+			 * CPLL update as the time measured since the start of
+			 * BT Fw till the end of function "rf_nmi_init_tuner"
+			 * was 71.2 ms
+			 */
+			msleep(100);
+		}
+	}
+
+	if ((wilc->power.status[DEV_WIFI] == true) ||
+		   (wilc->power.status[DEV_BT] == true)) {
+		pr_info("Device already up. request source is %s\n",
+			 (source == DEV_WIFI ? "Wifi" : "BT"));
+	} else {
+		pr_info("WILC POWER UP\n");
+	}
+	wilc->power.status[source] = true;
+	mutex_unlock(&wilc->cs);
+
+	if (source == DEV_BT) {
+		/*TicketId1092*/
+		/*If WiFi is off, force BT*/
+		if (wilc->power.status[DEV_WIFI] == false) {
+			acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+			/*TicketId1115*/
+			/*Disable awake coex null frames*/
+			ret = hif_func->hif_read_reg(wilc,
+						     COE_AUTO_PS_ON_NULL_PKT,
+						     &reg);
+			if (ret) {
+				pr_err("[wilc start]: fail read reg %x\n",
+				       COE_AUTO_PS_ON_NULL_PKT);
+				goto fail;
+			}
+			reg &= ~BIT(30);
+			ret = hif_func->hif_write_reg(wilc,
+						      COE_AUTO_PS_ON_NULL_PKT,
+						      reg);
+			if (ret) {
+				pr_err("[wilc start]: fail write reg %x\n",
+				       COE_AUTO_PS_ON_NULL_PKT);
+				goto fail;
+			}
+
+			/*TicketId1115*/
+			/*Disable doze coex null frames*/
+			ret = hif_func->hif_read_reg(wilc,
+						     COE_AUTO_PS_OFF_NULL_PKT,
+						     &reg);
+			if (ret) {
+				pr_err("[wilc start]: fail read reg %x\n",
+				       COE_AUTO_PS_OFF_NULL_PKT);
+				goto fail;
+			}
+			reg &= ~BIT(30);
+			ret = hif_func->hif_write_reg(wilc,
+						      COE_AUTO_PS_OFF_NULL_PKT,
+						      reg);
+			if (ret) {
+				pr_err("[wilc start]: fail write reg %x\n",
+				       COE_AUTO_PS_OFF_NULL_PKT);
+				goto fail;
+			}
+
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+		}
+
+		/* Enable BT wakeup */
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+		ret = hif_func->hif_read_reg(wilc, PWR_SEQ_MISC_CTRL,
+					     &reg);
+		if (ret) {
+			pr_err("[wilc start]: fail read reg %x ...\n",
+			       PWR_SEQ_MISC_CTRL);
+			goto fail;
+		}
+		reg |= BIT(29);
+		ret = hif_func->hif_write_reg(wilc, PWR_SEQ_MISC_CTRL,
+					      reg);
+		if (ret) {
+			pr_err("[wilc start]: fail write reg %x ...\n",
+			       PWR_SEQ_MISC_CTRL);
+			goto fail;
+		}
+
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+	}
+
+	return 0;
+
+fail:
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+	wilc_bt_power_down(wilc, DEV_BT);
+	return ret;
+}
+
+static void wilc_bt_firmware_download(struct wilc *wilc)
+{
+	u32 offset;
+	u32 addr, size, size2, blksz;
+	u8 *dma_buffer;
+	const struct firmware *wilc_bt_firmware;
+	const u8 *buffer;
+	size_t buffer_size;
+	int ret = 0;
+	u32 reg;
+	const struct wilc_hif_func *hif_func;
+
+	hif_func = wilc->hif_func;
+
+	pr_info("Bluetooth firmware: %s\n", FW_WILC3000_BLE);
+	if (request_firmware(&wilc_bt_firmware, FW_WILC3000_BLE, dev) != 0) {
+		pr_err("%s - firmare not available. Skip!\n", FW_WILC3000_BLE);
+		ret = -1;
+		goto fail_1;
+	}
+
+	buffer = wilc_bt_firmware->data;
+	buffer_size = (size_t)wilc_bt_firmware->size;
+	if (buffer_size <= 0) {
+		pr_err("Firmware size = 0!\n");
+		ret = -1;
+		goto fail_1;
+	}
+
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+	ret = hif_func->hif_write_reg(wilc, 0x4f0000, 0x71);
+	if (ret) {
+		pr_err("[wilc start]: fail write reg 0x4f0000 ...\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+		goto fail_1;
+	}
+
+	/*
+	 * Avoid booting from BT boot ROM. Make sure that Drive IRQN
+	 * [SDIO platform] or SD_DAT3 [SPI platform] to ?1?
+	 */
+	/* Set cortus reset register to register control. */
+	ret = hif_func->hif_read_reg(wilc, 0x3b0090, &reg);
+	if (ret) {
+		pr_err("[wilc start]: fail read reg 0x3b0090 ...\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+		goto fail_1;
+	}
+
+	reg |= (1 << 0);
+	ret = hif_func->hif_write_reg(wilc, 0x3b0090, reg);
+	if (ret) {
+		pr_err("[wilc start]: fail write reg 0x3b0090 ...\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+		goto fail_1;
+	}
+
+	hif_func->hif_read_reg(wilc, 0x3B0400, &reg);
+
+	if (reg & (1ul << 2)) {
+		reg &= ~(1ul << 2);
+	} else {
+		reg |= (1ul << 2);
+		hif_func->hif_write_reg(wilc, 0x3B0400, reg);
+		reg &= ~(1ul << 2);
+	}
+	hif_func->hif_write_reg(wilc, 0x3B0400, reg);
+
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+
+	/* blocks of sizes > 512 causes the wifi to hang! */
+	blksz = (1ul << 9);
+	/* Allocate a DMA coherent  buffer. */
+	dma_buffer = kmalloc(blksz, GFP_KERNEL);
+	if (dma_buffer == NULL) {
+		ret = -5;
+		pr_err("Can't allocate buffer for BT firmware download IO error\n");
+		goto fail_1;
+	}
+	pr_info("Downloading BT firmware size = %zu ...\n", buffer_size);
+
+	offset = 0;
+	addr = 0x400000;
+	size = buffer_size;
+	addr = cpu_to_le32(addr);
+	size = cpu_to_le32(size);
+	offset = 0;
+
+	while (((int)size) && (offset < buffer_size)) {
+		if (size <= blksz)
+			size2 = size;
+		else
+			size2 = blksz;
+
+		/* Copy firmware into a DMA coherent buffer */
+		memcpy(dma_buffer, &buffer[offset], size2);
+
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+		ret = hif_func->hif_block_tx(wilc, addr, dma_buffer, size2);
+
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+
+		if (ret)
+			break;
+
+		addr += size2;
+		offset += size2;
+		size -= size2;
+	}
+
+	if (ret) {
+		ret = -5;
+		pr_err("Can't download BT firmware IO error\n");
+		goto fail;
+	}
+
+fail:
+	kfree(dma_buffer);
+fail_1:
+	pr_debug("Freeing BT FW buffer ...\n");
+	pr_debug("Releasing BT firmware\n");
+	release_firmware(wilc_bt_firmware);
+}
+
+static void wilc_bt_start(struct wilc *wilc)
+{
+	u32 val32 = 0;
+
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+	pr_info("Starting BT firmware\n");
+	/*
+	 * Write the firmware download complete magic value 0x10ADD09E at
+	 * location 0xFFFF000C (Cortus map) or C000C (AHB map).
+	 * This will let the boot-rom code execute from RAM.
+	 */
+	wilc->hif_func->hif_write_reg(wilc, 0x4F000c, 0x10add09e);
+
+	wilc->hif_func->hif_read_reg(wilc, 0x3B0400, &val32);
+	val32 &= ~((1ul << 2) | (1ul << 3));
+	wilc->hif_func->hif_write_reg(wilc, 0x3B0400, val32);
+
+	msleep(100);
+
+	val32 |= ((1ul << 2) | (1ul << 3));
+
+	wilc->hif_func->hif_write_reg(wilc, 0x3B0400, val32);
+
+	pr_info("BT Start Succeeded\n");
+
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+}
+
+static void handle_cmd_pwr_up(char *param)
+{
+	pr_info("AT PWR: bt_power_up\n");
+	bt_init_done = 0;
+
+	if (!wilc_bt->initialized && !wilc_bt->hif_func->hif_is_init(wilc_bt)) {
+		acquire_bus(wilc_bt, WILC_BUS_ACQUIRE_ONLY, DEV_BT);
+		if (wilc_bt->hif_func->hif_init(wilc_bt, false)) {
+			release_bus(wilc_bt, WILC_BUS_RELEASE_ONLY, DEV_BT);
+			return;
+		}
+		release_bus(wilc_bt, WILC_BUS_RELEASE_ONLY, DEV_BT);
+	}
+
+	wilc_bt_power_up(wilc_bt, DEV_BT);
+}
+
+static void handle_cmd_pwr_down(char *param)
+{
+	wilc_bt_power_down(wilc_bt, DEV_BT);
+}
+
+static void handle_cmd_chip_wake_up(char *param)
+{
+	chip_wakeup(wilc_bt, DEV_BT);
+}
+
+static void handle_cmd_chip_allow_sleep(char *param)
+{
+	bt_init_done = 1;
+	chip_allow_sleep(wilc_bt, DEV_BT);
+}
+
+static void handle_cmd_download_fw(char *param)
+{
+	pr_info("AT PWR: bt_download_fw\n");
+
+	wilc_bt_firmware_download(wilc_bt);
+	wilc_bt_start(wilc_bt);
+}
+
+static void handle_cmd_bt_enable(char *param)
+{
+	wilc_bt_power_up(wilc_bt, DEV_BT);
+	wilc_bt_firmware_download(wilc_bt);
+	wilc_bt_start(wilc_bt);
+}
+
+void wilc_bt_init(struct wilc *wilc)
+{
+	wilc_bt = wilc;
+	pr_debug("at_pwr_dev: init\n");
+	wilc_bt_create_device();
+}
+
+void wilc_bt_deinit(void)
+{
+	pr_info("at_pwr_dev: deinit\n");
+
+	mutex_destroy(&wilc_bt->cs);
+
+	cdev_del(&str_chc_dev);
+	device_created = 0;
+	device_destroy(chc_dev_class, chc_dev_no);
+	class_destroy(chc_dev_class);
+	unregister_chrdev_region(chc_dev_no, 1);
+	pr_info("at_pwr_dev: unregistered\n");
+}
--- linux-6.6.51/drivers/net/wireless/microchip/wilc1000/cfg80211.c	2024-12-05 13:07:51.228704400 +0900
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/cfg80211.c	2024-12-04 16:41:31.553548000 +0900
@@ -5,6 +5,7 @@
  */
 
 #include "cfg80211.h"
+#include "netdev.h"
 
 #define GO_NEG_REQ			0x00
 #define GO_NEG_RSP			0x01
@@ -45,7 +46,7 @@
 			BIT(IEEE80211_STYPE_DISASSOC >> 4) |
 			BIT(IEEE80211_STYPE_AUTH >> 4) |
 			BIT(IEEE80211_STYPE_DEAUTH >> 4)
-	}
+	},
 };
 
 #ifdef CONFIG_PM
@@ -105,11 +106,10 @@
 } __packed;
 
 static void cfg_scan_result(enum scan_event scan_event,
-			    struct wilc_rcvd_net_info *info, void *user_void)
+			    struct wilc_rcvd_net_info *info,
+			    struct wilc_priv *priv)
 {
-	struct wilc_priv *priv = user_void;
-
-	if (!priv->cfg_scanning)
+	if (!priv || !priv->cfg_scanning)
 		return;
 
 	if (scan_event == SCAN_EVENT_NETWORK_FOUND) {
@@ -127,12 +127,18 @@
 		if (!channel)
 			return;
 
+		PRINT_D(priv->dev, CFG80211_DBG,
+			"Network Info:: CHANNEL Frequency: %d, RSSI: %d,\n",
+			freq, ((s32)info->rssi * 100));
+
 		bss = cfg80211_inform_bss_frame(wiphy, channel, info->mgmt,
 						info->frame_len,
 						(s32)info->rssi * 100,
 						GFP_KERNEL);
 		cfg80211_put_bss(wiphy, bss);
 	} else if (scan_event == SCAN_EVENT_DONE) {
+		PRINT_INFO(priv->dev, CFG80211_DBG, "Scan Done[%p]\n",
+			   priv->dev);
 		mutex_lock(&priv->scan_req_lock);
 
 		if (priv->scan_req) {
@@ -148,6 +154,7 @@
 	} else if (scan_event == SCAN_EVENT_ABORTED) {
 		mutex_lock(&priv->scan_req_lock);
 
+		PRINT_INFO(priv->dev, CFG80211_DBG, "Scan Aborted\n");
 		if (priv->scan_req) {
 			struct cfg80211_scan_info info = {
 				.aborted = false,
@@ -162,9 +169,8 @@
 }
 
 static void cfg_connect_result(enum conn_event conn_disconn_evt, u8 mac_status,
-			       void *priv_data)
+			       struct wilc_priv *priv)
 {
-	struct wilc_priv *priv = priv_data;
 	struct net_device *dev = priv->dev;
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wl = vif->wilc;
@@ -177,6 +183,9 @@
 	if (conn_disconn_evt == CONN_DISCONN_EVENT_CONN_RESP) {
 		u16 connect_status = conn_info->status;
 
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Connection response received=%d connect_stat[%d]\n",
+			   mac_status, connect_status);
 		if (mac_status == WILC_MAC_STATUS_DISCONNECTED &&
 		    connect_status == WLAN_STATUS_SUCCESS) {
 			connect_status = WLAN_STATUS_UNSPECIFIED_FAILURE;
@@ -188,10 +197,22 @@
 			netdev_err(dev, "Unspecified failure\n");
 		}
 
-		if (connect_status == WLAN_STATUS_SUCCESS)
+		if (connect_status == WLAN_STATUS_SUCCESS) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Connection Successful: BSSID: %x%x%x%x%x%x\n",
+				   conn_info->bssid[0], conn_info->bssid[1],
+				   conn_info->bssid[2], conn_info->bssid[3],
+				   conn_info->bssid[4], conn_info->bssid[5]);
 			memcpy(priv->associated_bss, conn_info->bssid,
 			       ETH_ALEN);
+		}
 
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Association request info elements length = %zu\n",
+			   conn_info->req_ies_len);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Association response info elements length = %d\n",
+			   conn_info->resp_ies_len);
 		cfg80211_ref_bss(wiphy, vif->bss);
 		cfg80211_connect_bss(dev, conn_info->bssid, vif->bss,
 				     conn_info->req_ies,
@@ -205,6 +226,9 @@
 	} else if (conn_disconn_evt == CONN_DISCONN_EVENT_DISCONN_NOTIF) {
 		u16 reason = 0;
 
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Received WILC_MAC_STATUS_DISCONNECTED dev [%p]\n",
+			   priv->dev);
 		eth_zero_addr(priv->associated_bss);
 		wilc_wlan_set_bssid(priv->dev, NULL, WILC_STATION_MODE);
 
@@ -249,11 +273,15 @@
 	}
 
 	channelnum = ieee80211_frequency_to_channel(chandef->chan->center_freq);
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Setting channel %d with frequency %d\n",
+		   channelnum, chandef->chan->center_freq);
 
 	wl->op_ch = channelnum;
 	result = wilc_set_mac_chnl_num(vif, channelnum);
 	if (result)
-		netdev_err(vif->ndev, "Error in setting channel\n");
+		netdev_err(vif->ndev, "Error in setting channel %d\n",
+			   channelnum);
 
 	srcu_read_unlock(&wl->srcu, srcu_idx);
 	return result;
@@ -279,20 +307,34 @@
 		u16 freq = request->channels[i]->center_freq;
 
 		scan_ch_list[i] = ieee80211_frequency_to_channel(freq);
+		PRINT_D(vif->ndev, CFG80211_DBG,
+			"ScanChannel List[%d] = %d",
+			i, scan_ch_list[i]);
 	}
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Requested num of channel %d\n",
+		   request->n_channels);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Scan Request IE len =  %zu\n",
+		   request->ie_len);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Number of SSIDs %d\n",
+		   request->n_ssids);
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Trigger Scan Request\n");
+
 	if (request->n_ssids)
 		scan_type = WILC_FW_ACTIVE_SCAN;
 	else
 		scan_type = WILC_FW_PASSIVE_SCAN;
 
-	ret = wilc_scan(vif, WILC_FW_USER_SCAN, scan_type, scan_ch_list,
-			request->n_channels, cfg_scan_result, (void *)priv,
-			request);
+	ret = wilc_scan(vif, WILC_FW_USER_SCAN, scan_type,
+			scan_ch_list, cfg_scan_result, request);
 
 	if (ret) {
 		priv->scan_req = NULL;
 		priv->cfg_scanning = false;
+		PRINT_WRN(vif->ndev, CFG80211_DBG,
+			  "Device is busy: Error(%d)\n", ret);
 	}
 
 	return ret;
@@ -316,8 +358,40 @@
 
 	vif->connecting = true;
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Connecting to SSID [%s] on netdev [%p] host if [%px]\n",
+		   sme->ssid, dev, priv->hif_drv);
+
+	if (sme->auth_type == NL80211_AUTHTYPE_SAE &&
+	    vif->wilc->chip == WILC_3000){
+		pr_err("WILC3000: WPA3 not supported\n");
+		ret = -ENOTSUPP;
+		goto out_error;
+	}
+
+	if (vif->iftype == WILC_CLIENT_MODE)
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Connected to Direct network,OBSS disabled\n");
+
+	PRINT_D(vif->ndev, CFG80211_DBG, "Required SSID= %s\n, AuthType= %d\n",
+		sme->ssid, sme->auth_type);
+
+	PRINT_D(vif->ndev, CFG80211_DBG, "sme->crypto.wpa_versions=%x\n",
+		sme->crypto.wpa_versions);
+	PRINT_D(vif->ndev, CFG80211_DBG, "sme->crypto.cipher_group=%x\n",
+		sme->crypto.cipher_group);
+	PRINT_D(vif->ndev, CFG80211_DBG, "sme->crypto.n_ciphers_pairwise=%d\n",
+		sme->crypto.n_ciphers_pairwise);
+	for (i = 0; i < sme->crypto.n_ciphers_pairwise; i++)
+		PRINT_D(vif->ndev, CORECONFIG_DBG,
+			"sme->crypto.ciphers_pairwise[%d]=%x\n", i,
+			sme->crypto.ciphers_pairwise[i]);
+
 	cipher_group = sme->crypto.cipher_group;
 	if (cipher_group != 0) {
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   ">> sme->crypto.wpa_versions: %x\n",
+			   sme->crypto.wpa_versions);
 		if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2) {
 			if (cipher_group == WLAN_CIPHER_SUITE_TKIP)
 				security = WILC_FW_SEC_WPA2_TKIP;
@@ -348,8 +422,14 @@
 		}
 	}
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Adding key with cipher group %x\n",
+		   cipher_group);
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Authentication Type = %d\n",
+		   sme->auth_type);
 	switch (sme->auth_type) {
 	case NL80211_AUTHTYPE_OPEN_SYSTEM:
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "In OPEN SYSTEM\n");
 		auth_type = WILC_FW_AUTH_OPEN_SYSTEM;
 		break;
 
@@ -364,6 +444,9 @@
 		break;
 
 	default:
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Automatic Authentication type= %d\n",
+			   sme->auth_type);
 		break;
 	}
 
@@ -404,6 +487,7 @@
 	}
 
 	ch = ieee80211_frequency_to_channel(bss->channel->center_freq);
+	PRINT_D(vif->ndev, CFG80211_DBG, "Required Channel = %d\n", ch);
 	vif->wilc->op_ch = ch;
 	if (vif->iftype != WILC_CLIENT_MODE)
 		vif->wilc->sta_ch = ch;
@@ -412,9 +496,8 @@
 
 	wfi_drv->conn_info.security = security;
 	wfi_drv->conn_info.auth_type = auth_type;
-	wfi_drv->conn_info.ch = ch;
 	wfi_drv->conn_info.conn_result = cfg_connect_result;
-	wfi_drv->conn_info.arg = priv;
+	wfi_drv->conn_info.priv = priv;
 	wfi_drv->conn_info.param = join_params;
 
 	if (sme->mfp == NL80211_MFP_OPTIONAL)
@@ -454,24 +537,21 @@
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc_priv *priv = &vif->priv;
 	struct wilc *wilc = vif->wilc;
+	struct host_if_drv *wfi_drv;
 	int ret;
 
 	vif->connecting = false;
 
 	if (!wilc)
 		return -EIO;
-
-	if (wilc->close) {
-		/* already disconnected done */
-		cfg80211_disconnected(dev, 0, NULL, 0, true, GFP_KERNEL);
-		return 0;
-	}
-
+	wfi_drv = (struct host_if_drv *)priv->hif_drv;
 	if (vif->iftype != WILC_CLIENT_MODE)
 		wilc->sta_ch = WILC_INVALID_CHANNEL;
 	wilc_wlan_set_bssid(priv->dev, NULL, WILC_STATION_MODE);
 
-	priv->hif_drv->p2p_timeout = 0;
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Disconnecting with reason code(%d)\n", reason_code);
+	wfi_drv->p2p_timeout = 0;
 
 	ret = wilc_disconnect(vif);
 	if (ret != 0) {
@@ -554,6 +634,13 @@
 	struct wilc_priv *priv = &vif->priv;
 	struct wilc_wfi_key *key;
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Adding key with cipher suite = %x\n", params->cipher);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "%px %px %d\n", wiphy,
+		   netdev, key_index);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "key %x %x %x\n", params->key[0],
+		   params->key[1],
+		   params->key[2]);
 	switch (params->cipher) {
 	case WLAN_CIPHER_SUITE_TKIP:
 	case WLAN_CIPHER_SUITE_CCMP:
@@ -582,6 +669,10 @@
 
 				key = priv->wilc_gtk[key_index];
 			} else {
+				PRINT_D(vif->ndev, CFG80211_DBG,
+					"STA Address: %x%x%x%x%x\n",
+					mac_addr[0], mac_addr[1], mac_addr[2],
+					mac_addr[3], mac_addr[4]);
 				if (params->cipher == WLAN_CIPHER_SUITE_TKIP)
 					mode = WILC_FW_SEC_WPA_TKIP;
 				else
@@ -711,6 +802,7 @@
 			key_params.seq_len = priv->wilc_gtk[key_index]->seq_len;
 		}
 	} else {
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Getting pairwise key\n");
 		key_params.key = priv->wilc_ptk[key_index]->key;
 		key_params.cipher = priv->wilc_ptk[key_index]->cipher;
 		key_params.key_len = priv->wilc_ptk[key_index]->key_len;
@@ -750,6 +842,8 @@
 	u32 inactive_time = 0;
 
 	if (vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE) {
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Getting station parameters\n");
 		for (i = 0; i < NUM_STA_ASSOCIATED; i++) {
 			if (!(memcmp(mac,
 				     priv->assoc_stainfo.sta_associated_bss[i],
@@ -768,11 +862,16 @@
 
 		wilc_get_inactive_time(vif, mac, &inactive_time);
 		sinfo->inactive_time = 1000 * inactive_time;
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Inactive time %d\n",
+			   sinfo->inactive_time);
 	} else if (vif->iftype == WILC_STATION_MODE) {
 		struct rf_info stats;
 
-		if (!wilc->initialized)
+		if (!wilc->initialized) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "driver not initialized\n");
 			return -EBUSY;
+		}
 
 		wilc_get_statistics(vif, &stats);
 
@@ -793,6 +892,11 @@
 			wilc_enable_tcp_ack_filter(vif, true);
 		else if (stats.link_speed != DEFAULT_LINK_SPEED)
 			wilc_enable_tcp_ack_filter(vif, false);
+
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   "*** stats[%d][%d][%d][%d][%d]\n", sinfo->signal,
+			   sinfo->rx_packets, sinfo->tx_packets,
+			   sinfo->tx_failed, sinfo->txrate.legacy);
 	}
 	return 0;
 }
@@ -800,6 +904,7 @@
 static int change_bss(struct wiphy *wiphy, struct net_device *dev,
 		      struct bss_parameters *params)
 {
+	PRINT_INFO(dev, CFG80211_DBG, "Changing Bss parametrs\n");
 	return 0;
 }
 
@@ -818,7 +923,9 @@
 		goto out;
 
 	priv = &vif->priv;
+
 	cfg_param_val.flag = 0;
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Setting Wiphy params\n");
 
 	if (changed & WIPHY_PARAM_RETRY_SHORT) {
 		netdev_dbg(vif->ndev,
@@ -862,6 +969,8 @@
 		}
 	}
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Setting CFG params in the host interface\n");
 	ret = wilc_hif_set_cfg(vif, &cfg_param_val);
 	if (ret)
 		netdev_err(priv->dev, "Error in setting WIPHY PARAMS\n");
@@ -880,14 +989,20 @@
 	int ret = 0;
 	u8 flag = 0;
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Setting PMKSA\n");
+
 	for (i = 0; i < priv->pmkid_list.numpmkid; i++)	{
 		if (!memcmp(pmksa->bssid, priv->pmkid_list.pmkidlist[i].bssid,
 			    ETH_ALEN)) {
 			flag = PMKID_FOUND;
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "PMKID already exists\n");
 			break;
 		}
 	}
 	if (i < WILC_MAX_NUM_PMKIDS) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Setting PMKID in private structure\n");
 		memcpy(priv->pmkid_list.pmkidlist[i].bssid, pmksa->bssid,
 		       ETH_ALEN);
 		memcpy(priv->pmkid_list.pmkidlist[i].pmkid, pmksa->pmkid,
@@ -899,9 +1014,11 @@
 		ret = -EINVAL;
 	}
 
-	if (!ret)
+	if (!ret) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Setting pmkid in the host interface\n");
 		ret = wilc_set_pmkid_info(vif, &priv->pmkid_list);
-
+	}
 	return ret;
 }
 
@@ -912,9 +1029,13 @@
 	struct wilc_vif *vif = netdev_priv(netdev);
 	struct wilc_priv *priv = &vif->priv;
 
+	PRINT_INFO(netdev, CFG80211_DBG, "Deleting PMKSA keys\n");
+
 	for (i = 0; i < priv->pmkid_list.numpmkid; i++)	{
 		if (!memcmp(pmksa->bssid, priv->pmkid_list.pmkidlist[i].bssid,
 			    ETH_ALEN)) {
+			PRINT_INFO(netdev, CFG80211_DBG,
+				   "Resetting PMKID values\n");
 			memset(&priv->pmkid_list.pmkidlist[i], 0,
 			       sizeof(struct wilc_pmkid));
 			break;
@@ -941,11 +1062,31 @@
 {
 	struct wilc_vif *vif = netdev_priv(netdev);
 
+	PRINT_INFO(netdev, CFG80211_DBG, "Flushing  PMKID key values\n");
 	memset(&vif->priv.pmkid_list, 0, sizeof(struct wilc_pmkid_attr));
 
 	return 0;
 }
 
+static inline void wilc_wfi_cfg_parse_p2p_intent_attr(u8 *buf, u32 len,
+						      bool p2p_mode)
+{
+	struct wilc_attr_entry *e;
+	u32 index = 0;
+
+	while (index + sizeof(*e) <= len) {
+		e = (struct wilc_attr_entry *)&buf[index];
+		if (e->attr_type == IEEE80211_P2P_ATTR_GO_INTENT) {
+			if (p2p_mode == WILC_P2P_ROLE_GO)
+				e->val[0] = (e->val[0]  & 0x01) | (0x0f << 1);
+			else
+				e->val[0] = (e->val[0]  & 0x01) | (0x00 << 1);
+			return;
+		}
+		index += le16_to_cpu(e->attr_len) + sizeof(*e);
+	}
+}
+
 static inline void wilc_wfi_cfg_parse_ch_attr(u8 *buf, u32 len, u8 sta_ch)
 {
 	struct wilc_attr_entry *e;
@@ -1025,7 +1166,7 @@
 	return cfg80211_rx_mgmt(&priv->wdev, freq, 0, buff, size, 0);
 }
 
-void wilc_wfi_p2p_rx(struct wilc_vif *vif, u8 *buff, u32 size)
+bool wilc_wfi_p2p_rx(struct wilc_vif *vif, u8 *buff, u32 size)
 {
 	struct wilc *wl = vif->wilc;
 	struct wilc_priv *priv = &vif->priv;
@@ -1037,6 +1178,7 @@
 	const u8 *vendor_ie;
 	u32 header, pkt_offset;
 	s32 freq;
+	int ret;
 
 	header = get_unaligned_le32(buff - HOST_HDR_OFFSET);
 	pkt_offset = FIELD_GET(WILC_PKT_HDR_OFFSET_FIELD, header);
@@ -1051,25 +1193,31 @@
 
 		cfg80211_mgmt_tx_status(&priv->wdev, priv->tx_cookie, buff,
 					size, ack, GFP_KERNEL);
-		return;
+		return true;
 	}
 
 	freq = ieee80211_channel_to_frequency(wl->op_ch, NL80211_BAND_2GHZ);
 
 	mgmt = (struct ieee80211_mgmt *)buff;
+	PRINT_D(vif->ndev, GENERIC_DBG, "Rx Frame Type:%x\n",
+		mgmt->frame_control);
 	if (!ieee80211_is_action(mgmt->frame_control))
 		goto out_rx_mgmt;
 
 	if (priv->cfg_scanning &&
 	    time_after_eq(jiffies, (unsigned long)wfi_drv->p2p_timeout)) {
 		netdev_dbg(vif->ndev, "Receiving action wrong ch\n");
-		return;
+		return false;
 	}
 
 	if (!ieee80211_is_public_action((struct ieee80211_hdr *)buff, size))
 		goto out_rx_mgmt;
 
 	d = (struct wilc_p2p_pub_act_frame *)(&mgmt->u.action);
+	PRINT_D(vif->ndev, GENERIC_DBG,
+		"Rx Action action: %x category %x oui type %x sub_type[%d]\n",
+		d->action, d->category, d->oui_type, d->oui_subtype);
+
 	if (d->oui_subtype != GO_NEG_REQ && d->oui_subtype != GO_NEG_RSP &&
 	    d->oui_subtype != P2P_INV_REQ && d->oui_subtype != P2P_INV_RSP)
 		goto out_rx_mgmt;
@@ -1080,10 +1228,16 @@
 		goto out_rx_mgmt;
 
 	p = (struct wilc_vendor_specific_ie *)vendor_ie;
+	/* use p2p mode invert value to treat other p2p device
+	 * opposite of mode set on this device.
+	 */
+	wilc_wfi_cfg_parse_p2p_intent_attr(p->attr, p->tag_len - 4,
+					   !vif->wilc->attr_sysfs.p2p_mode);
 	wilc_wfi_cfg_parse_ch_attr(p->attr, p->tag_len - 4, vif->wilc->sta_ch);
 
 out_rx_mgmt:
-	cfg80211_rx_mgmt(&priv->wdev, freq, 0, buff, size, 0);
+	ret = cfg80211_rx_mgmt(&priv->wdev, freq, 0, buff, size, 0);
+	return ret;
 }
 
 static void wilc_wfi_mgmt_tx_complete(void *priv, int status)
@@ -1094,18 +1248,21 @@
 	kfree(pv_data);
 }
 
-static void wilc_wfi_remain_on_channel_expired(void *data, u64 cookie)
+static void wilc_wfi_remain_on_channel_expired(struct wilc_vif *vif, u64 cookie)
 {
-	struct wilc_vif *vif = data;
 	struct wilc_priv *priv = &vif->priv;
 	struct wilc_wfi_p2p_listen_params *params = &priv->remain_on_ch_params;
 
-	if (cookie != params->listen_cookie)
+	if (cookie != priv->remain_on_ch_params.listen_cookie) {
+		PRINT_INFO(priv->dev, GENERIC_DBG,
+			   "Received cookies didn't match received[%llu] Expected[%llu]\n",
+			   cookie, priv->remain_on_ch_params.listen_cookie);
 		return;
+	}
 
-	priv->p2p_listen_state = false;
+	vif->p2p_listen_state = false;
 
-	cfg80211_remain_on_channel_expired(&priv->wdev, params->listen_cookie,
+	cfg80211_remain_on_channel_expired(&vif->priv.wdev, cookie,
 					   params->listen_ch, GFP_KERNEL);
 }
 
@@ -1128,9 +1285,8 @@
 	if (id == 0)
 		id = ++priv->inc_roc_cookie;
 
-	ret = wilc_remain_on_channel(vif, id, duration, chan->hw_value,
-				     wilc_wfi_remain_on_channel_expired,
-				     (void *)vif);
+	ret = wilc_remain_on_channel(vif, id, chan->hw_value,
+				     wilc_wfi_remain_on_channel_expired);
 	if (ret)
 		return ret;
 
@@ -1139,13 +1295,17 @@
 	priv->remain_on_ch_params.listen_ch = chan;
 	priv->remain_on_ch_params.listen_cookie = id;
 	*cookie = id;
-	priv->p2p_listen_state = true;
+	vif->p2p_listen_state = true;
 	priv->remain_on_ch_params.listen_duration = duration;
 
 	cfg80211_ready_on_channel(wdev, *cookie, chan, duration, GFP_KERNEL);
 	mod_timer(&vif->hif_drv->remain_on_ch_timer,
 		  jiffies + msecs_to_jiffies(duration + 1000));
 
+	PRINT_INFO(vif->ndev, GENERIC_DBG,
+		   "Remaining on duration [%d] [%llu] op_ch[%d]\n",
+		   duration, priv->remain_on_ch_params.listen_cookie,
+		   vif->wilc->op_ch);
 	return ret;
 }
 
@@ -1156,6 +1316,9 @@
 	struct wilc_vif *vif = netdev_priv(wdev->netdev);
 	struct wilc_priv *priv = &vif->priv;
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "cookie received[%llu] expected[%llu]\n",
+		   cookie, priv->remain_on_ch_params.listen_cookie);
 	if (cookie != priv->remain_on_ch_params.listen_cookie)
 		return -ENOENT;
 
@@ -1186,18 +1349,26 @@
 	priv->tx_cookie = *cookie;
 	mgmt = (const struct ieee80211_mgmt *)buf;
 
-	if (!ieee80211_is_mgmt(mgmt->frame_control))
+	if (!ieee80211_is_mgmt(mgmt->frame_control)) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "This function transmits only management frames\n");
 		goto out;
+	}
 
 	mgmt_tx = kmalloc(sizeof(*mgmt_tx), GFP_KERNEL);
 	if (!mgmt_tx) {
-		ret = -ENOMEM;
-		goto out;
+		PRINT_ER(vif->ndev,
+			 "%s failed to allocate memory for structure\n",
+			 __func__);
+		return -ENOMEM;
 	}
 
 	mgmt_tx->buff = kmemdup(buf, len, GFP_KERNEL);
 	if (!mgmt_tx->buff) {
 		ret = -ENOMEM;
+		PRINT_ER(vif->ndev,
+			 "%s Failed to allocate memory buff\n",
+			 __func__);
 		kfree(mgmt_tx);
 		goto out;
 	}
@@ -1205,6 +1376,9 @@
 	mgmt_tx->size = len;
 
 	if (ieee80211_is_probe_resp(mgmt->frame_control)) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "TX: Probe Response\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "Setting channel: %d\n",
+			   chan->hw_value);
 		wilc_set_mac_chnl_num(vif, chan->hw_value);
 		vif->wilc->op_ch = chan->hw_value;
 		goto out_txq_add_pkt;
@@ -1219,14 +1393,20 @@
 		goto out_set_timeout;
 	}
 
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "ACTION FRAME:%x\n",
+		   (u16)mgmt->frame_control);
+
 	d = (struct wilc_p2p_pub_act_frame *)(&mgmt->u.action);
 	if (d->oui_type != WLAN_OUI_TYPE_WFA_P2P ||
 	    d->oui_subtype != GO_NEG_CONF) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "Setting channel: %d\n",
+			   chan->hw_value);
 		wilc_set_mac_chnl_num(vif, chan->hw_value);
 		vif->wilc->op_ch = chan->hw_value;
 	}
 
-	if (d->oui_subtype != P2P_INV_REQ && d->oui_subtype != P2P_INV_RSP)
+	if (d->oui_subtype != GO_NEG_REQ && d->oui_subtype != GO_NEG_RSP &&
+	    d->oui_subtype != P2P_INV_REQ && d->oui_subtype != P2P_INV_RSP)
 		goto out_set_timeout;
 
 	vendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P,
@@ -1236,14 +1416,27 @@
 		goto out_set_timeout;
 
 	p = (struct wilc_vendor_specific_ie *)vendor_ie;
-	wilc_wfi_cfg_parse_ch_attr(p->attr, p->tag_len - 4, vif->wilc->sta_ch);
-
+	wilc_wfi_cfg_parse_p2p_intent_attr(p->attr, p->tag_len - 4,
+					   vif->wilc->attr_sysfs.p2p_mode);
+	/*
+	 * Update only the go_intent value and don't modify the channel list
+	 * attributes values for GO_REQ and GO_Response to retain
+	 * previous logic.  For mgmt_tx only INVITATION_REQ and INVITATION_RES
+	 * frame update the channel list attribute.
+	 */
+
+	if (d->oui_subtype == P2P_INV_REQ && d->oui_subtype == P2P_INV_RSP)
+		wilc_wfi_cfg_parse_ch_attr(p->attr, p->tag_len - 4,
+					   vif->wilc->sta_ch);
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG,
+		   "TX: ACTION FRAME Type:%x : Chan:%d\n", d->action,
+		   chan->hw_value);
 out_set_timeout:
 	wfi_drv->p2p_timeout = (jiffies + msecs_to_jiffies(wait));
 
 out_txq_add_pkt:
-
-	wilc_wlan_txq_add_mgmt_pkt(wdev->netdev, mgmt_tx,
+	wilc_wlan_txq_add_mgmt_pkt(priv->wdev.netdev, mgmt_tx,
 				   mgmt_tx->buff, mgmt_tx->size,
 				   wilc_wfi_mgmt_tx_complete);
 
@@ -1262,7 +1455,7 @@
 
 	wfi_drv->p2p_timeout = jiffies;
 
-	if (!priv->p2p_listen_state) {
+	if (!vif->p2p_listen_state) {
 		struct wilc_wfi_p2p_listen_params *params;
 
 		params = &priv->remain_on_ch_params;
@@ -1323,6 +1516,7 @@
 static int set_cqm_rssi_config(struct wiphy *wiphy, struct net_device *dev,
 			       s32 rssi_thold, u32 rssi_hyst)
 {
+	PRINT_INFO(dev, CFG80211_DBG, "Setting CQM RSSi Function\n");
 	return 0;
 }
 
@@ -1335,6 +1529,8 @@
 	if (idx != 0)
 		return -ENOENT;
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Dumping station information\n");
+
 	ret = wilc_get_rssi(vif, &sinfo->signal);
 	if (ret)
 		return ret;
@@ -1350,8 +1546,15 @@
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc_priv *priv = &vif->priv;
 
-	if (!priv->hif_drv)
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "dev [%s]\n", dev->name);
+	if (!priv->hif_drv) {
+		PRINT_ER(dev, "hif driver is NULL\n");
 		return -EIO;
+	}
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   " Power save Enabled= %d , TimeOut = %d\n", enabled,
+		   timeout);
 
 	wilc_set_power_mgmt(vif, enabled, timeout);
 
@@ -1366,9 +1569,16 @@
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc_priv *priv = &vif->priv;
 
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+		   "In Change virtual interface function\n");
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+		   "Wireless interface name =%s\n", dev->name);
+
 	switch (type) {
 	case NL80211_IFTYPE_STATION:
 		vif->connecting = false;
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_STATION\n");
 		dev->ieee80211_ptr->iftype = type;
 		priv->wdev.iftype = type;
 		vif->monitor_flag = 0;
@@ -1386,6 +1596,8 @@
 
 	case NL80211_IFTYPE_P2P_CLIENT:
 		vif->connecting = false;
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_P2P_CLIENT\n");
 		dev->ieee80211_ptr->iftype = type;
 		priv->wdev.iftype = type;
 		vif->monitor_flag = 0;
@@ -1397,6 +1609,8 @@
 		break;
 
 	case NL80211_IFTYPE_AP:
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_AP\n");
 		dev->ieee80211_ptr->iftype = type;
 		priv->wdev.iftype = type;
 		vif->iftype = WILC_AP_MODE;
@@ -1407,6 +1621,10 @@
 		break;
 
 	case NL80211_IFTYPE_P2P_GO:
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_GO\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "start duringIP timer\n");
+
 		dev->ieee80211_ptr->iftype = type;
 		priv->wdev.iftype = type;
 		vif->iftype = WILC_GO_MODE;
@@ -1415,6 +1633,18 @@
 			wilc_set_operation_mode(vif, wilc_get_vif_idx(vif),
 						WILC_AP_MODE, vif->idx);
 		break;
+	case NL80211_IFTYPE_MONITOR:
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_MONITOR\n");
+		dev->ieee80211_ptr->iftype = type;
+		dev->type = ARPHRD_IEEE80211_RADIOTAP;
+		priv->wdev.iftype = type;
+		vif->iftype = WILC_MONITOR_MODE;
+
+		if (wl->initialized)
+			wilc_set_operation_mode(vif, wilc_get_vif_idx(vif),
+						WILC_MONITOR_MODE, vif->idx);
+		break;
 
 	default:
 		netdev_err(dev, "Unknown interface type= %d\n", type);
@@ -1430,6 +1660,7 @@
 	struct wilc_vif *vif = netdev_priv(dev);
 	int ret;
 
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG, "Starting ap\n");
 	ret = set_channel(wiphy, &settings->chandef);
 	if (ret != 0)
 		netdev_err(dev, "Error in setting channel\n");
@@ -1445,6 +1676,8 @@
 {
 	struct wilc_vif *vif = netdev_priv(dev);
 
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG, "Setting beacon\n");
+
 	return wilc_add_beacon(vif, 0, 0, beacon);
 }
 
@@ -1454,6 +1687,8 @@
 	int ret;
 	struct wilc_vif *vif = netdev_priv(dev);
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Deleting beacon\n");
+
 	wilc_wlan_set_bssid(dev, NULL, WILC_AP_MODE);
 
 	ret = wilc_del_beacon(vif);
@@ -1472,6 +1707,41 @@
 	struct wilc_priv *priv = &vif->priv;
 
 	if (vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE) {
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Adding station parameters %d\n", params->aid);
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG, "ASSOC ID = %d\n",
+			   params->aid);
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Number of supported rates = %d\n",
+			   params->link_sta_params.supported_rates_len);
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "IS HT supported = %d\n",
+			   (!params->link_sta_params.ht_capa) ? false : true);
+
+		if (params->link_sta_params.ht_capa) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Capability Info = %d\n",
+				   params->link_sta_params.ht_capa->cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "AMPDU Params = %d\n",
+				   params->link_sta_params.ht_capa->ampdu_params_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "HT Extended params= %d\n",
+				   params->link_sta_params.ht_capa->extended_ht_cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Tx Beamforming Cap= %d\n",
+				   params->link_sta_params.ht_capa->tx_BF_cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Antenna selection info = %d\n",
+				   params->link_sta_params.ht_capa->antenna_selection_info);
+		}
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Mask = %d\n",
+			   params->sta_flags_mask);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Set = %d\n",
+			   params->sta_flags_set);
+
 		memcpy(priv->assoc_stainfo.sta_associated_bss[params->aid], mac,
 		       ETH_ALEN);
 
@@ -1495,10 +1765,19 @@
 	if (!(vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE))
 		return ret;
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Deleting station\n");
+
 	info = &priv->assoc_stainfo;
 
-	if (!mac)
+	if (!mac) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "All associated stations\n");
 		ret = wilc_del_allstation(vif, info->sta_associated_bss);
+	} else {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "With mac address: %x%x%x%x%x%x\n",
+			   mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+	}
 
 	ret = wilc_del_station(vif, mac);
 	if (ret)
@@ -1512,7 +1791,39 @@
 	int ret = 0;
 	struct wilc_vif *vif = netdev_priv(dev);
 
+	PRINT_D(vif->ndev, CFG80211_DBG, "Change station parameters\n");
+
 	if (vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "BSSID = %x%x%x%x%x%x\n",
+			   mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "ASSOC ID = %d\n",
+			   params->aid);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Number of supported rates = %d\n",
+			   params->link_sta_params.supported_rates_len);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "IS HT supported = %d\n",
+			   (!params->link_sta_params.ht_capa) ? false : true);
+		if (params->link_sta_params.ht_capa) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Capability Info = %d\n",
+				   params->link_sta_params.ht_capa->cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "AMPDU Params = %d\n",
+				   params->link_sta_params.ht_capa->ampdu_params_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "HT Extended params= %d\n",
+				   params->link_sta_params.ht_capa->extended_ht_cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Tx Beamforming Cap= %d\n",
+				   params->link_sta_params.ht_capa->tx_BF_cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Antenna selection info = %d\n",
+				   params->link_sta_params.ht_capa->antenna_selection_info);
+		}
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Mask = %d\n",
+			   params->sta_flags_mask);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Set = %d\n",
+			   params->sta_flags_set);
 		ret = wilc_edit_station(vif, mac, params);
 		if (ret)
 			netdev_err(dev, "Host edit station fail\n");
@@ -1520,7 +1831,7 @@
 	return ret;
 }
 
-static struct wilc_vif *wilc_get_vif_from_type(struct wilc *wl, int type)
+struct wilc_vif *wilc_get_vif_from_type(struct wilc *wl, int type)
 {
 	struct wilc_vif *vif;
 
@@ -1561,9 +1872,14 @@
 			srcu_read_unlock(&wl->srcu, srcu_idx);
 			goto validate_interface;
 		}
-
-		ndev = wilc_wfi_init_mon_interface(wl, name, vif->ndev);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Initializing mon ifc virtual device driver\n");
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Adding monitor interface[%p]\n", vif->ndev);
+		ndev = wilc_wfi_init_mon_interface(vif->wilc, name, vif->ndev);
 		if (ndev) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Setting monitor flag in private structure\n");
 			vif->monitor_flag = 1;
 		} else {
 			srcu_read_unlock(&wl->srcu, srcu_idx);
@@ -1591,6 +1907,9 @@
 	case NL80211_IFTYPE_AP:
 		iftype = WILC_AP_MODE;
 		break;
+	case NL80211_IFTYPE_MONITOR:
+		iftype = WILC_MONITOR_MODE;
+		break;
 	default:
 		return ERR_PTR(-EOPNOTSUPP);
 	}
@@ -1607,11 +1926,15 @@
 	struct wilc *wl = wiphy_priv(wiphy);
 	struct wilc_vif *vif;
 
+	if (wdev->iftype == NL80211_IFTYPE_MONITOR) {
+		wilc_wfi_deinit_mon_interface(wl, true);
+		return 0;
+	}
+
 	if (wdev->iftype == NL80211_IFTYPE_AP ||
 	    wdev->iftype == NL80211_IFTYPE_P2P_GO)
 		wilc_wfi_deinit_mon_interface(wl, true);
 	vif = netdev_priv(wdev->netdev);
-	cfg80211_stop_iface(wiphy, wdev, GFP_KERNEL);
 	cfg80211_unregister_netdevice(vif->ndev);
 	vif->monitor_flag = 0;
 
@@ -1625,13 +1948,6 @@
 
 static int wilc_suspend(struct wiphy *wiphy, struct cfg80211_wowlan *wow)
 {
-	struct wilc *wl = wiphy_priv(wiphy);
-
-	if (!wow && wilc_wlan_get_num_conn_ifcs(wl))
-		wl->suspend_event = true;
-	else
-		wl->suspend_event = false;
-
 	return 0;
 }
 
@@ -1677,7 +1993,7 @@
 		return -EINVAL;
 	}
 
-	netdev_info(vif->ndev, "Setting tx power %d\n", tx_power);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Setting tx power %d\n", tx_power);
 	if (tx_power < 0)
 		tx_power = 0;
 	else if (tx_power > 18)
@@ -1705,6 +2021,36 @@
 	if (ret)
 		netdev_err(vif->ndev, "Failed to get tx power\n");
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Got tx power %d\n", *dbm);
+
+	return ret;
+}
+
+static int set_antenna(struct wiphy *wiphy, u32 tx_ant, u32 rx_ant)
+{
+	int ret;
+	struct wilc *wl = wiphy_priv(wiphy);
+	struct wilc_vif *vif;
+	int srcu_idx;
+
+	srcu_idx = srcu_read_lock(&wl->srcu);
+	vif = wilc_get_wl_to_vif(wl);
+	if (IS_ERR(vif)) {
+		srcu_read_unlock(&wl->srcu, srcu_idx);
+		return -EINVAL;
+	}
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Select antenna mode %d\n", tx_ant);
+	if (!tx_ant || !rx_ant) {
+		srcu_read_unlock(&wl->srcu, srcu_idx);
+		return -EINVAL;
+	}
+
+	ret = wilc_set_antenna(vif, (u8)(tx_ant-1));
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to set tx antenna\n");
+	srcu_read_unlock(&wl->srcu, srcu_idx);
+
 	return ret;
 }
 
@@ -1750,7 +2096,7 @@
 	.set_wakeup = wilc_set_wakeup,
 	.set_tx_power = set_tx_power,
 	.get_tx_power = get_tx_power,
-
+	.set_antenna = set_antenna,
 };
 
 static void wlan_init_locks(struct wilc *wl)
@@ -1760,6 +2106,7 @@
 	mutex_init(&wl->cfg_cmd_lock);
 	mutex_init(&wl->vif_mutex);
 	mutex_init(&wl->deinit_lock);
+	mutex_init(&wl->cs);
 
 	spin_lock_init(&wl->txq_spinlock);
 	mutex_init(&wl->txq_add_to_head_cs);
@@ -1768,6 +2115,7 @@
 	init_completion(&wl->cfg_event);
 	init_completion(&wl->sync_event);
 	init_completion(&wl->txq_thread_started);
+	init_completion(&wl->debug_thread_started);
 	init_srcu_struct(&wl->srcu);
 }
 
@@ -1778,6 +2126,7 @@
 	mutex_destroy(&wilc->cfg_cmd_lock);
 	mutex_destroy(&wilc->txq_add_to_head_cs);
 	mutex_destroy(&wilc->vif_mutex);
+	mutex_destroy(&wilc->cs);
 	mutex_destroy(&wilc->deinit_lock);
 	cleanup_srcu_struct(&wilc->srcu);
 }
@@ -1785,9 +2134,9 @@
 int wilc_cfg80211_init(struct wilc **wilc, struct device *dev, int io_type,
 		       const struct wilc_hif_func *ops)
 {
+	int i, ret;
 	struct wilc *wl;
 	struct wilc_vif *vif;
-	int ret, i;
 
 	wl = wilc_create_wiphy(dev);
 	if (!wl)
@@ -1799,10 +2148,12 @@
 	if (ret)
 		goto free_wl;
 
+#ifdef WILC_DEBUGFS
+	wilc_debugfs_init();
+#endif
 	*wilc = wl;
 	wl->io_type = io_type;
 	wl->hif_func = ops;
-
 	for (i = 0; i < NQUEUES; i++)
 		INIT_LIST_HEAD(&wl->txq[i].txq_head.list);
 
@@ -1822,21 +2173,24 @@
 		goto free_hq;
 	}
 
+	wilc_sysfs_init(wl);
+
 	return 0;
 
 free_hq:
 	destroy_workqueue(wl->hif_workqueue);
 
 free_cfg:
+#ifdef WILC_DEBUGFS
+	wilc_debugfs_remove();
+#endif
 	wilc_wlan_cfg_deinit(wl);
-
 free_wl:
 	wlan_deinit_locks(wl);
 	wiphy_unregister(wl->wiphy);
 	wiphy_free(wl->wiphy);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(wilc_cfg80211_init);
 
 struct wilc *wilc_create_wiphy(struct device *dev)
 {
@@ -1876,6 +2230,8 @@
 	       sizeof(wilc_cipher_suites));
 	wiphy->cipher_suites = wl->cipher_suites;
 	wiphy->n_cipher_suites = ARRAY_SIZE(wilc_cipher_suites);
+	wiphy->available_antennas_tx = 0x3;
+	wiphy->available_antennas_rx = 0x3;
 	wiphy->mgmt_stypes = wilc_wfi_cfg80211_mgmt_types;
 
 	wiphy->max_remain_on_channel_duration = 500;
@@ -1902,7 +2258,10 @@
 	struct wilc_vif *vif = netdev_priv(net);
 	struct wilc_priv *priv = &vif->priv;
 
-	priv->p2p_listen_state = false;
+	PRINT_INFO(net, INIT_DBG, "Host[%p][%p]\n", net, net->ieee80211_ptr);
+	timer_setup(&priv->eap_buff_timer, eap_buff_timeout, 0);
+
+	vif->p2p_listen_state = false;
 
 	mutex_init(&priv->scan_req_lock);
 	ret = wilc_init(net, &priv->hif_drv);
@@ -1918,12 +2277,14 @@
 	struct wilc_vif *vif = netdev_priv(net);
 	struct wilc_priv *priv = &vif->priv;
 
-	priv->p2p_listen_state = false;
+	vif->p2p_listen_state = false;
 
 	flush_workqueue(vif->wilc->hif_workqueue);
 	mutex_destroy(&priv->scan_req_lock);
 	ret = wilc_deinit(vif);
 
+	del_timer_sync(&priv->eap_buff_timer);
+
 	if (ret)
 		netdev_err(net, "Error while deinitializing host interface\n");
 }
--- linux-6.6.51/drivers/net/wireless/microchip/wilc1000/cfg80211.h	2024-12-05 13:07:51.228704400 +0900
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/cfg80211.h	2024-12-04 16:41:31.554545100 +0900
@@ -21,6 +21,10 @@
 void wilc_update_mgmt_frame_registrations(struct wiphy *wiphy,
 					  struct wireless_dev *wdev,
 					  struct mgmt_frame_regs *upd);
+void wilc_sysfs_init(struct wilc *wilc);
+void wilc_sysfs_exit(void);
+struct wilc_vif *wilc_get_vif_from_type(struct wilc *wl, int type);
 struct wilc_vif *wilc_get_wl_to_vif(struct wilc *wl);
 void wlan_deinit_locks(struct wilc *wilc);
+struct wilc_vif *wilc_get_vif_from_type(struct wilc *wl, int type);
 #endif
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/debugfs.c	2024-12-04 16:41:31.554545100 +0900
@@ -0,0 +1,111 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#include <linux/module.h>
+#include <linux/debugfs.h>
+
+#include "debugfs.h"
+
+atomic_t WILC_DEBUG_REGION = ATOMIC_INIT(INIT_DBG | GENERIC_DBG |
+					 CFG80211_DBG | HOSTAPD_DBG |
+					 PWRDEV_DBG);
+
+#if defined(WILC_DEBUGFS)
+static struct dentry *wilc_dir;
+
+static ssize_t wilc_debug_region_read(struct file *file, char __user *userbuf,
+				     size_t count, loff_t *ppos)
+{
+	char buf[128];
+	int res = 0;
+
+	/* only allow read from start */
+	if (*ppos > 0)
+		return 0;
+
+	res = scnprintf(buf, sizeof(buf), "Debug Region: (0x%08x)\n",
+				    atomic_read(&WILC_DEBUG_REGION));
+
+	return simple_read_from_buffer(userbuf, count, ppos, buf, res);
+}
+
+static ssize_t wilc_debug_region_write(struct file *filp,
+				      const char __user *buf, size_t count,
+				      loff_t *ppos)
+{
+	int flag = 0;
+	int ret;
+
+	ret = kstrtouint_from_user(buf, count, 16, &flag);
+	if (ret)
+		return ret;
+
+	if (flag > DBG_REGION_ALL) {
+		pr_err("%s, value (0x%08x) is out of range, stay previous flag (0x%08x)\n",
+			   __func__, flag, atomic_read(&WILC_DEBUG_REGION));
+		pr_err("allowed bits are 0 to 15\n");
+		return -EINVAL;
+	}
+
+	atomic_set(&WILC_DEBUG_REGION, (int)flag);
+
+	pr_info("Debug region set to %x\n", atomic_read(&WILC_DEBUG_REGION));
+
+	return count;
+}
+
+#define FOPS(_open, _read, _write, _poll) { \
+		.owner	= THIS_MODULE, \
+		.open	= (_open), \
+		.read	= (_read), \
+		.write	= (_write), \
+		.poll		= (_poll), \
+}
+
+struct wilc_debugfs_info_t {
+	const char *name;
+	int perm;
+	unsigned int data;
+	const struct file_operations fops;
+};
+
+static struct wilc_debugfs_info_t debugfs_info[] = {
+	{
+		"wilc_debug_region",
+		0666,
+		0,
+		FOPS(NULL, wilc_debug_region_read, wilc_debug_region_write,
+		     NULL),
+	},
+};
+
+int wilc_debugfs_init(void)
+{
+	int i;
+	struct wilc_debugfs_info_t *info;
+
+	wilc_dir = debugfs_create_dir("wilc", NULL);
+	if (wilc_dir == NULL) {
+		pr_err("Error creating debugfs\n");
+		return -EFAULT;
+	}
+	for (i = 0; i < ARRAY_SIZE(debugfs_info); i++) {
+		info = &debugfs_info[i];
+		debugfs_create_file(info->name,
+				    info->perm,
+				    wilc_dir,
+				    &info->data,
+				    &info->fops);
+	}
+	return 0;
+}
+
+void wilc_debugfs_remove(void)
+{
+	debugfs_remove_recursive(wilc_dir);
+}
+
+#endif
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/debugfs.h	2024-12-04 16:41:31.555542700 +0900
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#ifndef WILC_DEBUGFS_H
+#define WILC_DEBUGFS_H
+
+#include <linux/kern_levels.h>
+#include <linux/version.h>
+
+#define GENERIC_DBG		BIT(0)
+#define HOSTAPD_DBG		BIT(1)
+#define HOSTINF_DBG		BIT(2)
+#define CORECONFIG_DBG		BIT(3)
+#define CFG80211_DBG		BIT(4)
+#define INT_DBG			BIT(5)
+#define TX_DBG			BIT(6)
+#define RX_DBG			BIT(7)
+#define TCP_ENH			BIT(8)
+#define INIT_DBG		BIT(9)
+#define PWRDEV_DBG		BIT(10)
+#define DBG_REGION_ALL		(BIT(11)-1)
+
+extern atomic_t WILC_DEBUG_REGION;
+
+#define PRINT_D(netdev, region, format, ...) do { \
+	if (atomic_read(&WILC_DEBUG_REGION)&(region))\
+		netdev_dbg(netdev, "DBG [%s: %d] "format, __func__, __LINE__,\
+		   ##__VA_ARGS__); } \
+	while (0)
+
+#define PRINT_INFO(netdev, region, format, ...) do { \
+	if (atomic_read(&WILC_DEBUG_REGION)&(region))\
+		netdev_info(netdev, "INFO [%s]"format, __func__, \
+		##__VA_ARGS__); } \
+	while (0)
+
+#define PRINT_WRN(netdev, region, format, ...) do { \
+	if (atomic_read(&WILC_DEBUG_REGION)&(region))\
+		netdev_warn(netdev, "WRN [%s: %d]"format, __func__, __LINE__,\
+		    ##__VA_ARGS__); } \
+	while (0)
+
+#define PRINT_ER(netdev, format, ...) netdev_err(netdev, "ERR [%s:%d] "format,\
+	__func__, __LINE__, ##__VA_ARGS__)
+
+#ifdef WILC_DEBUGFS
+int wilc_debugfs_init(void);
+void wilc_debugfs_remove(void);
+#endif
+
+#endif /* WILC_DEBUGFS_H */
--- linux-6.6.51/drivers/net/wireless/microchip/wilc1000/hif.c	2024-12-05 13:07:51.229701500 +0900
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/hif.c	2024-12-04 16:41:31.555542700 +0900
@@ -4,12 +4,22 @@
  * All rights reserved.
  */
 
+#include "cfg80211.h"
 #include "netdev.h"
 
 #define WILC_HIF_SCAN_TIMEOUT_MS                5000
 #define WILC_HIF_CONNECT_TIMEOUT_MS             9500
 
 #define WILC_FALSE_FRMWR_CHANNEL		100
+struct send_buffered_eap {
+	void (*deliver_to_stack)(struct wilc_vif *vif, u8 *buff, u32 size,
+			      u32 pkt_offset, u8 status);
+	void (*eap_buf_param)(void *priv);
+	u8 *buff;
+	unsigned int size;
+	unsigned int pkt_offset;
+	void *user_arg;
+};
 
 #define WILC_SCAN_WID_LIST_SIZE		6
 
@@ -27,11 +37,38 @@
 	u8 wowlan_trigger;
 };
 
+struct host_if_set_ant {
+	u8 mode;
+	u8 antenna1;
+	u8 antenna2;
+	u8 gpio_mode;
+};
+
+struct tx_power {
+	u8 tx_pwr;
+};
+
+struct power_mgmt_param {
+	bool enabled;
+	u32 timeout;
+};
+
 struct wilc_del_all_sta {
 	u8 assoc_sta;
 	u8 mac[WILC_MAX_NUM_STA][ETH_ALEN];
 };
 
+struct add_sta_param {
+	u8 bssid[ETH_ALEN];
+	u16 aid;
+	u8 supported_rates_len;
+	const u8 *supported_rates;
+	bool ht_supported;
+	struct ieee80211_ht_cap ht_capa;
+	u16 flags_mask;
+	u16 flags_set;
+};
+
 union wilc_message_body {
 	struct wilc_rcvd_net_info net_info;
 	struct wilc_rcvd_mac_info mac_info;
@@ -39,6 +76,12 @@
 	struct wilc_remain_ch remain_on_ch;
 	char *data;
 	struct host_if_wowlan_trigger wow_trigger;
+	struct send_buffered_eap send_buff_eap;
+	struct host_if_set_ant set_ant;
+	struct tx_power tx_power;
+	struct power_mgmt_param pwr_mgmt_info;
+	struct add_sta_param add_sta_info;
+	struct add_sta_param edit_sta_info;
 };
 
 struct host_if_msg {
@@ -115,15 +158,29 @@
 	return NULL;
 }
 
-static int handle_scan_done(struct wilc_vif *vif, enum scan_event evt)
+int handle_scan_done(struct wilc_vif *vif, enum scan_event evt)
 {
 	int result = 0;
 	u8 abort_running_scan;
 	struct wid wid;
 	struct host_if_drv *hif_drv = vif->hif_drv;
 	struct wilc_user_scan_req *scan_req;
+	u8 null_bssid[6] = {0};
 
-	if (evt == SCAN_EVENT_ABORTED) {
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "handling scan done\n");
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
+		return result;
+	}
+
+	if (evt == SCAN_EVENT_DONE) {
+		if (memcmp(hif_drv->assoc_bssid, null_bssid, ETH_ALEN) == 0)
+			hif_drv->hif_state = HOST_IF_IDLE;
+		else
+			hif_drv->hif_state = HOST_IF_CONNECTED;
+	} else if (evt == SCAN_EVENT_ABORTED) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "Abort running scan\n");
 		abort_running_scan = 1;
 		wid.id = WID_ABORT_RUNNING_SCAN;
 		wid.type = WID_CHAR;
@@ -132,30 +189,53 @@
 
 		result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 		if (result) {
-			netdev_err(vif->ndev, "Failed to set abort running\n");
+			PRINT_ER(vif->ndev, "Failed to set abort running\n");
 			result = -EFAULT;
 		}
 	}
 
-	if (!hif_drv) {
-		netdev_err(vif->ndev, "%s: hif driver is NULL\n", __func__);
-		return result;
-	}
-
 	scan_req = &hif_drv->usr_scan_req;
 	if (scan_req->scan_result) {
-		scan_req->scan_result(evt, NULL, scan_req->arg);
+		scan_req->scan_result(evt, NULL, scan_req->priv);
 		scan_req->scan_result = NULL;
 	}
 
 	return result;
 }
 
-int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
-	      u8 *ch_freq_list, u8 ch_list_len,
+static void handle_send_buffered_eap(struct work_struct *work)
+{
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct send_buffered_eap *hif_buff_eap = &msg->body.send_buff_eap;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Sending bufferd eapol to WPAS\n");
+	if (!hif_buff_eap->buff)
+		goto out;
+
+	if (hif_buff_eap->deliver_to_stack)
+		hif_buff_eap->deliver_to_stack(vif, hif_buff_eap->buff,
+					       hif_buff_eap->size,
+					       hif_buff_eap->pkt_offset,
+					       PKT_STATUS_BUFFERED);
+	if (hif_buff_eap->eap_buf_param)
+		hif_buff_eap->eap_buf_param(hif_buff_eap->user_arg);
+
+	if (hif_buff_eap->buff != NULL) {
+		kfree(hif_buff_eap->buff);
+		hif_buff_eap->buff = NULL;
+	}
+
+out:
+	kfree(msg);
+}
+
+int wilc_scan(struct wilc_vif *vif, u8 scan_source,
+	      u8 scan_type, u8 *ch_freq_list,
 	      void (*scan_result_fn)(enum scan_event,
-				     struct wilc_rcvd_net_info *, void *),
-	      void *user_arg, struct cfg80211_scan_request *request)
+				     struct wilc_rcvd_net_info *,
+				     struct wilc_priv *),
+	      struct cfg80211_scan_request *request)
 {
 	int result = 0;
 	struct wid wid_list[WILC_SCAN_WID_LIST_SIZE];
@@ -164,21 +244,44 @@
 	u8 *buffer;
 	u8 valuesize = 0;
 	u8 *search_ssid_vals = NULL;
+	const u8 ch_list_len = request->n_channels;
 	struct host_if_drv *hif_drv = vif->hif_drv;
+	struct wilc_vif *vif_tmp;
+	int srcu_idx;
 
-	if (hif_drv->hif_state >= HOST_IF_SCANNING &&
-	    hif_drv->hif_state < HOST_IF_CONNECTED) {
-		netdev_err(vif->ndev, "Already scan\n");
-		result = -EBUSY;
-		goto error;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setting SCAN params\n");
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Scanning: In [%d] state\n",
+		   hif_drv->hif_state);
+
+	srcu_idx = srcu_read_lock(&vif->wilc->srcu);
+	list_for_each_entry_rcu(vif_tmp, &vif->wilc->vif_list, list) {
+		struct host_if_drv *hif_drv_tmp;
+
+		if (vif_tmp == NULL || vif_tmp->hif_drv == NULL)
+			continue;
+
+		hif_drv_tmp = vif_tmp->hif_drv;
+
+		if (hif_drv_tmp->hif_state != HOST_IF_IDLE &&
+		    hif_drv_tmp->hif_state != HOST_IF_CONNECTED) {
+			PRINT_INFO(vif_tmp->ndev, GENERIC_DBG,
+				   "Abort scan. In state [%d]\n",
+				   hif_drv_tmp->hif_state);
+			result = -EBUSY;
+			srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
+			goto error;
+		}
 	}
+	srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
 
 	if (vif->connecting) {
-		netdev_err(vif->ndev, "Don't do obss scan\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Don't do scan in (CONNECTING) state\n");
 		result = -EBUSY;
 		goto error;
 	}
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setting SCAN params\n");
 	hif_drv->usr_scan_req.ch_cnt = 0;
 
 	if (request->n_ssids) {
@@ -193,6 +296,9 @@
 
 			*buffer++ = request->n_ssids;
 
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "In Handle_ProbeRequest number of ssid %d\n",
+			 request->n_ssids);
 			for (i = 0; i < request->n_ssids; i++) {
 				*buffer++ = request->ssids[i].ssid_len;
 				memcpy(buffer, request->ssids[i].ssid,
@@ -249,18 +355,20 @@
 	index++;
 
 	hif_drv->usr_scan_req.scan_result = scan_result_fn;
-	hif_drv->usr_scan_req.arg = user_arg;
+	hif_drv->usr_scan_req.priv = &vif->priv;
 
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list, index);
 	if (result) {
 		netdev_err(vif->ndev, "Failed to send scan parameters\n");
 		goto error;
+	} else {
+		hif_drv->scan_timer_vif = vif;
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   ">> Starting the SCAN timer\n");
+		mod_timer(&hif_drv->scan_timer,
+			  jiffies + msecs_to_jiffies(scan_timeout));
 	}
 
-	hif_drv->scan_timer_vif = vif;
-	mod_timer(&hif_drv->scan_timer,
-		  jiffies + msecs_to_jiffies(scan_timeout));
-
 error:
 
 	kfree(search_ssid_vals);
@@ -276,6 +384,28 @@
 	struct host_if_drv *hif_drv = vif->hif_drv;
 	struct wilc_conn_info *conn_attr = &hif_drv->conn_info;
 	struct wilc_join_bss_param *bss_param = conn_attr->param;
+	struct wilc_vif *vif_tmp;
+	int srcu_idx;
+
+	srcu_idx = srcu_read_lock(&vif->wilc->srcu);
+	list_for_each_entry_rcu(vif_tmp, &vif->wilc->vif_list, list) {
+		struct host_if_drv *hif_drv_tmp;
+
+		if (vif_tmp == NULL || vif_tmp->hif_drv == NULL)
+			continue;
+
+		hif_drv_tmp = vif_tmp->hif_drv;
+
+		if (hif_drv_tmp->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif_tmp->ndev, GENERIC_DBG,
+				   "Abort connect in state [%d]\n",
+				   hif_drv_tmp->hif_state);
+			result = -EBUSY;
+			srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
+			goto error;
+		}
+	}
+	srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
 
 
         wid_list[wid_cnt].id = WID_SET_MFP;
@@ -296,18 +426,25 @@
 	wid_list[wid_cnt].val = (s8 *)&conn_attr->security;
 	wid_cnt++;
 
+	PRINT_D(vif->ndev, HOSTINF_DBG, "Encrypt Mode = %x\n",
+		conn_attr->security);
 	wid_list[wid_cnt].id = WID_AUTH_TYPE;
 	wid_list[wid_cnt].type = WID_CHAR;
 	wid_list[wid_cnt].size = sizeof(char);
 	wid_list[wid_cnt].val = (s8 *)&conn_attr->auth_type;
 	wid_cnt++;
 
+	PRINT_D(vif->ndev, HOSTINF_DBG, "Authentication Type = %x\n",
+		conn_attr->auth_type);
+
 	wid_list[wid_cnt].id = WID_JOIN_REQ_EXTENDED;
 	wid_list[wid_cnt].type = WID_STR;
 	wid_list[wid_cnt].size = sizeof(*bss_param);
 	wid_list[wid_cnt].val = (u8 *)bss_param;
 	wid_cnt++;
 
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "send HOST_IF_WAITING_CONN_RESP\n");
+
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list, wid_cnt);
 	if (result) {
 		netdev_err(vif->ndev, "failed to send config packet\n");
@@ -348,7 +485,7 @@
 	if (hif_drv->conn_info.conn_result) {
 		hif_drv->conn_info.conn_result(CONN_DISCONN_EVENT_CONN_RESP,
 					       WILC_MAC_STATUS_DISCONNECTED,
-					       hif_drv->conn_info.arg);
+					       hif_drv->conn_info.priv);
 
 	} else {
 		netdev_err(vif->ndev, "%s: conn_result is NULL\n", __func__);
@@ -359,6 +496,7 @@
 	wid.val = (s8 *)&dummy_reason_code;
 	wid.size = sizeof(char);
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Sending disconnect request\n");
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
 		netdev_err(vif->ndev, "Failed to send disconnect\n");
@@ -371,8 +509,9 @@
 	kfree(msg);
 }
 
-void *wilc_parse_join_bss_param(struct cfg80211_bss *bss,
-				struct cfg80211_crypto_settings *crypto)
+struct wilc_join_bss_param *
+wilc_parse_join_bss_param(struct cfg80211_bss *bss,
+			  struct cfg80211_crypto_settings *crypto)
 {
 	const u8 *ies_data, *tim_elm, *ssid_elm, *rates_ie, *supp_rates_ie;
 	const u8 *ht_ie, *wpa_ie, *wmm_ie, *rsn_ie;
@@ -534,12 +673,16 @@
 {
 	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
 	struct wilc_rcvd_net_info *rcvd_info = &msg->body.net_info;
-	struct wilc_user_scan_req *scan_req = &msg->vif->hif_drv->usr_scan_req;
+	struct host_if_drv *hif_drv;
+	struct wilc_user_scan_req *scan_req;
 	const u8 *ch_elm;
 	u8 *ies;
 	int ies_len;
 	size_t offset;
 
+	PRINT_D(msg->vif->ndev, HOSTINF_DBG,
+		"Handling received network info\n");
+
 	if (ieee80211_is_probe_resp(rcvd_info->mgmt->frame_control))
 		offset = offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
 	else if (ieee80211_is_beacon(rcvd_info->mgmt->frame_control))
@@ -552,13 +695,20 @@
 	if (ies_len <= 0)
 		goto done;
 
+	PRINT_INFO(msg->vif->ndev, HOSTINF_DBG, "New network found\n");
+	/* extract the channel from received mgmt frame */
 	ch_elm = cfg80211_find_ie(WLAN_EID_DS_PARAMS, ies, ies_len);
 	if (ch_elm && ch_elm[1] > 0)
 		rcvd_info->ch = ch_elm[2];
 
+	if (!msg->vif || !msg->vif->hif_drv)
+		goto done;
+
+	hif_drv = msg->vif->hif_drv;
+	scan_req = &hif_drv->usr_scan_req;
 	if (scan_req->scan_result)
 		scan_req->scan_result(SCAN_EVENT_NETWORK_FOUND, rcvd_info,
-				      scan_req->arg);
+				      scan_req->priv);
 
 done:
 	kfree(rcvd_info->mgmt);
@@ -625,9 +775,14 @@
 					    WILC_MAX_ASSOC_RESP_FRAME_SIZE,
 					    &assoc_resp_info_len);
 
+		PRINT_D(vif->ndev, HOSTINF_DBG,
+			"Received association response = %d\n",
+			assoc_resp_info_len);
 		if (assoc_resp_info_len != 0) {
 			s32 err = 0;
 
+			PRINT_INFO(vif->ndev, HOSTINF_DBG,
+				   "Parsing association response\n");
 			err = wilc_parse_assoc_resp_info(hif_drv->assoc_resp,
 							 assoc_resp_info_len,
 							 conn_info);
@@ -640,13 +795,18 @@
 
 	del_timer(&hif_drv->connect_timer);
 	conn_info->conn_result(CONN_DISCONN_EVENT_CONN_RESP, mac_status,
-			       hif_drv->conn_info.arg);
+			       hif_drv->conn_info.priv);
 
 	if (mac_status == WILC_MAC_STATUS_CONNECTED &&
 	    conn_info->status == WLAN_STATUS_SUCCESS) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "MAC status : CONNECTED and Connect Status : Successful\n");
 		ether_addr_copy(hif_drv->assoc_bssid, conn_info->bssid);
 		hif_drv->hif_state = HOST_IF_CONNECTED;
 	} else {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "MAC status : %d and Connect Status : %d\n",
+			   mac_status, conn_info->status);
 		hif_drv->hif_state = HOST_IF_IDLE;
 	}
 
@@ -663,14 +823,18 @@
 {
 	struct host_if_drv *hif_drv = vif->hif_drv;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Received WILC_MAC_STATUS_DISCONNECTED from the FW\n");
 	if (hif_drv->usr_scan_req.scan_result) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "\n\n<< Abort the running OBSS Scan >>\n\n");
 		del_timer(&hif_drv->scan_timer);
 		handle_scan_done(vif, SCAN_EVENT_ABORTED);
 	}
 
 	if (hif_drv->conn_info.conn_result)
 		hif_drv->conn_info.conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF,
-					       0, hif_drv->conn_info.arg);
+					       0, hif_drv->conn_info.priv);
 
 	eth_zero_addr(hif_drv->assoc_bssid);
 
@@ -692,6 +856,10 @@
 		goto free_msg;
 	}
 
+	PRINT_INFO(vif->ndev, GENERIC_DBG,
+		   "Current State = %d,Received state = %d\n",
+		   hif_drv->hif_state, mac_info->status);
+
 	if (!hif_drv->conn_info.conn_result) {
 		netdev_err(vif->ndev, "%s: conn_result is NULL\n", __func__);
 		goto free_msg;
@@ -708,6 +876,8 @@
 		if (hif_drv->hif_state == HOST_IF_CONNECTED) {
 			wilc_handle_disconnect(vif);
 		} else if (hif_drv->usr_scan_req.scan_result) {
+			PRINT_WRN(vif->ndev, HOSTINF_DBG,
+				  "Received WILC_MAC_STATUS_DISCONNECTED. Abort the running Scan");
 			del_timer(&hif_drv->scan_timer);
 			handle_scan_done(vif, SCAN_EVENT_ABORTED);
 		}
@@ -725,12 +895,35 @@
 	struct wilc_conn_info *conn_info;
 	int result;
 	u16 dummy_reason_code = 0;
+	struct wilc_vif *vif_tmp;
+	int srcu_idx;
+
+	srcu_idx = srcu_read_lock(&vif->wilc->srcu);
+	list_for_each_entry_rcu(vif_tmp, &vif->wilc->vif_list, list) {
+		struct host_if_drv *hif_drv_tmp;
+
+		if (vif_tmp == NULL || vif_tmp->hif_drv == NULL)
+			continue;
+
+		hif_drv_tmp = vif_tmp->hif_drv;
+
+		if (hif_drv_tmp->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif_tmp->ndev, GENERIC_DBG,
+				   "Abort scan from disconnect. state [%d]\n",
+				   hif_drv_tmp->hif_state);
+			del_timer(&hif_drv_tmp->scan_timer);
+			handle_scan_done(vif_tmp, SCAN_EVENT_ABORTED);
+		}
+	}
+	srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
 
 	wid.id = WID_DISCONNECT;
 	wid.type = WID_CHAR;
 	wid.val = (s8 *)&dummy_reason_code;
 	wid.size = sizeof(char);
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Sending disconnect request\n");
+
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result) {
 		netdev_err(vif->ndev, "Failed to send disconnect\n");
@@ -742,17 +935,22 @@
 
 	if (scan_req->scan_result) {
 		del_timer(&hif_drv->scan_timer);
-		scan_req->scan_result(SCAN_EVENT_ABORTED, NULL, scan_req->arg);
+		scan_req->scan_result(SCAN_EVENT_ABORTED, NULL, scan_req->priv);
 		scan_req->scan_result = NULL;
 	}
 
 	if (conn_info->conn_result) {
 		if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP ||
-		    hif_drv->hif_state == HOST_IF_EXTERNAL_AUTH)
+		    hif_drv->hif_state == HOST_IF_EXTERNAL_AUTH) {
 			del_timer(&hif_drv->connect_timer);
-
-		conn_info->conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF, 0,
-				       conn_info->arg);
+			conn_info->conn_result(CONN_DISCONN_EVENT_CONN_RESP,
+					       WILC_MAC_STATUS_DISCONNECTED,
+					       conn_info->priv);
+		} else if (hif_drv->hif_state == HOST_IF_CONNECTED) {
+			conn_info->conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF,
+					       WILC_MAC_STATUS_DISCONNECTED,
+					       conn_info->priv);
+		}
 	} else {
 		netdev_err(vif->ndev, "%s: conn_result is NULL\n", __func__);
 	}
@@ -764,6 +962,7 @@
 	conn_info->req_ies_len = 0;
 	kfree(conn_info->req_ies);
 	conn_info->req_ies = NULL;
+	conn_info->conn_result = NULL;
 
 	return 0;
 }
@@ -810,10 +1009,14 @@
 	}
 
 	if (stats->link_speed > TCP_ACK_FILTER_LINK_SPEED_THRESH &&
-	    stats->link_speed != DEFAULT_LINK_SPEED)
+	    stats->link_speed != DEFAULT_LINK_SPEED) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "Enable TCP filter\n");
 		wilc_enable_tcp_ack_filter(vif, true);
-	else if (stats->link_speed != DEFAULT_LINK_SPEED)
+	} else if (stats->link_speed != DEFAULT_LINK_SPEED) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "Disable TCP filter %d\n",
+			   stats->link_speed);
 		wilc_enable_tcp_ack_filter(vif, false);
+	}
 
 	return result;
 }
@@ -829,33 +1032,32 @@
 	kfree(msg);
 }
 
-static void wilc_hif_pack_sta_param(u8 *cur_byte, const u8 *mac,
-				    struct station_parameters *params)
+static void wilc_hif_pack_sta_param(u8 *cur_byte, struct add_sta_param *params)
 {
-	ether_addr_copy(cur_byte, mac);
+	ether_addr_copy(cur_byte, params->bssid);
 	cur_byte += ETH_ALEN;
 
 	put_unaligned_le16(params->aid, cur_byte);
 	cur_byte += 2;
 
-	*cur_byte++ = params->link_sta_params.supported_rates_len;
-	if (params->link_sta_params.supported_rates_len > 0)
-		memcpy(cur_byte, params->link_sta_params.supported_rates,
-		       params->link_sta_params.supported_rates_len);
-	cur_byte += params->link_sta_params.supported_rates_len;
+	*cur_byte++ = params->supported_rates_len;
+	if (params->supported_rates_len > 0)
+		memcpy(cur_byte, params->supported_rates,
+		       params->supported_rates_len);
+	cur_byte += params->supported_rates_len;
 
-	if (params->link_sta_params.ht_capa) {
+	if (params->ht_supported) {
 		*cur_byte++ = true;
-		memcpy(cur_byte, params->link_sta_params.ht_capa,
+		memcpy(cur_byte, &params->ht_capa,
 		       sizeof(struct ieee80211_ht_cap));
 	} else {
 		*cur_byte++ = false;
 	}
 	cur_byte += sizeof(struct ieee80211_ht_cap);
 
-	put_unaligned_le16(params->sta_flags_mask, cur_byte);
+	put_unaligned_le16(params->flags_mask, cur_byte);
 	cur_byte += 2;
-	put_unaligned_le16(params->sta_flags_set, cur_byte);
+	put_unaligned_le16(params->flags_set, cur_byte);
 }
 
 static int handle_remain_on_chan(struct wilc_vif *vif,
@@ -865,15 +1067,45 @@
 	u8 remain_on_chan_flag;
 	struct wid wid;
 	struct host_if_drv *hif_drv = vif->hif_drv;
+	struct wilc_vif *vif_tmp;
+	int srcu_idx;
 
-	if (hif_drv->usr_scan_req.scan_result)
-		return -EBUSY;
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "Driver is null\n");
+		return -EFAULT;
+	}
 
-	if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP)
-		return -EBUSY;
+	srcu_idx = srcu_read_lock(&vif->wilc->srcu);
+	list_for_each_entry_rcu(vif_tmp, &vif->wilc->vif_list, list) {
+		struct host_if_drv *hif_drv_tmp;
+
+		if (vif_tmp == NULL || vif_tmp->hif_drv == NULL)
+			continue;
+
+		hif_drv_tmp = vif_tmp->hif_drv;
+
+		if (hif_drv_tmp->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif_tmp->ndev, GENERIC_DBG,
+				   "IFC busy scanning. WLAN_IFC state %d\n",
+				   hif_drv_tmp->hif_state);
+			srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
+			return -EBUSY;
+		} else if (hif_drv_tmp->hif_state != HOST_IF_IDLE &&
+			   hif_drv_tmp->hif_state != HOST_IF_CONNECTED) {
+			PRINT_INFO(vif_tmp->ndev, GENERIC_DBG,
+				   "IFC busy connecting. WLAN_IFC %d\n",
+				   hif_drv_tmp->hif_state);
+			srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
+			return -EBUSY;
+		}
+	}
+	srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
 
-	if (vif->connecting)
+	if (vif->connecting) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Don't do scan in (CONNECTING) state\n");
 		return -EBUSY;
+	}
 
 	remain_on_chan_flag = true;
 	wid.id = WID_REMAIN_ON_CHAN;
@@ -888,16 +1120,20 @@
 
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	kfree(wid.val);
-	if (result)
+	if (result) {
+		PRINT_ER(vif->ndev, "Failed to set remain on channel\n");
 		return -EBUSY;
+	}
 
-	hif_drv->remain_on_ch.arg = hif_remain_ch->arg;
+	hif_drv->remain_on_ch.vif = hif_remain_ch->vif;
 	hif_drv->remain_on_ch.expired = hif_remain_ch->expired;
 	hif_drv->remain_on_ch.ch = hif_remain_ch->ch;
 	hif_drv->remain_on_ch.cookie = hif_remain_ch->cookie;
+	hif_drv->hif_state = HOST_IF_P2P_LISTEN;
+
 	hif_drv->remain_on_ch_timer_vif = vif;
 
-	return 0;
+	return result;
 }
 
 static int wilc_handle_roc_expired(struct wilc_vif *vif, u64 cookie)
@@ -906,16 +1142,19 @@
 	struct wid wid;
 	int result;
 	struct host_if_drv *hif_drv = vif->hif_drv;
+	u8 null_bssid[6] = {0};
 
-	if (vif->priv.p2p_listen_state) {
+	if (hif_drv->hif_state == HOST_IF_P2P_LISTEN) {
 		remain_on_chan_flag = false;
 		wid.id = WID_REMAIN_ON_CHAN;
 		wid.type = WID_STR;
 		wid.size = 2;
 
 		wid.val = kmalloc(wid.size, GFP_KERNEL);
-		if (!wid.val)
+		if (!wid.val) {
+			PRINT_ER(vif->ndev, "Failed to allocate memory\n");
 			return -ENOMEM;
+		}
 
 		wid.val[0] = remain_on_chan_flag;
 		wid.val[1] = WILC_FALSE_FRMWR_CHANNEL;
@@ -927,10 +1166,14 @@
 			return -EINVAL;
 		}
 
-		if (hif_drv->remain_on_ch.expired) {
-			hif_drv->remain_on_ch.expired(hif_drv->remain_on_ch.arg,
+		if (hif_drv->remain_on_ch.expired)
+			hif_drv->remain_on_ch.expired(hif_drv->remain_on_ch.vif,
 						      cookie);
-		}
+
+		if (memcmp(hif_drv->assoc_bssid, null_bssid, ETH_ALEN) == 0)
+			hif_drv->hif_state = HOST_IF_IDLE;
+		else
+			hif_drv->hif_state = HOST_IF_CONNECTED;
 	} else {
 		netdev_dbg(vif->ndev, "Not in listen state\n");
 	}
@@ -941,8 +1184,13 @@
 static void wilc_handle_listen_state_expired(struct work_struct *work)
 {
 	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct wilc_remain_ch *hif_remain_ch = &msg->body.remain_on_ch;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "CANCEL REMAIN ON CHAN\n");
+
+	wilc_handle_roc_expired(vif, hif_remain_ch->cookie);
 
-	wilc_handle_roc_expired(msg->vif, msg->body.remain_on_ch.cookie);
 	kfree(msg);
 }
 
@@ -978,6 +1226,8 @@
 	struct wid wid;
 	u8 *cur_byte;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setup Multicast Filter\n");
+
 	wid.id = WID_SETUP_MULTICAST_FILTER;
 	wid.type = WID_BIN;
 	wid.size = sizeof(struct wilc_set_multicast) + (set_mc->cnt * ETH_ALEN);
@@ -1021,7 +1271,8 @@
 
 	ret = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (ret)
-		pr_err("Failed to send wowlan trigger config packet\n");
+		PRINT_ER(vif->ndev,
+			 "Failed to send wowlan trigger config packet\n");
 }
 
 int wilc_set_external_auth_param(struct wilc_vif *vif,
@@ -1053,6 +1304,9 @@
 {
 	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
 
+	if(!msg->vif || !msg->vif->wilc || msg->vif->wilc->close)
+		return;
+
 	handle_scan_done(msg->vif, SCAN_EVENT_ABORTED);
 	kfree(msg);
 }
@@ -1062,6 +1316,7 @@
 	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
 
 	del_timer(&msg->vif->hif_drv->scan_timer);
+	PRINT_INFO(msg->vif->ndev, HOSTINF_DBG, "scan completed\n");
 
 	handle_scan_done(msg->vif, SCAN_EVENT_DONE);
 
@@ -1101,6 +1356,40 @@
 		kfree(msg);
 }
 
+signed int wilc_send_buffered_eap(struct wilc_vif *vif,
+				  void (*deliver_to_stack)(struct wilc_vif *,
+							   u8 *, u32, u32, u8),
+				  void (*eap_buf_param)(void *), u8 *buff,
+				  unsigned int size, unsigned int pkt_offset,
+				  void *user_arg)
+{
+	int result;
+	struct host_if_msg *msg;
+
+	if (!vif || !deliver_to_stack || !eap_buf_param)
+		return -EFAULT;
+
+	msg = wilc_alloc_work(vif, handle_send_buffered_eap, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+	msg->body.send_buff_eap.deliver_to_stack = deliver_to_stack;
+	msg->body.send_buff_eap.eap_buf_param = eap_buf_param;
+	msg->body.send_buff_eap.size = size;
+	msg->body.send_buff_eap.pkt_offset = pkt_offset;
+	msg->body.send_buff_eap.buff = kmalloc(size + pkt_offset,
+					       GFP_ATOMIC);
+	memcpy(msg->body.send_buff_eap.buff, buff, size + pkt_offset);
+	msg->body.send_buff_eap.user_arg = user_arg;
+
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg->body.send_buff_eap.buff);
+		kfree(msg);
+	}
+	return result;
+}
+
 int wilc_add_ptk(struct wilc_vif *vif, const u8 *ptk, u8 ptk_key_len,
 		 const u8 *mac_addr, const u8 *rx_mic, const u8 *tx_mic,
 		 u8 mode, u8 cipher_mode, u8 index)
@@ -1118,9 +1407,11 @@
 		wid_list[0].val = (s8 *)&cipher_mode;
 
 		key_buf = kzalloc(sizeof(*key_buf) + t_key_len, GFP_KERNEL);
-		if (!key_buf)
+		if (!key_buf) {
+			PRINT_ER(vif->ndev,
+				 "NO buffer to keep Key buffer - AP\n");
 			return -ENOMEM;
-
+		}
 		ether_addr_copy(key_buf->mac_addr, mac_addr);
 		key_buf->index = index;
 		key_buf->key_len = t_key_len;
@@ -1146,8 +1437,11 @@
 		struct wilc_sta_wpa_ptk *key_buf;
 
 		key_buf = kzalloc(sizeof(*key_buf) + t_key_len, GFP_KERNEL);
-		if (!key_buf)
+		if (!key_buf) {
+			PRINT_ER(vif->ndev,
+				 "No buffer to keep Key buffer - Station\n");
 			return -ENOMEM;
+		}
 
 		ether_addr_copy(key_buf->mac_addr, mac_addr);
 		key_buf->key_len = t_key_len;
@@ -1212,8 +1506,10 @@
 	int t_key_len = gtk_key_len + WILC_RX_MIC_KEY_LEN + WILC_TX_MIC_KEY_LEN;
 
 	gtk_key = kzalloc(sizeof(*gtk_key) + t_key_len, GFP_KERNEL);
-	if (!gtk_key)
+	if (!gtk_key) {
+		PRINT_ER(vif->ndev, "No buffer to send GTK Key\n");
 		return -ENOMEM;
+	}
 
 	/* fill bssid value only in station mode */
 	if (mode == WILC_STATION_MODE &&
@@ -1326,8 +1622,10 @@
 	}
 
 	result = wilc_send_connect_wid(vif);
-	if (result)
+	if (result) {
+		PRINT_ER(vif->ndev, "Failed to send connect wid\n");
 		goto free_ies;
+	}
 
 	hif_drv->connect_timer_vif = vif;
 	mod_timer(&hif_drv->connect_timer,
@@ -1389,8 +1687,10 @@
 	wid.type = WID_STR;
 	wid.size = ETH_ALEN;
 	wid.val = kzalloc(wid.size, GFP_KERNEL);
-	if (!wid.val)
+	if (!wid.val) {
+		PRINT_ER(vif->ndev, "Failed to allocate buffer\n");
 		return -ENOMEM;
+	}
 
 	ether_addr_copy(wid.val, mac);
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
@@ -1408,6 +1708,9 @@
 	if (result)
 		netdev_err(vif->ndev, "Failed to get inactive time\n");
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Getting inactive time : %d\n",
+		   *out_val);
+
 	return result;
 }
 
@@ -1437,6 +1740,7 @@
 	int result;
 	struct host_if_msg *msg;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, " getting async statistics\n");
 	msg = wilc_alloc_work(vif, handle_get_statistics, false);
 	if (IS_ERR(msg))
 		return PTR_ERR(msg);
@@ -1510,12 +1814,12 @@
 	struct host_if_drv *hif_drv;
 	struct wilc_vif *vif = netdev_priv(dev);
 
-	hif_drv  = kzalloc(sizeof(*hif_drv), GFP_KERNEL);
-	if (!hif_drv)
+	hif_drv = kzalloc(sizeof(*hif_drv), GFP_KERNEL);
+	if (!hif_drv) {
+		PRINT_ER(dev, "hif driver is NULL\n");
 		return -ENOMEM;
-
+	}
 	*hif_drv_handler = hif_drv;
-
 	vif->hif_drv = hif_drv;
 
 	timer_setup(&vif->periodic_rssi, get_periodic_rssi, 0);
@@ -1544,14 +1848,20 @@
 
 	mutex_lock(&vif->wilc->deinit_lock);
 
+#if KERNEL_VERSION(6, 4, 0) <= LINUX_VERSION_CODE
 	timer_shutdown_sync(&hif_drv->scan_timer);
 	timer_shutdown_sync(&hif_drv->connect_timer);
-	del_timer_sync(&vif->periodic_rssi);
 	timer_shutdown_sync(&hif_drv->remain_on_ch_timer);
-
+#else
+	/* to support compilation on v6.1, will be removed later */
+	del_timer_sync(&hif_drv->scan_timer);
+	del_timer_sync(&hif_drv->connect_timer);
+	del_timer_sync(&hif_drv->remain_on_ch_timer);
+#endif
+	del_timer_sync(&vif->periodic_rssi);
 	if (hif_drv->usr_scan_req.scan_result) {
 		hif_drv->usr_scan_req.scan_result(SCAN_EVENT_ABORTED, NULL,
-						  hif_drv->usr_scan_req.arg);
+						  hif_drv->usr_scan_req.priv);
 		hif_drv->usr_scan_req.scan_result = NULL;
 	}
 
@@ -1570,21 +1880,23 @@
 	int id;
 	struct host_if_drv *hif_drv;
 	struct wilc_vif *vif;
+	int srcu_idx;
 
 	id = get_unaligned_le32(&buffer[length - 4]);
+	srcu_idx = srcu_read_lock(&wilc->srcu);
 	vif = wilc_get_vif_from_idx(wilc, id);
 	if (!vif)
-		return;
-	hif_drv = vif->hif_drv;
+		goto out;
 
+	hif_drv = vif->hif_drv;
 	if (!hif_drv) {
 		netdev_err(vif->ndev, "driver not init[%p]\n", hif_drv);
-		return;
+		goto out;
 	}
 
 	msg = wilc_alloc_work(vif, handle_rcvd_ntwrk_info, false);
 	if (IS_ERR(msg))
-		return;
+		goto out;
 
 	msg->body.net_info.frame_len = get_unaligned_le16(&buffer[6]) - 1;
 	msg->body.net_info.rssi = buffer[8];
@@ -1593,7 +1905,7 @@
 					  GFP_KERNEL);
 	if (!msg->body.net_info.mgmt) {
 		kfree(msg);
-		return;
+		goto out;
 	}
 
 	result = wilc_enqueue_work(msg);
@@ -1602,6 +1914,8 @@
 		kfree(msg->body.net_info.mgmt);
 		kfree(msg);
 	}
+out:
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
 }
 
 void wilc_gnrl_async_info_received(struct wilc *wilc, u8 *buffer, u32 length)
@@ -1611,43 +1925,47 @@
 	int id;
 	struct host_if_drv *hif_drv;
 	struct wilc_vif *vif;
+	int srcu_idx;
 
 	mutex_lock(&wilc->deinit_lock);
 
 	id = get_unaligned_le32(&buffer[length - 4]);
+	srcu_idx = srcu_read_lock(&wilc->srcu);
 	vif = wilc_get_vif_from_idx(wilc, id);
-	if (!vif) {
-		mutex_unlock(&wilc->deinit_lock);
-		return;
-	}
+	if (!vif)
+		goto out;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "General asynchronous info packet received\n");
 
 	hif_drv = vif->hif_drv;
 
 	if (!hif_drv) {
-		mutex_unlock(&wilc->deinit_lock);
-		return;
+		pr_err("hif driver is NULL\n");
+		goto out;
 	}
 
 	if (!hif_drv->conn_info.conn_result) {
-		netdev_err(vif->ndev, "%s: conn_result is NULL\n", __func__);
-		mutex_unlock(&wilc->deinit_lock);
-		return;
+		pr_err("there is no current Connect Request\n");
+		goto out;
 	}
 
 	msg = wilc_alloc_work(vif, handle_rcvd_gnrl_async_info, false);
-	if (IS_ERR(msg)) {
-		mutex_unlock(&wilc->deinit_lock);
-		return;
-	}
+	if (IS_ERR(msg))
+		goto out;
 
 	msg->body.mac_info.status = buffer[7];
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Received MAC status= %d Reason= %d Info = %d\n",
+		   buffer[7], buffer[8], buffer[9]);
 	result = wilc_enqueue_work(msg);
 	if (result) {
 		netdev_err(vif->ndev, "%s: enqueue work failed\n", __func__);
 		kfree(msg);
 	}
-
+out:
 	mutex_unlock(&wilc->deinit_lock);
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
 }
 
 void wilc_scan_complete_received(struct wilc *wilc, u8 *buffer, u32 length)
@@ -1656,22 +1974,28 @@
 	int id;
 	struct host_if_drv *hif_drv;
 	struct wilc_vif *vif;
+	int srcu_idx;
 
 	id = get_unaligned_le32(&buffer[length - 4]);
+	srcu_idx = srcu_read_lock(&wilc->srcu);
 	vif = wilc_get_vif_from_idx(wilc, id);
 	if (!vif)
-		return;
-	hif_drv = vif->hif_drv;
+		goto out;
 
-	if (!hif_drv)
-		return;
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "Scan notification received\n");
+
+	hif_drv = vif->hif_drv;
+	if (!hif_drv) {
+		pr_err("hif driver is NULL\n");
+		goto out;
+	}
 
 	if (hif_drv->usr_scan_req.scan_result) {
 		struct host_if_msg *msg;
 
 		msg = wilc_alloc_work(vif, handle_scan_complete, false);
 		if (IS_ERR(msg))
-			return;
+			goto out;
 
 		result = wilc_enqueue_work(msg);
 		if (result) {
@@ -1680,20 +2004,20 @@
 			kfree(msg);
 		}
 	}
+out:
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
 }
 
-int wilc_remain_on_channel(struct wilc_vif *vif, u64 cookie,
-			   u32 duration, u16 chan,
-			   void (*expired)(void *, u64),
-			   void *user_arg)
+int wilc_remain_on_channel(struct wilc_vif *vif, u64 cookie, u16 chan,
+			   void (*expired)(struct wilc_vif *, u64))
 {
 	struct wilc_remain_ch roc;
 	int result;
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "called\n");
 	roc.ch = chan;
 	roc.expired = expired;
-	roc.arg = user_arg;
-	roc.duration = duration;
+	roc.vif = vif;
 	roc.cookie = cookie;
 	result = handle_remain_on_chan(vif, &roc);
 	if (result)
@@ -1733,10 +2057,12 @@
 
 	switch (frame_type) {
 	case IEEE80211_STYPE_ACTION:
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "ACTION\n");
 		reg_frame.reg_id = WILC_FW_ACTION_FRM_IDX;
 		break;
 
 	case IEEE80211_STYPE_PROBE_REQ:
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "PROBE REQ\n");
 		reg_frame.reg_id = WILC_FW_PROBE_REQ_IDX;
 		break;
 
@@ -1745,6 +2071,7 @@
                 break;
 
 	default:
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "Not valid frame type\n");
 		break;
 	}
 	reg_frame.frame_type = cpu_to_le16(frame_type);
@@ -1760,12 +2087,17 @@
 	int result;
 	u8 *cur_byte;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting adding beacon\n");
+
 	wid.id = WID_ADD_BEACON;
 	wid.type = WID_BIN;
 	wid.size = params->head_len + params->tail_len + 16;
 	wid.val = kzalloc(wid.size, GFP_KERNEL);
-	if (!wid.val)
+	if (!wid.val) {
+		PRINT_ER(vif->ndev, "Failed to allocate buffer\n");
 		return -ENOMEM;
+	}
 
 	cur_byte = wid.val;
 	put_unaligned_le32(interval, cur_byte);
@@ -1800,6 +2132,9 @@
 	struct wid wid;
 	u8 del_beacon = 0;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting deleting beacon message queue params\n");
+
 	wid.id = WID_DEL_BEACON;
 	wid.type = WID_CHAR;
 	wid.size = sizeof(char);
@@ -1812,29 +2147,78 @@
 	return result;
 }
 
-int wilc_add_station(struct wilc_vif *vif, const u8 *mac,
-		     struct station_parameters *params)
+static void handle_add_station(struct work_struct *work)
 {
-	struct wid wid;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct add_sta_param *params = &msg->body.add_sta_info;
 	int result;
-	u8 *cur_byte;
+	struct wid wid;
 
 	wid.id = WID_ADD_STA;
 	wid.type = WID_BIN;
-	wid.size = WILC_ADD_STA_LENGTH +
-		   params->link_sta_params.supported_rates_len;
+	wid.size = WILC_ADD_STA_LENGTH + params->supported_rates_len;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling add station\n");
 	wid.val = kmalloc(wid.size, GFP_KERNEL);
 	if (!wid.val)
-		return -ENOMEM;
+		goto error;
 
-	cur_byte = wid.val;
-	wilc_hif_pack_sta_param(cur_byte, mac, params);
+	wilc_hif_pack_sta_param(wid.val, params);
 
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
-	if (result != 0)
-		netdev_err(vif->ndev, "Failed to send add station\n");
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to send add station\n");
 
 	kfree(wid.val);
+error:
+	kfree(params->supported_rates);
+	kfree(msg);
+}
+
+int wilc_add_station(struct wilc_vif *vif, const u8 *mac,
+		     struct station_parameters *params)
+{
+	int result;
+	struct host_if_msg *msg;
+	struct add_sta_param *sta_params;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting adding station message queue params\n");
+
+	msg = wilc_alloc_work(vif, handle_add_station, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+
+	sta_params = &msg->body.add_sta_info;
+	memcpy(sta_params->bssid, mac, ETH_ALEN);
+	sta_params->aid = params->aid;
+	if (!params->link_sta_params.ht_capa) {
+		sta_params->ht_supported = false;
+	} else {
+		sta_params->ht_supported = true;
+		memcpy(&sta_params->ht_capa, params->link_sta_params.ht_capa,
+		       sizeof(struct ieee80211_ht_cap));
+	}
+	sta_params->flags_mask = params->sta_flags_mask;
+	sta_params->flags_set = params->sta_flags_set;
+
+	sta_params->supported_rates_len = params->link_sta_params.supported_rates_len;
+	if (params->link_sta_params.supported_rates_len > 0) {
+		sta_params->supported_rates = kmemdup(params->link_sta_params.supported_rates,
+					    params->link_sta_params.supported_rates_len,
+					    GFP_KERNEL);
+		if (!sta_params->supported_rates) {
+			kfree(msg);
+			return -ENOMEM;
+		}
+	}
+
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(sta_params->supported_rates);
+		kfree(msg);
+	}
 
 	return result;
 }
@@ -1844,12 +2228,17 @@
 	struct wid wid;
 	int result;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting deleting station message queue params\n");
+
 	wid.id = WID_REMOVE_STA;
 	wid.type = WID_BIN;
 	wid.size = ETH_ALEN;
 	wid.val = kzalloc(wid.size, GFP_KERNEL);
-	if (!wid.val)
+	if (!wid.val) {
+		PRINT_ER(vif->ndev, "Failed to allocate buffer\n");
 		return -ENOMEM;
+	}
 
 	if (!mac_addr)
 		eth_broadcast_addr(wid.val);
@@ -1873,17 +2262,25 @@
 	u8 assoc_sta = 0;
 	struct wilc_del_all_sta del_sta;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting deauthenticating station message queue params\n");
 	memset(&del_sta, 0x0, sizeof(del_sta));
 	for (i = 0; i < WILC_MAX_NUM_STA; i++) {
 		if (!is_zero_ether_addr(mac_addr[i])) {
+			PRINT_INFO(vif->ndev,
+				   CFG80211_DBG, "BSSID = %x%x%x%x%x%x\n",
+				   mac_addr[i][0], mac_addr[i][1],
+				   mac_addr[i][2], mac_addr[i][3],
+				   mac_addr[i][4], mac_addr[i][5]);
 			assoc_sta++;
 			ether_addr_copy(del_sta.mac[i], mac_addr[i]);
 		}
 	}
 
-	if (!assoc_sta)
+	if (!assoc_sta) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "NO ASSOCIATED STAS\n");
 		return 0;
-
+	}
 	del_sta.assoc_sta = assoc_sta;
 
 	wid.id = WID_DEL_ALL_STA;
@@ -1898,53 +2295,129 @@
 	return result;
 }
 
-int wilc_edit_station(struct wilc_vif *vif, const u8 *mac,
-		      struct station_parameters *params)
+static void handle_edit_station(struct work_struct *work)
 {
-	struct wid wid;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct add_sta_param *params = &msg->body.edit_sta_info;
 	int result;
-	u8 *cur_byte;
+	struct wid wid;
 
 	wid.id = WID_EDIT_STA;
 	wid.type = WID_BIN;
-	wid.size = WILC_ADD_STA_LENGTH +
-		   params->link_sta_params.supported_rates_len;
+	wid.size = WILC_ADD_STA_LENGTH + params->supported_rates_len;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling edit station\n");
 	wid.val = kmalloc(wid.size, GFP_KERNEL);
 	if (!wid.val)
-		return -ENOMEM;
+		goto error;
 
-	cur_byte = wid.val;
-	wilc_hif_pack_sta_param(cur_byte, mac, params);
+	wilc_hif_pack_sta_param(wid.val, params);
 
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
-		netdev_err(vif->ndev, "Failed to send edit station\n");
+		PRINT_ER(vif->ndev, "Failed to send edit station\n");
 
 	kfree(wid.val);
+error:
+	kfree(params->supported_rates);
+	kfree(msg);
+}
+
+int wilc_edit_station(struct wilc_vif *vif, const u8 *mac,
+		      struct station_parameters *params)
+{
+	int result;
+	struct host_if_msg *msg;
+	struct add_sta_param *sta_params;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting editing station message queue params\n");
+
+	msg = wilc_alloc_work(vif, handle_edit_station, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+
+	sta_params = &msg->body.edit_sta_info;
+	memcpy(sta_params->bssid, mac, ETH_ALEN);
+	sta_params->aid = params->aid;
+	if (!params->link_sta_params.ht_capa) {
+		sta_params->ht_supported = false;
+	} else {
+		sta_params->ht_supported = true;
+		memcpy(&sta_params->ht_capa, params->link_sta_params.ht_capa,
+		       sizeof(struct ieee80211_ht_cap));
+	}
+	sta_params->flags_mask = params->sta_flags_mask;
+	sta_params->flags_set = params->sta_flags_set;
+
+	sta_params->supported_rates_len = params->link_sta_params.supported_rates_len;
+	if (params->link_sta_params.supported_rates_len > 0) {
+		sta_params->supported_rates = kmemdup(params->link_sta_params.supported_rates,
+					    params->link_sta_params.supported_rates_len,
+					    GFP_KERNEL);
+		if (!sta_params->supported_rates) {
+			kfree(msg);
+			return -ENOMEM;
+		}
+	}
+
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(sta_params->supported_rates);
+		kfree(msg);
+	}
+
 	return result;
 }
 
-int wilc_set_power_mgmt(struct wilc_vif *vif, bool enabled, u32 timeout)
+static void handle_power_management(struct work_struct *work)
 {
-	struct wilc *wilc = vif->wilc;
-	struct wid wid;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct power_mgmt_param *pm_param = &msg->body.pwr_mgmt_info;
 	int result;
+	struct wid wid;
 	s8 power_mode;
 
-	if (enabled)
+	wid.id = WID_POWER_MANAGEMENT;
+
+	if (pm_param->enabled)
 		power_mode = WILC_FW_MIN_FAST_PS;
 	else
 		power_mode = WILC_FW_NO_POWERSAVE;
-
-	wid.id = WID_POWER_MANAGEMENT;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling power mgmt to %d\n",
+		   power_mode);
 	wid.val = &power_mode;
 	wid.size = sizeof(char);
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling Power Management\n");
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
 		netdev_err(vif->ndev, "Failed to send power management\n");
-	else
-		wilc->power_save_mode = enabled;
 
+	kfree(msg);
+}
+
+int wilc_set_power_mgmt(struct wilc_vif *vif, bool enabled, u32 timeout)
+{
+	int result;
+	struct host_if_msg *msg;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "\n\n>> Setting PS to %d <<\n\n",
+		   enabled);
+	msg = wilc_alloc_work(vif, handle_power_management, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+
+	msg->body.pwr_mgmt_info.enabled = enabled;
+	msg->body.pwr_mgmt_info.timeout = timeout;
+
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg);
+	}
 	return result;
 }
 
@@ -1954,6 +2427,8 @@
 	int result;
 	struct host_if_msg *msg;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting Multicast Filter params\n");
 	msg = wilc_alloc_work(vif, handle_set_mcast_filter, false);
 	if (IS_ERR(msg))
 		return PTR_ERR(msg);
@@ -1982,16 +2457,46 @@
 	return wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 }
 
-int wilc_get_tx_power(struct wilc_vif *vif, u8 *tx_power)
+static void handle_get_tx_pwr(struct work_struct *work)
 {
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	u8 *tx_pwr = &msg->body.tx_power.tx_pwr;
+	int ret;
 	struct wid wid;
 
 	wid.id = WID_TX_POWER;
 	wid.type = WID_CHAR;
-	wid.val = tx_power;
+	wid.val = tx_pwr;
 	wid.size = sizeof(char);
 
-	return wilc_send_config_pkt(vif, WILC_GET_CFG, &wid, 1);
+	ret = wilc_send_config_pkt(vif, WILC_GET_CFG, &wid, 1);
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to get TX PWR\n");
+
+	complete(&msg->work_comp);
+}
+
+int wilc_get_tx_power(struct wilc_vif *vif, u8 *tx_power)
+{
+	int ret;
+	struct host_if_msg *msg;
+
+	msg = wilc_alloc_work(vif, handle_get_tx_pwr, true);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+
+	ret = wilc_enqueue_work(msg);
+	if (ret) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+	} else {
+		wait_for_completion(&msg->work_comp);
+		*tx_power = msg->body.tx_power.tx_pwr;
+	}
+
+	/* free 'msg' after copying data */
+	kfree(msg);
+	return ret;
 }
 
 int wilc_set_default_mgmt_key_index(struct wilc_vif *vif, u8 index)
@@ -2010,3 +2515,89 @@
 
         return result;
 }
+
+static bool is_valid_gpio(struct wilc_vif *vif, u8 gpio)
+{
+	switch (vif->wilc->chip) {
+	case WILC_1000:
+		if (gpio == 0 || gpio == 1 || gpio == 4 || gpio == 6)
+			return true;
+		else
+			return false;
+	case WILC_3000:
+		if (gpio == 0 || gpio == 3 || gpio == 4 ||
+		    (gpio >= 17 && gpio <= 20))
+			return true;
+		else
+			return false;
+	default:
+		return false;
+	}
+}
+
+int wilc_set_antenna(struct wilc_vif *vif, u8 mode)
+{
+	struct wid wid;
+	int ret;
+	struct sysfs_attr_group *attr_sysfs_p = &vif->wilc->attr_sysfs;
+	struct host_if_set_ant set_ant;
+
+	set_ant.mode = mode;
+
+	if (attr_sysfs_p->ant_swtch_mode == ANT_SWTCH_INVALID_GPIO_CTRL) {
+		pr_err("Ant switch GPIO mode is invalid.\n");
+		pr_err("Set it using /sys/wilc/ant_swtch_mode\n");
+		return -EINVAL;
+	}
+
+	if (is_valid_gpio(vif, attr_sysfs_p->antenna1)) {
+		set_ant.antenna1 = attr_sysfs_p->antenna1;
+	} else  {
+		pr_err("Invalid GPIO %d\n", attr_sysfs_p->antenna1);
+		return -EINVAL;
+	}
+
+	if (attr_sysfs_p->ant_swtch_mode == ANT_SWTCH_DUAL_GPIO_CTRL) {
+		if (attr_sysfs_p->antenna2 != attr_sysfs_p->antenna1 &&
+		    is_valid_gpio(vif, attr_sysfs_p->antenna2)) {
+			set_ant.antenna2 = attr_sysfs_p->antenna2;
+		} else {
+			pr_err("Invalid GPIO %d\n", attr_sysfs_p->antenna2);
+			return -EINVAL;
+		}
+	}
+
+	set_ant.gpio_mode = attr_sysfs_p->ant_swtch_mode;
+
+	wid.id = WID_ANTENNA_SELECTION;
+	wid.type = WID_BIN;
+	wid.val = (u8 *)&set_ant;
+	wid.size = sizeof(struct host_if_set_ant);
+	if (attr_sysfs_p->ant_swtch_mode == ANT_SWTCH_SNGL_GPIO_CTRL)
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "set antenna %d on GPIO %d\n", set_ant.mode,
+			   set_ant.antenna1);
+	else if (attr_sysfs_p->ant_swtch_mode == ANT_SWTCH_DUAL_GPIO_CTRL)
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "set antenna %d on GPIOs %d and %d\n",
+			   set_ant.mode, set_ant.antenna1,
+			   set_ant.antenna2);
+
+	ret = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to set antenna mode\n");
+
+	return ret;
+}
+
+void wilc_set_fw_debug_level(struct wilc *wl, u8 dbg_level)
+{
+	struct wilc_vif *vif = wilc_get_wl_to_vif(wl);
+	struct wid wid;
+
+	wid.id = WID_FW_PRINT_LEVEL;
+	wid.type = WID_CHAR;
+	wid.size = sizeof(char);
+	wid.val = &dbg_level;
+	wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
+}
--- linux-6.6.51/drivers/net/wireless/microchip/wilc1000/hif.h	2024-12-05 13:07:51.229701500 +0900
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/hif.h	2024-12-04 16:41:31.556539800 +0900
@@ -14,7 +14,8 @@
 	WILC_AP_MODE = 0x1,
 	WILC_STATION_MODE = 0x2,
 	WILC_GO_MODE = 0x3,
-	WILC_CLIENT_MODE = 0x4
+	WILC_CLIENT_MODE = 0x4,
+	WILC_MONITOR_MODE = 0x5
 };
 
 #define WILC_MAX_NUM_PROBED_SSID		10
@@ -30,6 +31,8 @@
 	WILC_GET_CFG
 };
 
+extern uint32_t cfg_packet_timeout;
+
 struct rf_info {
 	u8 link_speed;
 	s8 rssi;
@@ -79,10 +82,12 @@
 
 enum {
 	WILC_HIF_SDIO = 0,
-	WILC_HIF_SPI = BIT(0)
+	WILC_HIF_SPI = BIT(0),
+	WILC_HIF_SDIO_GPIO_IRQ = BIT(1)
 };
 
 enum {
+	WILC_MAC_STATUS_PRE_INIT = -2,
 	WILC_MAC_STATUS_INIT = -1,
 	WILC_MAC_STATUS_DISCONNECTED = 0,
 	WILC_MAC_STATUS_CONNECTED = 1
@@ -95,34 +100,37 @@
 	struct ieee80211_mgmt *mgmt;
 };
 
+struct wilc_priv;
 struct wilc_user_scan_req {
 	void (*scan_result)(enum scan_event evt,
-			    struct wilc_rcvd_net_info *info, void *priv);
-	void *arg;
+			    struct wilc_rcvd_net_info *info,
+			    struct wilc_priv *priv);
+	struct wilc_priv *priv;
 	u32 ch_cnt;
 };
 
+struct wilc_join_bss_param;
 struct wilc_conn_info {
 	u8 bssid[ETH_ALEN];
 	u8 security;
 	enum authtype auth_type;
 	enum mfptype mfp_type;
-	u8 ch;
 	u8 *req_ies;
 	size_t req_ies_len;
 	u8 *resp_ies;
 	u16 resp_ies_len;
 	u16 status;
-	void (*conn_result)(enum conn_event evt, u8 status, void *priv_data);
-	void *arg;
-	void *param;
+	void (*conn_result)(enum conn_event evt, u8 status,
+			    struct wilc_priv *priv);
+	struct wilc_priv *priv;
+	struct wilc_join_bss_param *param;
 };
 
+struct wilc_vif;
 struct wilc_remain_ch {
 	u16 ch;
-	u32 duration;
-	void (*expired)(void *priv, u64 cookie);
-	void *arg;
+	void (*expired)(struct wilc_vif *vif, u64 cookie);
+	struct wilc_vif *vif;
 	u64 cookie;
 };
 
@@ -151,6 +159,13 @@
 };
 
 struct wilc_vif;
+
+signed int wilc_send_buffered_eap(struct wilc_vif *vif,
+				  void (*deliver_to_stack)(struct wilc_vif *,
+							   u8 *, u32, u32, u8),
+				  void (*eap_buf_param)(void *), u8 *buff,
+				  unsigned int size, unsigned int pkt_offset,
+				  void *user_arg);
 int wilc_add_ptk(struct wilc_vif *vif, const u8 *ptk, u8 ptk_key_len,
 		 const u8 *mac_addr, const u8 *rx_mic, const u8 *tx_mic,
 		 u8 mode, u8 cipher_mode, u8 index);
@@ -171,11 +186,12 @@
 int wilc_disconnect(struct wilc_vif *vif);
 int wilc_set_mac_chnl_num(struct wilc_vif *vif, u8 channel);
 int wilc_get_rssi(struct wilc_vif *vif, s8 *rssi_level);
-int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
-	      u8 *ch_freq_list, u8 ch_list_len,
+int wilc_scan(struct wilc_vif *vif, u8 scan_source,
+	      u8 scan_type, u8 *ch_freq_list,
 	      void (*scan_result_fn)(enum scan_event,
-				     struct wilc_rcvd_net_info *, void *),
-	      void *user_arg, struct cfg80211_scan_request *request);
+				     struct wilc_rcvd_net_info *,
+				     struct wilc_priv *),
+	      struct cfg80211_scan_request *request);
 int wilc_hif_set_cfg(struct wilc_vif *vif,
 		     struct cfg_param_attr *cfg_param);
 int wilc_init(struct net_device *dev, struct host_if_drv **hif_drv_handler);
@@ -192,10 +208,8 @@
 int wilc_set_power_mgmt(struct wilc_vif *vif, bool enabled, u32 timeout);
 int wilc_setup_multicast_filter(struct wilc_vif *vif, u32 enabled, u32 count,
 				u8 *mc_list);
-int wilc_remain_on_channel(struct wilc_vif *vif, u64 cookie,
-			   u32 duration, u16 chan,
-			   void (*expired)(void *, u64),
-			   void *user_arg);
+int wilc_remain_on_channel(struct wilc_vif *vif, u64 cookie, u16 chan,
+			   void (*expired)(struct wilc_vif *, u64));
 int wilc_listen_state_expired(struct wilc_vif *vif, u64 cookie);
 void wilc_frame_register(struct wilc_vif *vif, u16 frame_type, bool reg);
 int wilc_set_operation_mode(struct wilc_vif *vif, int index, u8 mode,
@@ -207,12 +221,21 @@
 void wilc_set_wowlan_trigger(struct wilc_vif *vif, bool enabled);
 int wilc_set_external_auth_param(struct wilc_vif *vif,
 				 struct cfg80211_external_auth_params *param);
+/* 0 select antenna 1 , 2 select antenna mode , 2 allow the firmware to choose
+ * the best antenna
+ */
+int wilc_set_antenna(struct wilc_vif *vif, u8 mode);
+int handle_scan_done(struct wilc_vif *vif, enum scan_event evt);
 void wilc_scan_complete_received(struct wilc *wilc, u8 *buffer, u32 length);
 void wilc_network_info_received(struct wilc *wilc, u8 *buffer, u32 length);
 void wilc_gnrl_async_info_received(struct wilc *wilc, u8 *buffer, u32 length);
-void *wilc_parse_join_bss_param(struct cfg80211_bss *bss,
-				struct cfg80211_crypto_settings *crypto);
+struct wilc_join_bss_param *
+wilc_parse_join_bss_param(struct cfg80211_bss *bss,
+			  struct cfg80211_crypto_settings *crypto);
 int wilc_set_default_mgmt_key_index(struct wilc_vif *vif, u8 index);
-void wilc_handle_disconnect(struct wilc_vif *vif);
 
+void wilc_handle_disconnect(struct wilc_vif *vif);
+int wilc_of_parse_power_pins(struct wilc *wilc);
+void wilc_wlan_power(struct wilc *wilc, bool on);
+void wilc_set_fw_debug_level(struct wilc *wl,u8 dbg_level);
 #endif
--- linux-6.6.51/drivers/net/wireless/microchip/wilc1000/mon.c	2024-12-05 13:07:51.230698900 +0900
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/mon.c	2024-12-04 16:41:31.556539800 +0900
@@ -31,8 +31,11 @@
 	if (!mon_dev)
 		return;
 
-	if (!netif_running(mon_dev))
+	if (!netif_running(mon_dev)) {
+		PRINT_D(mon_dev, HOSTAPD_DBG,
+			"Monitor interface already RUNNING\n");
 		return;
+	}
 
 	/* Get WILC header */
 	header = get_unaligned_le32(buff - HOST_HDR_OFFSET);
@@ -46,9 +49,11 @@
 		/* hostapd callback mgmt frame */
 
 		skb = dev_alloc_skb(size + sizeof(*cb_hdr));
-		if (!skb)
+		if (!skb) {
+			PRINT_D(mon_dev, HOSTAPD_DBG,
+				"Monitor if : No memory to allocate skb");
 			return;
-
+		}
 		skb_put_data(skb, buff, size);
 
 		cb_hdr = skb_push(skb, sizeof(*cb_hdr));
@@ -80,8 +85,12 @@
 		memset(hdr, 0, sizeof(struct wilc_wfi_radiotap_hdr));
 		hdr->hdr.it_version = 0; /* PKTHDR_RADIOTAP_VERSION; */
 		hdr->hdr.it_len = cpu_to_le16(sizeof(*hdr));
+		PRINT_D(mon_dev, HOSTAPD_DBG,
+			"Radiotap len %d\n", hdr->hdr.it_len);
 		hdr->hdr.it_present = cpu_to_le32
-				(1 << IEEE80211_RADIOTAP_RATE);
+				(1 << IEEE80211_RADIOTAP_RATE); /* | */
+		PRINT_D(mon_dev, HOSTAPD_DBG, "Presentflags %d\n",
+			hdr->hdr.it_present);
 		hdr->rate = 5;
 	}
 
@@ -191,6 +200,10 @@
 	}
 	skb->dev = mon_priv->real_ndev;
 
+	PRINT_D(dev, HOSTAPD_DBG, "Skipping the radiotap header\n");
+	PRINT_D(dev, HOSTAPD_DBG, "SKB netdevice name = %s\n", skb->dev->name);
+	PRINT_D(dev, HOSTAPD_DBG, "MONITOR real dev name = %s\n",
+		mon_priv->real_ndev->name);
 	ether_addr_copy(srcadd, &skb->data[10]);
 	ether_addr_copy(bssid, &skb->data[16]);
 	/*
@@ -250,9 +263,14 @@
 	if (!wl->monitor_dev)
 		return;
 
+	PRINT_INFO(wl->monitor_dev, HOSTAPD_DBG,
+		   "In Deinit monitor interface\n");
+	PRINT_INFO(wl->monitor_dev, HOSTAPD_DBG, "Unregister monitor netdev\n");
 	if (rtnl_locked)
 		unregister_netdevice(wl->monitor_dev);
 	else
 		unregister_netdev(wl->monitor_dev);
+	PRINT_INFO(wl->monitor_dev, HOSTAPD_DBG,
+		   "Deinit monitor interface done\n");
 	wl->monitor_dev = NULL;
 }
--- linux-6.6.51/drivers/net/wireless/microchip/wilc1000/netdev.c	2024-12-05 13:07:51.230698900 +0900
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/netdev.c	2024-12-04 16:41:31.557537300 +0900
@@ -19,10 +19,166 @@
 /* latest API version supported */
 #define WILC1000_API_VER		1
 
-#define WILC1000_FW_PREFIX		"atmel/wilc1000_wifi_firmware-"
+#define WILC1000_FW_PREFIX		"mchp/wilc1000_wifi_firmware"
 #define __WILC1000_FW(api)		WILC1000_FW_PREFIX #api ".bin"
 #define WILC1000_FW(api)		__WILC1000_FW(api)
 
+#define WILC3000_API_VER		1
+
+#define WILC3000_FW_PREFIX		"mchp/wilc3000_wifi_firmware"
+#define __WILC3000_FW(api)		WILC3000_FW_PREFIX #api ".bin"
+#define WILC3000_FW(api)		__WILC3000_FW(api)
+
+#define WILCS02_FW_PREFIX			"mchp/wilcs02_wifi_firmware"
+#define __WILCS02_FW(api)			WILCS02_FW_PREFIX #api ".bin"
+#define WILCS02_FW(api)			__WILCS02_FW(api)
+
+#define WILC_FIRMWARE_START_TIMEOUT		500
+#define WILC_S02_FIRMWARE_START_TIMEOUT		10000
+
+static int wilc_mac_open(struct net_device *ndev);
+static int wilc_mac_close(struct net_device *ndev);
+
+
+#ifdef WILC_S02_TEST_BUS_INTERFACE
+static int frame_size= WILC_S02_TEST_FRAME_SIZE;	/* configure the frame size of loopback */
+module_param(frame_size, int, 0644);
+MODULE_PARM_DESC(frame_size,
+		 "use to configure frame size, default 1546");
+
+bool is_test_mode= false;	/* enable loopback test */
+module_param(is_test_mode, bool, 0644);
+MODULE_PARM_DESC(is_test_mode,
+		 "use to enable loopback test mode, is_loopback_mode = 1 means loopback is enable, default disabled");
+#endif /* WILCS02_TEST_BUS_INTERFACE */
+
+static int debug_running;
+static int recovery_on;
+int wait_for_recovery;
+static int debug_thread(void *arg)
+{
+	struct wilc *wl = arg;
+	struct wilc_vif *vif;
+	signed long timeout;
+	struct host_if_drv *hif_drv;
+	int i = 0;
+
+	complete(&wl->debug_thread_started);
+
+	while (1) {
+		int srcu_idx;
+		int ret;
+
+		if (!wl->initialized && !kthread_should_stop()) {
+			msleep(1000);
+			continue;
+		} else if (!wl->initialized) {
+			break;
+		}
+		ret = wait_for_completion_interruptible_timeout(
+			&wl->debug_thread_started, msecs_to_jiffies(6000));
+		if (ret > 0) {
+			while (!kthread_should_stop())
+				schedule();
+			pr_info("Exit debug thread\n");
+			return 0;
+		}
+		if (!debug_running || ret == -ERESTARTSYS)
+			continue;
+
+		pr_debug("%s *** Debug Thread Running ***cnt[%d]\n", __func__,
+			 cfg_packet_timeout);
+
+		if (cfg_packet_timeout < 5)
+			continue;
+
+		pr_info("%s <Recover>\n", __func__);
+		cfg_packet_timeout = 0;
+		timeout = 10;
+		recovery_on = 1;
+		wait_for_recovery = 1;
+
+		srcu_idx = srcu_read_lock(&wl->srcu);
+		list_for_each_entry_rcu(vif, &wl->vif_list, list) {
+			/* close the interface only if it was open */
+			if (vif->mac_opened) {
+				wilc_mac_close(vif->ndev);
+				vif->restart = 1;
+			}
+		}
+
+		/* For Spi, clear 'is_init' flag so that protocol offset
+		 * register can be send to FW to setup required crc mode after
+		 * chip reset
+		 */
+		if (wl->io_type == WILC_HIF_SPI)
+			wl->hif_func->hif_clear_init(wl);
+
+		//TODO://Need to find way to call them in reverse
+		i = 0;
+		list_for_each_entry_rcu(vif, &wl->vif_list, list) {
+			struct wilc_conn_info *info;
+
+			/* Only open the interface manually closed earlier */
+			if (!vif->restart)
+				continue;
+			i++;
+			hif_drv = vif->priv.hif_drv;
+			while (wilc_mac_open(vif->ndev) && --timeout)
+				msleep(100);
+
+			if (timeout == 0)
+				PRINT_WRN(vif->ndev, GENERIC_DBG,
+					  "Couldn't restart ifc %d\n", i);
+
+			if (hif_drv->hif_state == HOST_IF_CONNECTED) {
+				info = &hif_drv->conn_info;
+				PRINT_INFO(vif->ndev, GENERIC_DBG,
+					   "notify the user with the Disconnection\n");
+				if (hif_drv->usr_scan_req.scan_result) {
+					PRINT_INFO(vif->ndev, GENERIC_DBG,
+						   "Abort the running OBSS Scan\n");
+					del_timer(&hif_drv->scan_timer);
+					handle_scan_done(vif,
+							 SCAN_EVENT_ABORTED);
+				}
+				if (info->conn_result) {
+					info->conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF,
+							  0, info->priv);
+				} else {
+					PRINT_ER(vif->ndev,
+						 "Connect result NULL\n");
+				}
+				eth_zero_addr(hif_drv->assoc_bssid);
+				info->req_ies_len = 0;
+				kfree(info->req_ies);
+				info->req_ies = NULL;
+				hif_drv->hif_state = HOST_IF_IDLE;
+			}
+			vif->restart = 0;
+		}
+		srcu_read_unlock(&wl->srcu, srcu_idx);
+		recovery_on = 0;
+	}
+	return 0;
+}
+
+static void wilc_disable_irq(struct wilc *wilc, int wait)
+{
+	if (wait) {
+		pr_info("%s Disabling IRQ ...\n", __func__);
+		disable_irq(wilc->dev_irq_num);
+	} else {
+		pr_info("%s Disabling IRQ ...\n", __func__);
+		disable_irq_nosync(wilc->dev_irq_num);
+	}
+}
+
+static irqreturn_t host_wakeup_isr(int irq, void *user_data)
+{
+	return IRQ_HANDLED;
+}
+
 static irqreturn_t isr_uh_routine(int irq, void *user_data)
 {
 	struct wilc *wilc = user_data;
@@ -52,18 +208,31 @@
 {
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wl = vif->wilc;
-	int ret;
 
-	ret = request_threaded_irq(wl->dev_irq_num, isr_uh_routine,
-				   isr_bh_routine,
-				   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
-				   dev->name, wl);
-	if (ret) {
-		netdev_err(dev, "Failed to request IRQ [%d]\n", ret);
-		return ret;
+	if (wl->dev_irq_num <= 0)
+		return 0;
+
+	if (wl->io_type == WILC_HIF_SPI ||
+	    wl->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+		if (request_threaded_irq(wl->dev_irq_num, isr_uh_routine,
+					 isr_bh_routine,
+					 IRQF_TRIGGER_FALLING | IRQF_NO_SUSPEND,
+					 dev->name, wl) < 0) {
+			pr_err("Failed to request IRQ [%d]\n", wl->dev_irq_num);
+			return -EINVAL;
+		}
+	} else {
+		if (request_irq(wl->dev_irq_num, host_wakeup_isr,
+				IRQF_TRIGGER_FALLING | IRQF_NO_SUSPEND,
+				dev->name, wl) < 0) {
+			pr_err("Failed to request IRQ [%d]\n", wl->dev_irq_num);
+			return -EINVAL;
+		}
 	}
-	netdev_dbg(dev, "IRQ request succeeded IRQ-NUM= %d\n", wl->dev_irq_num);
 
+	PRINT_INFO(dev, GENERIC_DBG, "IRQ request succeeded IRQ-NUM= %d\n",
+		   wl->dev_irq_num);
+	enable_irq_wake(wl->dev_irq_num);
 	return 0;
 }
 
@@ -90,26 +259,47 @@
 	}
 }
 
-static struct net_device *get_if_handler(struct wilc *wilc, u8 *mac_header)
+static void free_eap_buff_params(void *vp)
 {
-	struct net_device *ndev = NULL;
-	struct wilc_vif *vif;
-	struct ieee80211_hdr *h = (struct ieee80211_hdr *)mac_header;
+	struct wilc_priv *priv;
 
-	list_for_each_entry_rcu(vif, &wilc->vif_list, list) {
-		if (vif->iftype == WILC_STATION_MODE)
-			if (ether_addr_equal_unaligned(h->addr2, vif->bssid)) {
-				ndev = vif->ndev;
-				goto out;
-			}
-		if (vif->iftype == WILC_AP_MODE)
-			if (ether_addr_equal_unaligned(h->addr1, vif->bssid)) {
-				ndev = vif->ndev;
-				goto out;
-			}
+	priv = (struct wilc_priv *)vp;
+
+	if (priv->buffered_eap) {
+		kfree(priv->buffered_eap->buff);
+		priv->buffered_eap->buff = NULL;
+
+		kfree(priv->buffered_eap);
+		priv->buffered_eap = NULL;
+	}
+}
+
+void eap_buff_timeout(struct timer_list *t)
+{
+	u8 null_bssid[ETH_ALEN] = {0};
+	u8 *assoc_bss;
+	static u8 timeout = 5;
+	int status = -1;
+	struct wilc_priv *priv = from_timer(priv, t, eap_buff_timer);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+
+	assoc_bss = priv->associated_bss;
+	if (!(memcmp(assoc_bss, null_bssid, ETH_ALEN)) && (timeout-- > 0)) {
+		mod_timer(&priv->eap_buff_timer,
+			  (jiffies + msecs_to_jiffies(10)));
+		return;
 	}
-out:
-	return ndev;
+	del_timer(&priv->eap_buff_timer);
+	timeout = 5;
+
+	status = wilc_send_buffered_eap(vif, wilc_frmw_to_host,
+					free_eap_buff_params,
+					priv->buffered_eap->buff,
+					priv->buffered_eap->size,
+					priv->buffered_eap->pkt_offset,
+					(void *)priv);
+	if (status)
+		PRINT_ER(vif->ndev, "Failed so send buffered eap\n");
 }
 
 void wilc_wlan_set_bssid(struct net_device *wilc_netdev, const u8 *bssid,
@@ -148,15 +338,22 @@
 
 	complete(&wl->txq_thread_started);
 	while (1) {
-		wait_for_completion(&wl->txq_event);
+		struct wilc_vif *vif = wilc_get_wl_to_vif(wl);
+		struct net_device *ndev = vif->ndev;
 
+		PRINT_INFO(ndev, TX_DBG, "txq_task Taking a nap\n");
+		if (wait_for_completion_interruptible(&wl->txq_event))
+			continue;
+		PRINT_INFO(ndev, TX_DBG, "txq_task Who waked me up\n");
 		if (wl->close) {
 			complete(&wl->txq_thread_started);
 
 			while (!kthread_should_stop())
 				schedule();
+			PRINT_INFO(ndev, TX_DBG, "TX thread stopped\n");
 			break;
 		}
+		PRINT_INFO(ndev, TX_DBG, "handle the tx packet\n");
 		do {
 			ret = wilc_wlan_handle_txq(wl, &txq_count);
 			if (txq_count < FLOW_CONTROL_LOWER_THRESHOLD) {
@@ -166,34 +363,55 @@
 				srcu_idx = srcu_read_lock(&wl->srcu);
 				list_for_each_entry_rcu(ifc, &wl->vif_list,
 							list) {
-					if (ifc->mac_opened && ifc->ndev)
+					if (ifc->mac_opened &&
+					    netif_queue_stopped(ifc->ndev))
 						netif_wake_queue(ifc->ndev);
 				}
 				srcu_read_unlock(&wl->srcu, srcu_idx);
 			}
-		} while (ret == WILC_VMM_ENTRY_FULL_RETRY && !wl->close);
+			if (ret != WILC_VMM_ENTRY_FULL_RETRY)
+				break;
+			/* Back off TX task from sending packets for some time.
+			 * msleep_interruptible will allow RX task to run and
+			 * free buffers. TX task will be in TASK_INTERRUPTIBLE
+			 * state which will put the thread back to CPU running
+			 * queue when it's signaled even if the timeout isn't
+			 * elapsed. This gives faster chance for reserved SK
+			 * buffers to be free.
+			 */
+			msleep_interruptible(TX_BACKOFF_WEIGHT_MS);
+		} while (!wl->close);
 	}
 	return 0;
 }
 
-static int wilc_wlan_get_firmware(struct net_device *dev)
+static int wilc_wlan_get_firmware(struct wilc *wilc)
 {
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
-	int chip_id;
 	const struct firmware *wilc_fw;
+	char *firmware;
 	int ret;
 
-	chip_id = wilc_get_chipid(wilc, false);
-
-	netdev_info(dev, "ChipID [%x] loading firmware [%s]\n", chip_id,
-		    WILC1000_FW(WILC1000_API_VER));
+	if (wilc->chip == WILC_3000) {
+		pr_info("Detect chip WILC3000\n");
+		firmware = WILC3000_FW();
+	} else if (wilc->chip == WILC_1000) {
+		pr_info("Detect chip WILC1000\n");
+		firmware = WILC1000_FW();
+	} else if (wilc->chip == WILC_S02) {
+		dev_dbg(wilc->dev, "Detect chip WILCS02\n");
+		firmware = WILCS02_FW();
+	} else {
+		return -EINVAL;
+	}
+	pr_info("loading firmware %s\n", firmware);
 
-	ret = request_firmware(&wilc_fw, WILC1000_FW(WILC1000_API_VER),
-			       wilc->dev);
+	ret = request_firmware(&wilc_fw, firmware, wilc->dev);
 	if (ret != 0) {
-		netdev_err(dev, "%s - firmware not available\n",
-			   WILC1000_FW(WILC1000_API_VER));
+		if (wilc->chip != WILC_S02) {
+			pr_err("%s - firmware not available\n", firmware);
+		} else {
+			pr_err("Use pre-installed firmware for WILC-SO2 LinkController\n");
+		}
 		return -EINVAL;
 	}
 	wilc->firmware = wilc_fw;
@@ -206,40 +424,64 @@
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wilc = vif->wilc;
 	int ret = 0;
+	unsigned int m;
 
-	ret = wilc_wlan_start(wilc);
-	if (ret)
+	PRINT_INFO(vif->ndev, INIT_DBG, "Starting Firmware ...\n");
+
+	if (wilc->chip == WILC_S02) {
+		ret = wilc_wlan_start_wilcs02_fw(wilc);
+		m = WILC_S02_FIRMWARE_START_TIMEOUT;
+	} else {
+		ret = wilc_wlan_start(wilc);
+		m = WILC_FIRMWARE_START_TIMEOUT;
+	}
+	if (ret < 0) {
+		PRINT_ER(dev, "Failed to start Firmware\n");
 		return ret;
+	}
 
-	if (!wait_for_completion_timeout(&wilc->sync_event,
-					 msecs_to_jiffies(5000)))
+	PRINT_INFO(vif->ndev, INIT_DBG, "Waiting for FW to get ready ...\n");
+#ifdef WILC_S02_TEST_BUS_INTERFACE
+	if (is_test_mode)
+		msleep(5000);
+	if (!is_test_mode)
+#endif
+	{
+		if (!wait_for_completion_timeout(&wilc->sync_event,
+					 msecs_to_jiffies(m))) {
+		PRINT_INFO(vif->ndev, INIT_DBG, "Firmware start timed out\n");
 		return -ETIME;
+	}
 
+	if (wilc->mac_status == WILC_MAC_STATUS_PRE_INIT)
+		return -ETIME;
+	}
+	PRINT_INFO(vif->ndev, INIT_DBG, "Firmware successfully started\n");
+	wilc->initialized = 1;
 	return 0;
 }
 
-static int wilc1000_firmware_download(struct net_device *dev)
+static int wilc_firmware_download(struct wilc *wilc)
 {
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
-	int ret = 0;
+	int ret;
 
 	if (!wilc->firmware) {
-		netdev_err(dev, "Firmware buffer is NULL\n");
-		return -ENOBUFS;
+		pr_err("Firmware buffer is NULL\n");
+		ret = -ENOBUFS;
 	}
-
+	pr_info("Downloading Firmware ...\n");
 	ret = wilc_wlan_firmware_download(wilc, wilc->firmware->data,
 					  wilc->firmware->size);
 	if (ret)
-		return ret;
+		goto fail;
 
+	pr_info("Download Succeeded\n");
+
+fail:
 	release_firmware(wilc->firmware);
 	wilc->firmware = NULL;
 
-	netdev_dbg(dev, "Download Succeeded\n");
-
-	return 0;
+	return ret;
 }
 
 static int wilc_init_fw_config(struct net_device *dev, struct wilc_vif *vif)
@@ -272,7 +514,7 @@
 	if (!wilc_wlan_cfg_set(vif, 0, WID_11G_OPERATING_MODE, &b, 1, 0, 0))
 		goto fail;
 
-	b = WILC_FW_PREAMBLE_SHORT;
+	b = WILC_FW_PREAMBLE_AUTO;
 	if (!wilc_wlan_cfg_set(vif, 0, WID_PREAMBLE, &b, 1, 0, 0))
 		goto fail;
 
@@ -402,9 +644,13 @@
 	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_CURRENT_TX_MCS, &b, 1, 0, 0))
 		goto fail;
 
+	b = vif->wilc->attr_sysfs.fw_dbg_level;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_FW_PRINT_LEVEL, &b, 1, 0, 0))
+		goto fail;
+
 	b = 1;
 	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_IMMEDIATE_BA_ENABLED, &b, 1,
-			       1, 1))
+			       1, 0))
 		goto fail;
 
 	return 0;
@@ -418,7 +664,19 @@
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wl = vif->wilc;
 
+	PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Threads\n");
+	if (!recovery_on) {
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinit debug Thread\n");
+		debug_running = false;
+		complete(&wl->debug_thread_started);
+		if (wl->debug_thread) {
+			kthread_stop(wl->debug_thread);
+			wl->debug_thread = NULL;
+		}
+	}
+
 	wl->close = 1;
+	PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Threads\n");
 
 	complete(&wl->txq_event);
 
@@ -430,36 +688,50 @@
 
 static void wilc_wlan_deinitialize(struct net_device *dev)
 {
+	int ret;
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wl = vif->wilc;
 
 	if (!wl) {
-		netdev_err(dev, "wl is NULL\n");
+		PRINT_ER(dev, "wl is NULL\n");
 		return;
 	}
 
 	if (wl->initialized) {
-		netdev_info(dev, "Deinitializing wilc1000...\n");
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing wilc  ...\n");
 
-		if (!wl->dev_irq_num &&
-		    wl->hif_func->disable_interrupt) {
-			mutex_lock(&wl->hif_cs);
-			wl->hif_func->disable_interrupt(wl);
-			mutex_unlock(&wl->hif_cs);
+		PRINT_D(vif->ndev, INIT_DBG, "destroy aging timer\n");
+
+		PRINT_INFO(vif->ndev, INIT_DBG, "Disabling IRQ\n");
+		if (wl->io_type == WILC_HIF_SPI ||
+		    wl->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+			wilc_disable_irq(wl, 1);
+		} else {
+			if (wl->hif_func->disable_interrupt) {
+				mutex_lock(&wl->hif_cs);
+				wl->hif_func->disable_interrupt(wl);
+				mutex_unlock(&wl->hif_cs);
+			}
 		}
 		complete(&wl->txq_event);
 
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Threads\n");
 		wlan_deinitialize_threads(dev);
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing IRQ\n");
 		deinit_irq(dev);
 
-		wilc_wlan_stop(wl, vif);
+		ret = wilc_wlan_stop(wl, vif);
+		if (ret != 0)
+			PRINT_ER(dev, "failed in wlan_stop\n");
+
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing WILC Wlan\n");
 		wilc_wlan_cleanup(dev);
 
 		wl->initialized = false;
 
-		netdev_dbg(dev, "wilc1000 deinitialization Done\n");
+		PRINT_INFO(dev, INIT_DBG, "wilc deinitialization Done\n");
 	} else {
-		netdev_dbg(dev, "wilc1000 is not initialized\n");
+		PRINT_INFO(dev, INIT_DBG, "wilc is not initialized\n");
 	}
 }
 
@@ -468,6 +740,8 @@
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wilc = vif->wilc;
 
+	PRINT_INFO(vif->ndev, INIT_DBG, "Initializing Threads ...\n");
+	PRINT_INFO(vif->ndev, INIT_DBG, "Creating kthread for transmission\n");
 	wilc->txq_thread = kthread_run(wilc_txq_task, (void *)wilc,
 				       "%s-tx", dev->name);
 	if (IS_ERR(wilc->txq_thread)) {
@@ -477,9 +751,54 @@
 	}
 	wait_for_completion(&wilc->txq_thread_started);
 
+	if (!debug_running) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Creating kthread for Debugging\n");
+		wilc->debug_thread = kthread_run(debug_thread, (void *)wilc,
+						 "WILC_DEBUG");
+		if (IS_ERR(wilc->debug_thread)) {
+			PRINT_ER(dev, "couldn't create debug thread\n");
+			wilc->close = 1;
+			kthread_stop(wilc->txq_thread);
+			return PTR_ERR(wilc->debug_thread);
+		}
+		debug_running = true;
+		wait_for_completion(&wilc->debug_thread_started);
+	}
+
 	return 0;
 }
 
+int wilc_s02_reset_firmware(struct wilc *wilc, u32 type)
+{
+	int ret;
+
+	ret = wilc->hif_func->hif_write_reg(wilc,
+					    wilc->vmm_ctl.host_vmm_tx_ctl,
+					    type);
+	if (ret)
+		pr_err("fail to write reg host_vmm_tx_ctl");
+
+	return ret;
+}
+
+int wilc_s02_check_firmware_download(struct wilc *wl)
+{
+	int ret;
+
+	ret = wilc_wlan_get_firmware(wl);
+	if (ret) {
+		pr_err("FW file doesn't exist so proceed with pre installed image");
+		return 0;
+	}
+
+	ret = wilc_firmware_download(wl);
+	if (ret)
+		pr_err("Failed to download firmware");
+
+	return ret;
+}
+
 static int wilc_wlan_initialize(struct net_device *dev, struct wilc_vif *vif)
 {
 	int ret = 0;
@@ -497,45 +816,56 @@
 		if (ret)
 			goto fail_wilc_wlan;
 
-		if (wl->dev_irq_num && init_irq(dev)) {
-			ret = -EIO;
+		ret = init_irq(dev);
+		if (ret)
 			goto fail_threads;
-		}
 
-		if (!wl->dev_irq_num &&
-		    wl->hif_func->enable_interrupt &&
+		if (wl->io_type == WILC_HIF_SDIO &&
 		    wl->hif_func->enable_interrupt(wl)) {
 			ret = -EIO;
 			goto fail_irq_init;
 		}
 
-		ret = wilc_wlan_get_firmware(dev);
-		if (ret)
-			goto fail_irq_enable;
-
-		ret = wilc1000_firmware_download(dev);
-		if (ret)
-			goto fail_irq_enable;
+		if (wl->chip != WILC_S02) {
+			ret = wilc_wlan_get_firmware(wl);
+			if (ret) {
+				PRINT_ER(dev, "Can't get firmware\n");
+				goto fail_irq_enable;
+			}
+			ret = wilc_firmware_download(wl);
+			if (ret) {
+				PRINT_ER(dev, "Failed to download firmware\n");
+				goto fail_irq_enable;
+			}
+		}
 
 		ret = wilc_start_firmware(dev);
-		if (ret)
+		if (ret) {
+			PRINT_ER(dev, "Failed to start firmware\n");
 			goto fail_irq_enable;
-
-		if (wilc_wlan_cfg_get(vif, 1, WID_FIRMWARE_VERSION, 1, 0)) {
-			int size;
-			char firmware_ver[WILC_MAX_FW_VERSION_STR_SIZE];
-
-			size = wilc_wlan_cfg_get_val(wl, WID_FIRMWARE_VERSION,
-						     firmware_ver,
-						     sizeof(firmware_ver));
-			firmware_ver[size] = '\0';
-			netdev_dbg(dev, "Firmware Ver = %s\n", firmware_ver);
 		}
+#ifdef WILC_S02_TEST_BUS_INTERFACE
+		if (!is_test_mode)
+#endif
+		{
+			if (wilc_wlan_cfg_get(vif, 1, WID_FIRMWARE_VERSION, 1, 0)) {
+				int size;
+				char firmware_ver[WILC_MAX_FW_VERSION_STR_SIZE];
+
+				size = wilc_wlan_cfg_get_val(wl, WID_FIRMWARE_VERSION,
+							     firmware_ver,
+							     sizeof(firmware_ver));
+				firmware_ver[size] = '\0';
+				PRINT_INFO(dev, INIT_DBG, "WILC Firmware Ver = %s\n",
+					firmware_ver);
+			}
 
-		ret = wilc_init_fw_config(dev, vif);
-		if (ret) {
-			netdev_err(dev, "Failed to configure firmware\n");
-			goto fail_fw_start;
+			ret = wilc_init_fw_config(dev, vif);
+			if (ret < 0) {
+				netdev_err(dev, "Failed to configure firmware\n");
+				ret = -EIO;
+				goto fail_fw_start;
+			}
 		}
 		wl->initialized = true;
 		return 0;
@@ -544,19 +874,18 @@
 		wilc_wlan_stop(wl, vif);
 
 fail_irq_enable:
-		if (!wl->dev_irq_num &&
-		    wl->hif_func->disable_interrupt)
+		if (wl->io_type == WILC_HIF_SDIO)
 			wl->hif_func->disable_interrupt(wl);
 fail_irq_init:
-		if (wl->dev_irq_num)
-			deinit_irq(dev);
+		deinit_irq(dev);
+
 fail_threads:
 		wlan_deinitialize_threads(dev);
 fail_wilc_wlan:
 		wilc_wlan_cleanup(dev);
 		netdev_err(dev, "WLAN initialization FAILED\n");
 	} else {
-		netdev_dbg(dev, "wilc1000 already initialized\n");
+		PRINT_WRN(vif->ndev, INIT_DBG, "wilc already initialized\n");
 	}
 	return ret;
 }
@@ -582,44 +911,65 @@
 		return -ENODEV;
 	}
 
-	netdev_dbg(ndev, "MAC OPEN[%p]\n", ndev);
+	PRINT_INFO(ndev, INIT_DBG, "MAC OPEN[%p] %s\n", ndev, ndev->name);
 
-	ret = wilc_init_host_int(ndev);
-	if (ret)
-		return ret;
+	if (wl->open_ifcs == 0)
+		wilc_bt_power_up(wl, DEV_WIFI);
 
+	if (!recovery_on) {
+		ret = wilc_init_host_int(ndev);
+		if (ret < 0) {
+			PRINT_ER(ndev, "Failed to initialize host interface\n");
+			return ret;
+		}
+	}
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "*** re-init ***\n");
 	ret = wilc_wlan_initialize(ndev, vif);
 	if (ret) {
-		wilc_deinit_host_int(ndev);
+		PRINT_ER(ndev, "Failed to initialize wilc\n");
+		if (!recovery_on)
+			wilc_deinit_host_int(ndev);
 		return ret;
 	}
 
-	wilc_set_operation_mode(vif, wilc_get_vif_idx(vif), vif->iftype,
+#ifdef WILC_S02_TEST_BUS_INTERFACE
+	if (!is_test_mode)
+#endif
+	{
+		wait_for_recovery = 0;
+		wilc_set_operation_mode(vif, wilc_get_vif_idx(vif), vif->iftype,
 				vif->idx);
 
-	if (is_valid_ether_addr(ndev->dev_addr)) {
-		ether_addr_copy(addr, ndev->dev_addr);
-		wilc_set_mac_address(vif, addr);
-	} else {
-		wilc_get_mac_address(vif, addr);
-		eth_hw_addr_set(ndev, addr);
-	}
-	netdev_dbg(ndev, "Mac address: %pM\n", ndev->dev_addr);
+		if (is_valid_ether_addr(ndev->dev_addr)) {
+			ether_addr_copy(addr, ndev->dev_addr);
+			wilc_set_mac_address(vif, addr);
+		} else {
+			wilc_get_mac_address(vif, addr);
+			eth_hw_addr_set(ndev, addr);
+		}
+		netdev_dbg(ndev, "Mac address: %pM\n", ndev->dev_addr);
+		if (!is_valid_ether_addr(ndev->dev_addr)) {
+			PRINT_ER(ndev, "Mac address is not configured");
+			wilc_deinit_host_int(ndev);
+			wilc_wlan_deinitialize(ndev);
+			return -EINVAL;
+		}
 
-	if (!is_valid_ether_addr(ndev->dev_addr)) {
-		netdev_err(ndev, "Wrong MAC address\n");
-		wilc_deinit_host_int(ndev);
-		wilc_wlan_deinitialize(ndev);
-		return -EINVAL;
+		mgmt_regs.interface_stypes = vif->mgmt_reg_stypes;
+		/* so we detect a change */
+		vif->mgmt_reg_stypes = 0;
+		wilc_update_mgmt_frame_registrations(vif->ndev->ieee80211_ptr->wiphy,
+						     vif->ndev->ieee80211_ptr,
+						     &mgmt_regs);
+		netif_wake_queue(ndev);
 	}
-
-	mgmt_regs.interface_stypes = vif->mgmt_reg_stypes;
-	/* so we detect a change */
-	vif->mgmt_reg_stypes = 0;
-	wilc_update_mgmt_frame_registrations(vif->ndev->ieee80211_ptr->wiphy,
-					     vif->ndev->ieee80211_ptr,
-					     &mgmt_regs);
-	netif_wake_queue(ndev);
+#ifdef WILC_S02_TEST_BUS_INTERFACE
+	if (is_test_mode) {
+		//wilc_test_bus_interface(vif, WILC_S02_TEST_FRAME_SIZE, WILC_S02_TEST_FRAME_COUNT);
+		wilc_test_bus_interface(vif, frame_size, 1);
+	}
+#endif
 	wl->open_ifcs++;
 	vif->mac_opened = 1;
 	return 0;
@@ -642,8 +992,10 @@
 	struct wilc_vif *tmp_vif;
 	int srcu_idx;
 
-	if (!is_valid_ether_addr(addr->sa_data))
+	if (!is_valid_ether_addr(addr->sa_data)) {
+		PRINT_INFO(vif->ndev, INIT_DBG, "Invalid MAC address\n");
 		return -EADDRNOTAVAIL;
+	}
 
 	if (!vif->mac_opened) {
 		eth_commit_mac_addr_change(dev, p);
@@ -651,12 +1003,13 @@
 	}
 
 	/* Verify MAC Address is not already in use: */
-
 	srcu_idx = srcu_read_lock(&wilc->srcu);
 	list_for_each_entry_rcu(tmp_vif, &wilc->vif_list, list) {
 		wilc_get_mac_address(tmp_vif, mac_addr);
 		if (ether_addr_equal(addr->sa_data, mac_addr)) {
 			if (vif != tmp_vif) {
+				PRINT_INFO(vif->ndev, INIT_DBG,
+					   "MAC address is already in use\n");
 				srcu_read_unlock(&wilc->srcu, srcu_idx);
 				return -EADDRNOTAVAIL;
 			}
@@ -666,6 +1019,7 @@
 	}
 	srcu_read_unlock(&wilc->srcu, srcu_idx);
 
+	/* configure new MAC address */
 	result = wilc_set_mac_address(vif, (u8 *)addr->sa_data);
 	if (result)
 		return result;
@@ -682,16 +1036,30 @@
 	u8 *mc_list;
 	u8 *cur_mc;
 
-	if (dev->flags & IFF_PROMISC)
+#ifdef WILC_S02_TEST_BUS_INTERFACE
+	if (is_test_mode){
+		return;
+	}
+#endif
+	PRINT_INFO(vif->ndev, INIT_DBG,
+		   "Setting mcast List with count = %d.\n", dev->mc.count);
+	if (dev->flags & IFF_PROMISC) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Set promiscuous mode ON retrieve all pkts\n");
 		return;
+	}
 
 	if (dev->flags & IFF_ALLMULTI ||
 	    dev->mc.count > WILC_MULTICAST_TABLE_SIZE) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Disable mcast filter retrieve multicast pkts\n");
 		wilc_setup_multicast_filter(vif, 0, 0, NULL);
 		return;
 	}
 
 	if (dev->mc.count == 0) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Enable mcast filter retrieve directed pkts only\n");
 		wilc_setup_multicast_filter(vif, 1, 0, NULL);
 		return;
 	}
@@ -728,6 +1096,8 @@
 	struct tx_complete_data *tx_data = NULL;
 	int queue_count;
 
+	PRINT_INFO(vif->ndev, TX_DBG,
+		   "Sending packet just received from TCP/IP\n");
 	if (skb->dev != ndev) {
 		netdev_err(ndev, "Packet not destined to this device\n");
 		dev_kfree_skb(skb);
@@ -736,6 +1106,7 @@
 
 	tx_data = kmalloc(sizeof(*tx_data), GFP_ATOMIC);
 	if (!tx_data) {
+		PRINT_ER(ndev, "Failed to alloc memory for tx_data struct\n");
 		dev_kfree_skb(skb);
 		netif_wake_queue(ndev);
 		return NETDEV_TX_OK;
@@ -745,6 +1116,9 @@
 	tx_data->size = skb->len;
 	tx_data->skb  = skb;
 
+	PRINT_D(vif->ndev, TX_DBG, "Sending pkt Size= %d Add= %p SKB= %p\n",
+		tx_data->size, tx_data->buff, tx_data->skb);
+	PRINT_D(vif->ndev, TX_DBG, "Adding tx pkt to TX Queue\n");
 	vif->netstats.tx_packets++;
 	vif->netstats.tx_bytes += tx_data->size;
 	queue_count = wilc_wlan_txq_add_net_pkt(ndev, tx_data,
@@ -771,23 +1145,29 @@
 	struct wilc_vif *vif = netdev_priv(ndev);
 	struct wilc *wl = vif->wilc;
 
-	netdev_dbg(ndev, "Mac close\n");
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "Mac close\n");
 
-	if (wl->open_ifcs > 0)
+	if (wl->open_ifcs > 0) {
 		wl->open_ifcs--;
-	else
+	} else {
+		PRINT_ER(ndev, "MAC close called with no opened interfaces\n");
 		return 0;
+	}
+
+	if (wl->open_ifcs == 0)
+		wl->close = 1;
 
 	if (vif->ndev) {
 		netif_stop_queue(vif->ndev);
 
 		wilc_handle_disconnect(vif);
-		wilc_deinit_host_int(vif->ndev);
+
+		if (!recovery_on)
+			wilc_deinit_host_int(vif->ndev);
 	}
 
 	if (wl->open_ifcs == 0) {
-		netdev_dbg(ndev, "Deinitializing wilc1000\n");
-		wl->close = 1;
+		netdev_dbg(ndev, "Deinitializing wilc\n");
 		wilc_wlan_deinitialize(ndev);
 	}
 
@@ -796,45 +1176,70 @@
 	return 0;
 }
 
-void wilc_frmw_to_host(struct wilc *wilc, u8 *buff, u32 size,
-		       u32 pkt_offset)
+void wilc_frmw_to_host(struct wilc_vif *vif, u8 *buff, u32 size,
+		       u32 pkt_offset, u8 status)
 {
 	unsigned int frame_len = 0;
 	int stats;
 	unsigned char *buff_to_send = NULL;
 	struct sk_buff *skb;
-	struct net_device *wilc_netdev;
-	struct wilc_vif *vif;
+	struct wilc_priv *priv;
+	u8 null_bssid[ETH_ALEN] = {0};
 
-	if (!wilc)
-		return;
+	buff += pkt_offset;
+	priv = &vif->priv;
 
-	wilc_netdev = get_if_handler(wilc, buff);
-	if (!wilc_netdev)
+	if (size == 0) {
+		pr_err("Discard sending packet with len = %d\n", size);
 		return;
+	}
 
-	buff += pkt_offset;
-	vif = netdev_priv(wilc_netdev);
+	frame_len = size;
+	buff_to_send = buff;
 
-	if (size > 0) {
-		frame_len = size;
-		buff_to_send = buff;
-
-		skb = dev_alloc_skb(frame_len);
-		if (!skb)
-			return;
-
-		skb->dev = wilc_netdev;
-
-		skb_put_data(skb, buff_to_send, frame_len);
-
-		skb->protocol = eth_type_trans(skb, wilc_netdev);
-		vif->netstats.rx_packets++;
-		vif->netstats.rx_bytes += frame_len;
-		skb->ip_summed = CHECKSUM_UNNECESSARY;
-		stats = netif_rx(skb);
-		netdev_dbg(wilc_netdev, "netif_rx ret value is: %d\n", stats);
+	if (status == PKT_STATUS_NEW && buff_to_send[12] == 0x88 &&
+	    buff_to_send[13] == 0x8e &&
+	    (vif->iftype == WILC_STATION_MODE ||
+	     vif->iftype == WILC_CLIENT_MODE) &&
+	    ether_addr_equal_unaligned(priv->associated_bss, null_bssid)) {
+		if (!priv->buffered_eap) {
+			priv->buffered_eap = kmalloc(sizeof(struct
+							    wilc_buffered_eap),
+						     GFP_ATOMIC);
+			if (priv->buffered_eap) {
+				priv->buffered_eap->buff = NULL;
+				priv->buffered_eap->size = 0;
+				priv->buffered_eap->pkt_offset = 0;
+			} else {
+				pr_err("failed to alloc buffered_eap\n");
+				return;
+			}
+		} else {
+			kfree(priv->buffered_eap->buff);
+		}
+		priv->buffered_eap->buff = kmalloc(size + pkt_offset,
+						   GFP_ATOMIC);
+		priv->buffered_eap->size = size;
+		priv->buffered_eap->pkt_offset = pkt_offset;
+		memcpy(priv->buffered_eap->buff, buff -
+		       pkt_offset, size + pkt_offset);
+		mod_timer(&priv->eap_buff_timer, (jiffies +
+			  msecs_to_jiffies(10)));
+		return;
+	}
+	skb = dev_alloc_skb(frame_len);
+	if (!skb) {
+		return;
 	}
+
+	skb->dev = vif->ndev;
+	skb_put_data(skb, buff_to_send, frame_len);
+
+	skb->protocol = eth_type_trans(skb, vif->ndev);
+	vif->netstats.rx_packets++;
+	vif->netstats.rx_bytes += frame_len;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	stats = netif_rx(skb);
 }
 
 void wilc_wfi_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size, bool is_auth)
@@ -856,10 +1261,11 @@
 			break;
 		}
 
-		if (vif->priv.p2p_listen_state &&
-		    vif->mgmt_reg_stypes & type_bit)
+		if (vif->mgmt_reg_stypes & type_bit &&
+		    vif->p2p_listen_state)
 			wilc_wfi_p2p_rx(vif, buff, size);
 
+
 		if (vif->monitor_flag)
 			wilc_wfi_monitor_rx(wilc->monitor_dev, buff, size);
 	}
@@ -878,7 +1284,8 @@
 
 void wilc_netdev_cleanup(struct wilc *wilc)
 {
-	struct wilc_vif *vif, *vif_tmp;
+	struct wilc_vif *vif;
+	int srcu_idx, ifc_cnt = 0;
 
 	if (!wilc)
 		return;
@@ -888,25 +1295,44 @@
 		wilc->firmware = NULL;
 	}
 
-	list_for_each_entry_safe(vif, vif_tmp, &wilc->vif_list, list) {
-		mutex_lock(&wilc->vif_mutex);
-		list_del_rcu(&vif->list);
-		wilc->vif_num--;
-		mutex_unlock(&wilc->vif_mutex);
-		synchronize_srcu(&wilc->srcu);
+	srcu_idx = srcu_read_lock(&wilc->srcu);
+	list_for_each_entry_rcu(vif, &wilc->vif_list, list) {
 		if (vif->ndev)
 			unregister_netdev(vif->ndev);
 	}
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
 
 	wilc_wfi_deinit_mon_interface(wilc, false);
 	destroy_workqueue(wilc->hif_workqueue);
+	wilc->hif_workqueue = NULL;
+
+	while (ifc_cnt < WILC_NUM_CONCURRENT_IFC) {
+		mutex_lock(&wilc->vif_mutex);
+		if (wilc->vif_num <= 0) {
+			mutex_unlock(&wilc->vif_mutex);
+			break;
+		}
+		vif = wilc_get_wl_to_vif(wilc);
+		if (!IS_ERR(vif))
+			list_del_rcu(&vif->list);
+
+		wilc->vif_num--;
+		mutex_unlock(&wilc->vif_mutex);
+		synchronize_srcu(&wilc->srcu);
+		ifc_cnt++;
+	}
 
 	wilc_wlan_cfg_deinit(wilc);
+#ifdef WILC_DEBUGFS
+	wilc_debugfs_remove();
+#endif
+	wilc_sysfs_exit();
 	wlan_deinit_locks(wilc);
 	wiphy_unregister(wilc->wiphy);
+	pr_info("Freeing wiphy\n");
 	wiphy_free(wilc->wiphy);
+	pr_info("Module_exit Done.\n");
 }
-EXPORT_SYMBOL_GPL(wilc_netdev_cleanup);
 
 static u8 wilc_get_available_idx(struct wilc *wl)
 {
@@ -948,11 +1374,13 @@
 
 	SET_NETDEV_DEV(ndev, wiphy_dev(wl->wiphy));
 
+	vif->ndev->ml_priv = vif;
 	vif->priv.wdev.wiphy = wl->wiphy;
 	vif->priv.wdev.netdev = ndev;
 	vif->priv.wdev.iftype = type;
 	vif->priv.dev = ndev;
 
+	vif->priv.dev = ndev;
 	if (rtnl_locked)
 		ret = cfg80211_register_netdevice(ndev);
 	else
@@ -984,5 +1412,7 @@
 	return ERR_PTR(ret);
 }
 
+MODULE_DESCRIPTION("Atmel WILC1000 core wireless driver");
 MODULE_LICENSE("GPL");
 MODULE_FIRMWARE(WILC1000_FW(WILC1000_API_VER));
+MODULE_FIRMWARE(WILC3000_FW(WILC3000_API_VER));
--- linux-6.6.51/drivers/net/wireless/microchip/wilc1000/netdev.h	2024-12-05 13:07:51.230698900 +0900
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/netdev.h	2024-12-04 16:41:31.557537300 +0900
@@ -17,6 +17,9 @@
 #include "hif.h"
 #include "wlan.h"
 #include "wlan_cfg.h"
+#include "wilcs02_loopback.h"
+
+extern int wait_for_recovery;
 
 #define FLOW_CONTROL_LOWER_THRESHOLD		128
 #define FLOW_CONTROL_UPPER_THRESHOLD		256
@@ -27,6 +30,12 @@
 #define TCP_ACK_FILTER_LINK_SPEED_THRESH	54
 #define DEFAULT_LINK_SPEED			72
 
+#define TX_BACKOFF_WEIGHT_MS			1
+
+#define ANT_SWTCH_INVALID_GPIO_CTRL		0
+#define ANT_SWTCH_SNGL_GPIO_CTRL		1
+#define ANT_SWTCH_DUAL_GPIO_CTRL		2
+
 struct wilc_wfi_stats {
 	unsigned long rx_packets;
 	unsigned long tx_packets;
@@ -56,6 +65,19 @@
 	u64 listen_cookie;
 };
 
+/* Struct to buffer eapol 1/4 frame */
+struct wilc_buffered_eap {
+	unsigned int size;
+	unsigned int pkt_offset;
+	u8 *buff;
+};
+
+struct wilc_p2p_var {
+	u8 local_random;
+	u8 recv_random;
+	bool is_wilc_ie;
+};
+
 static const u32 wilc_cipher_suites[] = {
 	WLAN_CIPHER_SUITE_TKIP,
 	WLAN_CIPHER_SUITE_CCMP,
@@ -134,9 +156,12 @@
 
 	/* mutexes */
 	struct mutex scan_req_lock;
-	bool p2p_listen_state;
-	int scanned_cnt;
 
+	struct wilc_buffered_eap *buffered_eap;
+
+	struct timer_list eap_buff_timer;
+	int scanned_cnt;
+	struct wilc_p2p_var p2p;
 	u64 inc_roc_cookie;
 };
 
@@ -166,6 +191,17 @@
 	bool enabled;
 };
 
+#define WILC_P2P_ROLE_GO	1
+#define WILC_P2P_ROLE_CLIENT	0
+
+struct sysfs_attr_group {
+	bool p2p_mode;
+	u8 ant_swtch_mode;
+	u8 antenna1;
+	u8 antenna2;
+	u8 fw_dbg_level;
+};
+
 struct wilc_vif {
 	u8 idx;
 	u8 iftype;
@@ -177,17 +213,29 @@
 	u8 bssid[ETH_ALEN];
 	struct host_if_drv *hif_drv;
 	struct net_device *ndev;
-	struct timer_list during_ip_timer;
+
 	struct timer_list periodic_rssi;
 	struct rf_info periodic_stat;
 	struct tcp_ack_filter ack_filter;
 	bool connecting;
 	struct wilc_priv priv;
 	struct list_head list;
+	u8 restart;
+	bool p2p_listen_state;
 	struct cfg80211_bss *bss;
 	struct cfg80211_external_auth_params auth;
 };
 
+struct wilc_power_gpios {
+	int reset;
+	int chip_en;
+};
+
+struct wilc_power {
+	struct wilc_power_gpios gpios;
+	u8 status[DEV_MAX];
+};
+
 struct wilc_tx_queue_status {
 	u8 buffer[AC_BUFFER_SIZE];
 	u16 end_index;
@@ -204,7 +252,6 @@
 	struct clk *rtc_clk;
 	bool initialized;
 	u32 chipid;
-	bool power_save_mode;
 	int dev_irq_num;
 	int close;
 	u8 vif_num;
@@ -231,11 +278,14 @@
 	struct completion sync_event;
 	struct completion txq_event;
 	struct completion txq_thread_started;
-
+	struct completion debug_thread_started;
 	struct task_struct *txq_thread;
+	struct task_struct *debug_thread;
 
 	int quit;
 
+	bool is_mmc_spi;
+
 	/* lock to protect issue of wid command to firmware */
 	struct mutex cfg_cmd_lock;
 	struct wilc_cfg_frame cfg_frame;
@@ -256,8 +306,13 @@
 	const struct firmware *firmware;
 
 	struct device *dev;
-	bool suspend_event;
+	struct device *dt_dev;
 
+	enum wilc_chip_type chip;
+	struct wilc_vmm_ctl vmm_ctl;
+	struct wilc_power power;
+	uint8_t keep_awake[DEV_MAX];
+	struct mutex cs;
 	struct workqueue_struct *hif_workqueue;
 	struct wilc_cfg cfg;
 	void *bus_data;
@@ -267,6 +322,7 @@
 	struct mutex deinit_lock;
 	u8 sta_ch;
 	u8 op_ch;
+	struct sysfs_attr_group attr_sysfs;
 	struct ieee80211_channel channels[ARRAY_SIZE(wilc_2ghz_channels)];
 	struct ieee80211_rate bitrates[ARRAY_SIZE(wilc_bitrates)];
 	struct ieee80211_supported_band band;
@@ -277,7 +333,12 @@
 	struct net_device *real_ndev;
 };
 
-void wilc_frmw_to_host(struct wilc *wilc, u8 *buff, u32 size, u32 pkt_offset);
+#ifdef WILC_S02_TEST_BUS_INTERFACE
+extern bool is_test_mode;
+#endif
+
+void wilc_frmw_to_host(struct wilc_vif *vif, u8 *buff, u32 size,
+		       u32 pkt_offset, u8 status);
 void wilc_mac_indicate(struct wilc *wilc);
 void wilc_netdev_cleanup(struct wilc *wilc);
 void wilc_wfi_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size, bool is_auth);
@@ -286,4 +347,8 @@
 struct wilc_vif *wilc_netdev_ifc_init(struct wilc *wl, const char *name,
 				      int vif_type, enum nl80211_iftype type,
 				      bool rtnl_locked);
+int wilc_bt_power_up(struct wilc *wilc, int source);
+int wilc_bt_power_down(struct wilc *wilc, int source);
+int wilc_s02_reset_firmware(struct wilc *wilc, u32 type);
+int wilc_s02_check_firmware_download(struct wilc *wl);
 #endif
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/power.c	2024-12-04 16:41:31.557537300 +0900
@@ -0,0 +1,80 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2023 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/version.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+
+#include "netdev.h"
+
+/**
+ * wilc_of_parse_power_pins() - parse power sequence pins; to keep backward
+ *		compatibility with old device trees that doesn't provide
+ *		power sequence pins we check for default pins on proper boards
+ *
+ * @wilc:	wilc data structure
+ *
+ * Returns:	 0 on success, negative error number on failures.
+ */
+int wilc_of_parse_power_pins(struct wilc *wilc)
+{
+	static const struct wilc_power_gpios default_gpios[] = {
+		{ .reset = GPIO_NUM_RESET,	.chip_en = GPIO_NUM_CHIP_EN, },
+	};
+	struct device_node *of = wilc->dt_dev->of_node;
+	struct wilc_power *power = &wilc->power;
+	const struct wilc_power_gpios *gpios = &default_gpios[0];
+	int ret;
+
+	power->gpios.reset = of_get_named_gpio(of, "reset-gpios", 0);
+	if (!gpio_is_valid(power->gpios.reset))
+		power->gpios.reset = gpios->reset;
+
+	power->gpios.chip_en = of_get_named_gpio(of, "chip_en-gpios", 0);
+	if (!gpio_is_valid(power->gpios.chip_en))
+		power->gpios.chip_en = gpios->chip_en;
+
+	if (!gpio_is_valid(power->gpios.chip_en) ||
+			!gpio_is_valid(power->gpios.reset))
+		return -EINVAL;
+
+	ret = devm_gpio_request(wilc->dev, power->gpios.chip_en, "CHIP_EN");
+	if (ret)
+		return ret;
+
+	ret = devm_gpio_request(wilc->dev, power->gpios.reset, "RESET");
+	return ret;
+}
+
+/**
+ * wilc_wlan_power() - handle power on/off commands
+ *
+ * @wilc:	wilc data structure
+ * @on:		requested power status
+ *
+ * Returns:	none
+ */
+void wilc_wlan_power(struct wilc *wilc, bool on)
+{
+	if (!gpio_is_valid(wilc->power.gpios.chip_en) ||
+	    !gpio_is_valid(wilc->power.gpios.reset)) {
+		/* In case SDIO power sequence driver is used to power this
+		 * device then the powering sequence is handled by the bus
+		 * via pm_runtime_* functions. */
+		return;
+	}
+
+	if (on) {
+		gpio_direction_output(wilc->power.gpios.chip_en, 1);
+		mdelay(5);
+		gpio_direction_output(wilc->power.gpios.reset, 1);
+	} else {
+		gpio_direction_output(wilc->power.gpios.chip_en, 0);
+		gpio_direction_output(wilc->power.gpios.reset, 0);
+	}
+}
--- linux-6.6.51/drivers/net/wireless/microchip/wilc1000/sdio.c	2024-12-05 13:07:51.231696300 +0900
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/sdio.c	2024-12-04 16:41:31.558534500 +0900
@@ -8,13 +8,23 @@
 #include <linux/mmc/sdio_func.h>
 #include <linux/mmc/sdio_ids.h>
 #include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/pm_runtime.h>
 #include <linux/mmc/sdio.h>
 #include <linux/of_irq.h>
 
 #include "netdev.h"
 #include "cfg80211.h"
 
-#define SDIO_MODALIAS "wilc1000_sdio"
+enum sdio_host_lock {
+	WILC_SDIO_HOST_NO_TAKEN = 0,
+	WILC_SDIO_HOST_IRQ_TAKEN = 1,
+	WILC_SDIO_HOST_DIS_TAKEN = 2,
+};
+
+static enum sdio_host_lock	sdio_intr_lock = WILC_SDIO_HOST_NO_TAKEN;
+static wait_queue_head_t sdio_intr_waitqueue;
+#define SDIO_MODALIAS "wilc_sdio"
 
 static const struct sdio_device_id wilc_sdio_ids[] = {
 	{ SDIO_DEVICE(SDIO_VENDOR_ID_MICROCHIP_WILC, SDIO_DEVICE_ID_MICROCHIP_WILC1000) },
@@ -22,13 +32,16 @@
 };
 MODULE_DEVICE_TABLE(sdio, wilc_sdio_ids);
 
-#define WILC_SDIO_BLOCK_SIZE 512
+#define WILC_SDIO_BLOCK_SIZE		512
+#define WILC_MMC_SPI_BLOCK_SIZE		256
 
 struct wilc_sdio {
 	bool irq_gpio;
 	u32 block_size;
 	bool isinit;
+	struct wilc *wl;
 	u8 *cmd53_buf;
+	bool is_mmc_spi;
 };
 
 struct sdio_cmd52 {
@@ -55,9 +68,14 @@
 
 static void wilc_sdio_interrupt(struct sdio_func *func)
 {
+	if (sdio_intr_lock == WILC_SDIO_HOST_DIS_TAKEN)
+		return;
+	sdio_intr_lock = WILC_SDIO_HOST_IRQ_TAKEN;
 	sdio_release_host(func);
 	wilc_handle_isr(sdio_get_drvdata(func));
 	sdio_claim_host(func);
+	sdio_intr_lock = WILC_SDIO_HOST_NO_TAKEN;
+	wake_up_interruptible(&sdio_intr_waitqueue);
 }
 
 static int wilc_sdio_cmd52(struct wilc *wilc, struct sdio_cmd52 *cmd)
@@ -106,9 +124,10 @@
 		size = cmd->count;
 
 	if (cmd->use_global_buf) {
-		if (size > sizeof(u32))
-			return -EINVAL;
-
+		if (size > sizeof(u32)) {
+			ret = -EINVAL;
+			goto out;
+		}
 		buf = sdio_priv->cmd53_buf;
 	}
 
@@ -116,18 +135,27 @@
 		if (cmd->use_global_buf)
 			memcpy(buf, cmd->buffer, size);
 
-		ret = sdio_memcpy_toio(func, cmd->address, buf, size);
+		if (cmd->increment)
+			ret = sdio_memcpy_toio(func, cmd->address, buf, size);
+		else
+			ret = sdio_writesb(func, cmd->address, buf, size);
 	} else {        /* read */
-		ret = sdio_memcpy_fromio(func, buf, cmd->address, size);
+		if (cmd->increment)
+			ret = sdio_memcpy_fromio(func, buf,
+						 cmd->address,  size);
+		else
+			ret = sdio_readsb(func,  buf, cmd->address, size);
 
 		if (cmd->use_global_buf)
 			memcpy(cmd->buffer, buf, size);
 	}
-
+out:
 	sdio_release_host(func);
 
 	if (ret)
-		dev_err(&func->dev, "%s..failed, err(%d)\n", __func__,  ret);
+		dev_err(&func->dev, "%s..%s failed, err(%d) %d %d\n", __func__,
+			cmd->read_write == 1 ? "write":"read",
+			ret, size, cmd->increment);
 
 	return ret;
 }
@@ -136,8 +164,11 @@
 			   const struct sdio_device_id *id)
 {
 	struct wilc *wilc;
-	int ret;
+	int ret, io_type;
+	static bool init_power;
 	struct wilc_sdio *sdio_priv;
+	struct device_node *np;
+	int irq_num;
 
 	sdio_priv = kzalloc(sizeof(*sdio_priv), GFP_KERNEL);
 	if (!sdio_priv)
@@ -149,24 +180,49 @@
 		goto free;
 	}
 
-	ret = wilc_cfg80211_init(&wilc, &func->dev, WILC_HIF_SDIO,
-				 &wilc_hif_sdio);
-	if (ret)
-		goto free;
-
-	if (IS_ENABLED(CONFIG_WILC1000_HW_OOB_INTR)) {
-		struct device_node *np = func->card->dev.of_node;
-		int irq_num = of_irq_get(np, 0);
+	sdio_priv->is_mmc_spi = func->card->host->caps & MMC_CAP_SPI;
 
-		if (irq_num > 0) {
-			wilc->dev_irq_num = irq_num;
-			sdio_priv->irq_gpio = true;
-		}
+	if (IS_ENABLED(CONFIG_WILC_HW_OOB_INTR) || func->card->host->caps &
+	    MMC_CAP_SPI) {
+		io_type = WILC_HIF_SDIO_GPIO_IRQ;
 	}
+	else
+		io_type = WILC_HIF_SDIO;
 
+	ret = wilc_cfg80211_init(&wilc, &func->dev, io_type, &wilc_hif_sdio);
+	if (ret) {
+		dev_err(&func->dev, "Couldn't initialize netdev\n");
+		goto free;
+	}
 	sdio_set_drvdata(func, wilc);
 	wilc->bus_data = sdio_priv;
 	wilc->dev = &func->dev;
+	wilc->dt_dev = &func->card->dev;
+	sdio_priv->wl = wilc;
+
+	if (sdio_priv->is_mmc_spi) {
+		struct device *dev = func->card->host->parent;
+		struct gpio_desc *gpio_interrupt;
+		wilc->dt_dev = dev;
+
+		/* mmc-spi holds the default irq for card detect, so use another GPIO for SPI interrupt */
+		gpio_interrupt = devm_gpiod_get(dev, "intr", GPIOD_IN);
+		if (IS_ERR(gpio_interrupt)) {
+			goto free;
+		} else {
+			wilc->dev_irq_num = gpiod_to_irq(gpio_interrupt);
+			pr_info("got gpio_irq successfully %d\r\n", wilc->dev_irq_num);
+			if (wilc->dev_irq_num < 0) {
+				dev_warn(wilc->dev, "could not the IRQ %d\n", wilc->dev_irq_num);
+				gpiod_put(gpio_interrupt);
+				goto free;
+			}
+		}
+	} else {
+		irq_num = of_irq_get(func->card->dev.of_node, 0);
+		if (irq_num > 0)
+			wilc->dev_irq_num = irq_num;
+	}
 
 	wilc->rtc_clk = devm_clk_get_optional(&func->card->dev, "rtc");
 	if (IS_ERR(wilc->rtc_clk)) {
@@ -175,9 +231,59 @@
 	}
 	clk_prepare_enable(wilc->rtc_clk);
 
+	/*
+	 * Some WILC SDIO setups needs a SD power sequence driver to be able
+	 * to power the WILC devices before reaching this function. For those
+	 * devices the power sequence driver already provides reset-gpios
+	 * and chip_en-gpios.
+	 */
+	np = of_parse_phandle(func->card->host->parent->of_node, "mmc-pwrseq",
+			      0);
+	if ((np && of_device_is_available(np)) || sdio_priv->is_mmc_spi) {
+		init_power = 1;
+		of_node_put(np);
+	} else {
+		ret = wilc_of_parse_power_pins(wilc);
+		if (ret)
+			goto disable_rtc_clk;
+	}
+
+
+	if (!init_power) {
+		wilc_wlan_power(wilc, false);
+		init_power = 1;
+		wilc_wlan_power(wilc, true);
+	}
+
+	wilc->is_mmc_spi = sdio_priv->is_mmc_spi;
+	if (!wilc->hif_func->hif_is_init(wilc)) {
+		if (wilc->hif_func->hif_init(wilc, false)) {
+			ret = -EIO;
+			goto disable_rtc_clk;
+		}
+	}
+
+	if (wilc->chip == WILC_S02) {
+		ret = wilc_s02_reset_firmware(wilc,
+					     WILC_S02_SOFT_RESET | (WILC_S02_WLAN_RESET << 8));
+		if (ret < 0) {
+			pr_err("Failed to start firmware\n");
+			ret = -EIO;
+			goto disable_rtc_clk;
+		}
+		ret = wilc_s02_check_firmware_download(wilc);
+		if (ret)
+			goto disable_rtc_clk;
+
+	}
+	wilc_bt_init(wilc);
+
 	dev_info(&func->dev, "Driver Initializing success\n");
 	return 0;
 
+disable_rtc_clk:
+	if (!IS_ERR(wilc->rtc_clk))
+		clk_disable_unprepare(wilc->rtc_clk);
 dispose_irq:
 	irq_dispose_mapping(wilc->dev_irq_num);
 	wilc_netdev_cleanup(wilc);
@@ -192,10 +298,14 @@
 	struct wilc *wilc = sdio_get_drvdata(func);
 	struct wilc_sdio *sdio_priv = wilc->bus_data;
 
+	wilc->mac_status = WILC_MAC_STATUS_PRE_INIT;
+	complete(&wilc->sync_event);
+
 	clk_disable_unprepare(wilc->rtc_clk);
 	wilc_netdev_cleanup(wilc);
 	kfree(sdio_priv->cmd53_buf);
 	kfree(sdio_priv);
+	wilc_bt_deinit();
 }
 
 static int wilc_sdio_reset(struct wilc *wilc)
@@ -204,6 +314,8 @@
 	int ret;
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 
+	dev_info(&func->dev, "De Init SDIO\n");
+
 	cmd.read_write = 1;
 	cmd.function = 0;
 	cmd.raw = 0;
@@ -224,29 +336,35 @@
 	return sdio_priv->isinit;
 }
 
+static int wilc_sdio_clear_init(struct wilc *wilc)
+{
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
+
+	sdio_priv->isinit = false;
+
+	return 0;
+}
+
 static int wilc_sdio_suspend(struct device *dev)
 {
 	struct sdio_func *func = dev_to_sdio_func(dev);
 	struct wilc *wilc = sdio_get_drvdata(func);
 	int ret;
 
-	dev_info(dev, "sdio suspend\n");
-	chip_wakeup(wilc);
+	dev_info(&func->dev, "sdio suspend\n");
+	mutex_lock(&wilc->hif_cs);
 
-	if (!IS_ERR(wilc->rtc_clk))
-		clk_disable_unprepare(wilc->rtc_clk);
+	chip_wakeup(wilc, DEV_WIFI);
 
-	if (wilc->suspend_event) {
-		host_sleep_notify(wilc);
-		chip_allow_sleep(wilc);
-	}
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	host_sleep_notify(wilc, DEV_WIFI);
+	chip_allow_sleep(wilc, DEV_WIFI);
+
+	mutex_lock(&wilc->hif_cs);
 
 	ret = wilc_sdio_reset(wilc);
-	if (ret) {
-		dev_err(&func->dev, "Fail reset sdio\n");
-		return ret;
-	}
-	sdio_claim_host(func);
 
 	return 0;
 }
@@ -256,6 +374,11 @@
 	struct sdio_func *func = container_of(dev->dev, struct sdio_func, dev);
 	int ret = 0;
 
+	sdio_intr_lock  = WILC_SDIO_HOST_NO_TAKEN;
+
+	if(dev->chip == WILC_S02)
+	    dev->hif_func->hif_clear_int_ext(dev, DATA_INT_CLR | ENABLE_RX_VMM);
+
 	sdio_claim_host(func);
 	ret = sdio_claim_irq(func, wilc_sdio_interrupt);
 	sdio_release_host(func);
@@ -272,11 +395,19 @@
 	struct sdio_func *func = container_of(dev->dev, struct sdio_func, dev);
 	int ret;
 
+	dev_info(&func->dev, "%s\n", __func__);
+
+	if (sdio_intr_lock  == WILC_SDIO_HOST_IRQ_TAKEN)
+		wait_event_interruptible(sdio_intr_waitqueue,
+					 sdio_intr_lock == WILC_SDIO_HOST_NO_TAKEN);
+	sdio_intr_lock  = WILC_SDIO_HOST_DIS_TAKEN;
+
 	sdio_claim_host(func);
 	ret = sdio_release_irq(func);
 	if (ret < 0)
 		dev_err(&func->dev, "can't release sdio_irq, err(%d)\n", ret);
 	sdio_release_host(func);
+	sdio_intr_lock  = WILC_SDIO_HOST_NO_TAKEN;
 }
 
 /********************************************
@@ -382,7 +513,7 @@
 		ret = wilc_sdio_cmd52(wilc, &cmd);
 		if (ret)
 			dev_err(&func->dev,
-				"Failed cmd 52, read reg (%08x) ...\n", addr);
+				"Failed cmd 52, write reg (%08x) ...\n", addr);
 	} else {
 		struct sdio_cmd53 cmd;
 
@@ -394,8 +525,13 @@
 			return ret;
 
 		cmd.read_write = 1;
-		cmd.function = 0;
-		cmd.address = WILC_SDIO_FBR_DATA_REG;
+		if (wilc->chip == WILC_S02) {
+			cmd.function = 1;
+			cmd.address = addr;
+		} else {
+			cmd.function = 0;
+			cmd.address = WILC_SDIO_FBR_DATA_REG;
+		}
 		cmd.block_mode = 0;
 		cmd.increment = 1;
 		cmd.count = sizeof(u32);
@@ -419,6 +555,11 @@
 	struct sdio_cmd53 cmd;
 	int nblk, nleft, ret;
 
+	if (wilc->chip == WILC_S02)
+		cmd.increment = 0;
+	else
+		cmd.increment = 1;
+
 	cmd.read_write = 1;
 	if (addr > 0) {
 		/**
@@ -441,11 +582,12 @@
 	cmd.use_global_buf = false;
 	if (nblk > 0) {
 		cmd.block_mode = 1;
-		cmd.increment = 1;
 		cmd.count = nblk;
 		cmd.buffer = buf;
 		cmd.block_size = block_size;
-		if (addr > 0) {
+		if (addr > 0)
+		{
+
 			ret = wilc_sdio_set_func0_csa_address(wilc, addr);
 			if (ret)
 				return ret;
@@ -453,9 +595,14 @@
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
-				"Failed cmd53 [%x], block send...\n", addr);
+				"Failed cmd53 [%x], block send...%d nblk %d\n", addr, block_size, nblk);
 			return ret;
 		}
+		if (wilc->chip == WILC_S02)
+			wilc->hif_func->hif_write_reg(wilc,
+						      wilc->vmm_ctl.host_vmm_tx_ctl,
+						      SDIO_MSG_VMM_INT_CLR);
+
 		if (addr > 0)
 			addr += nblk * block_size;
 		buf += nblk * block_size;
@@ -463,7 +610,6 @@
 
 	if (nleft > 0) {
 		cmd.block_mode = 0;
-		cmd.increment = 1;
 		cmd.count = nleft;
 		cmd.buffer = buf;
 
@@ -480,17 +626,96 @@
 				"Failed cmd53 [%x], bytes send...\n", addr);
 			return ret;
 		}
+		if (wilc->chip == WILC_S02)
+			wilc->hif_func->hif_write_reg(wilc,
+						      wilc->vmm_ctl.host_vmm_tx_ctl,
+						      SDIO_MSG_VMM_INT_CLR);
 	}
 
 	return 0;
 }
 
+static int wilc_read_chip_id(struct wilc *wilc, u32 addr, u32 *data)
+{
+	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
+	struct sdio_cmd53 cmd;
+	int ret;
+
+	ret = wilc_sdio_set_func0_csa_address(wilc, addr);
+	if (ret)
+		return ret;
+
+	cmd.read_write = 0;
+	cmd.function = 0;
+	cmd.address = WILC_SDIO_FBR_DATA_REG;
+
+	cmd.block_mode = 0;
+	cmd.increment = 1;
+	cmd.count = sizeof(u32);
+	cmd.buffer = (u8 *)data;
+	cmd.use_global_buf = true;
+
+	cmd.block_size = sdio_priv->block_size;
+	ret = wilc_sdio_cmd53(wilc, &cmd);
+	if (ret) {
+		dev_err(&func->dev,
+			"Failed cmd53, read reg (%08x)...\n", addr);
+		return ret;
+	}
+	le32_to_cpus(data);
+	return 0;
+
+}
+
+static int wilc_read_wilcs02_chip_id(struct wilc *wilc, u32 addr, u32 *data)
+{
+	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
+	struct sdio_cmd53 cmd;
+	int ret;
+
+	ret = wilc_sdio_set_func0_csa_address(wilc, addr);
+	if (ret)
+		return ret;
+
+	cmd.read_write = 0;
+	cmd.function = 0;
+	cmd.address = 0x10f;
+	cmd.block_mode = 0;
+	cmd.increment = 0;
+
+	cmd.count = sizeof(u32);
+	cmd.buffer = (u8 *)data;
+	cmd.use_global_buf = true;
+
+	cmd.block_size = sdio_priv->block_size;
+	ret = wilc_sdio_cmd53(wilc, &cmd);
+	if (ret) {
+		dev_err(&func->dev,
+			"Failed cmd53, read reg (%08x)...\n", addr);
+		return ret;
+	}
+	le32_to_cpus(data);
+	return 0;
+
+}
+
 static int wilc_sdio_read_reg(struct wilc *wilc, u32 addr, u32 *data)
 {
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 	struct wilc_sdio *sdio_priv = wilc->bus_data;
 	int ret;
 
+	/* read chip id first */
+	if (addr == WILC_S02_CHIP_ID) {
+		ret = wilc_read_wilcs02_chip_id(wilc, addr, data);
+		return ret;
+	} else if (addr == WILC3000_CHIP_ID || addr == WILC_CHIPID) {
+		ret = wilc_read_chip_id(wilc, addr, data);
+		return ret;
+	}
+
 	if (addr >= 0xf0 && addr <= 0xff) { /* only vendor specific registers */
 		struct sdio_cmd52 cmd;
 
@@ -508,25 +733,55 @@
 	} else {
 		struct sdio_cmd53 cmd;
 
-		ret = wilc_sdio_set_func0_csa_address(wilc, addr);
-		if (ret)
-			return ret;
+		if (wilc->chip == WILC_S02) {
+			cmd.read_write = 0;
+			if (addr >= 0x01 && addr <= 0x0f) {
+				cmd.function = 0;
+				cmd.address = 0x10f;
+				cmd.increment = 0;
+				ret = wilc_sdio_set_func0_csa_address(wilc, addr);
+				if (ret)
+					return ret;
+
+			} else {
+				cmd.function = 1;
+				cmd.address = addr;
+				cmd.increment = 1;
+			}
+			cmd.block_mode = 0;
 
-		cmd.read_write = 0;
-		cmd.function = 0;
-		cmd.address = WILC_SDIO_FBR_DATA_REG;
-		cmd.block_mode = 0;
-		cmd.increment = 1;
-		cmd.count = sizeof(u32);
-		cmd.buffer = (u8 *)data;
-		cmd.use_global_buf = true;
+			cmd.count = sizeof(u32);
+			cmd.buffer = (u8 *)data;
+			cmd.use_global_buf = true;
 
-		cmd.block_size = sdio_priv->block_size;
-		ret = wilc_sdio_cmd53(wilc, &cmd);
-		if (ret) {
-			dev_err(&func->dev,
+			cmd.block_size = sdio_priv->block_size;
+			ret = wilc_sdio_cmd53(wilc, &cmd);
+			if (ret) {
+				dev_err(&func->dev,
+					"Failed cmd53, read reg (%08x)...\n", addr);
+				return ret;
+			}
+		} else {
+			ret = wilc_sdio_set_func0_csa_address(wilc, addr);
+			if (ret)
+				return ret;
+
+			cmd.read_write = 0;
+			cmd.function = 0;
+			cmd.address = WILC_SDIO_FBR_DATA_REG;
+			cmd.block_mode = 0;
+			cmd.increment = 1;
+			cmd.count = sizeof(u32);
+			cmd.buffer = (u8 *)data;
+			cmd.use_global_buf = true;
+
+			cmd.block_size = sdio_priv->block_size;
+			ret = wilc_sdio_cmd53(wilc, &cmd);
+			if (ret) {
+				dev_err(&func->dev,
 				"Failed cmd53, read reg (%08x)...\n", addr);
-			return ret;
+				return ret;
+			}
 		}
 	}
 
@@ -562,9 +817,14 @@
 	nleft = size % block_size;
 
 	cmd.use_global_buf = false;
+
+	if (wilc->chip == WILC_S02)
+		cmd.increment = 0;
+	else
+		cmd.increment = 1;
+
 	if (nblk > 0) {
 		cmd.block_mode = 1;
-		cmd.increment = 1;
 		cmd.count = nblk;
 		cmd.buffer = buf;
 		cmd.block_size = block_size;
@@ -579,6 +839,10 @@
 				"Failed cmd53 [%x], block read...\n", addr);
 			return ret;
 		}
+		if (wilc->chip == WILC_S02)
+			wilc->hif_func->hif_write_reg(wilc,
+						      wilc->vmm_ctl.host_vmm_tx_ctl,
+						      SDIO_MSG_VMM_INT_CLR);
 		if (addr > 0)
 			addr += nblk * block_size;
 		buf += nblk * block_size;
@@ -586,7 +850,6 @@
 
 	if (nleft > 0) {
 		cmd.block_mode = 0;
-		cmd.increment = 1;
 		cmd.count = nleft;
 		cmd.buffer = buf;
 
@@ -603,6 +866,11 @@
 				"Failed cmd53 [%x], bytes read...\n", addr);
 			return ret;
 		}
+		if (wilc->chip == WILC_S02)
+			wilc->hif_func->hif_write_reg(wilc,
+						      wilc->vmm_ctl.host_vmm_tx_ctl,
+						      SDIO_MSG_VMM_INT_CLR);
+
 	}
 
 	return 0;
@@ -616,9 +884,14 @@
 
 static int wilc_sdio_deinit(struct wilc *wilc)
 {
+	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 	struct wilc_sdio *sdio_priv = wilc->bus_data;
 
 	sdio_priv->isinit = false;
+
+	pm_runtime_put_sync_autosuspend(mmc_dev(func->card->host));
+	wilc_wlan_power(wilc, false);
+
 	return 0;
 }
 
@@ -629,6 +902,25 @@
 	struct sdio_cmd52 cmd;
 	int loop, ret;
 	u32 chipid;
+	bool test_mode = false;
+
+#ifdef WILC_S02_TEST_BUS_INTERFACE
+	test_mode = is_test_mode;
+#endif
+	dev_info(&func->dev, "SDIO single driver speed: %d %s\n",
+		 func->card->host->ios.clock, test_mode? "loopback mode": "");
+
+	if (!sdio_priv->is_mmc_spi) {
+		/* Patch for sdio interrupt latency issue */
+		ret = pm_runtime_get_sync(mmc_dev(func->card->host));
+		if (ret < 0) {
+			pm_runtime_put_noidle(mmc_dev(func->card->host));
+			return ret;
+		}
+	}
+
+	init_waitqueue_head(&sdio_intr_waitqueue);
+	sdio_priv->irq_gpio = (wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ);
 
 	/**
 	 *      function 0 csa enable
@@ -641,18 +933,22 @@
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Fail cmd 52, enable csa...\n");
-		return ret;
+		goto pm_runtime_put;
 	}
 
+	if (sdio_priv->is_mmc_spi)
+		sdio_priv->block_size = WILC_MMC_SPI_BLOCK_SIZE;
+	else
+		sdio_priv->block_size = WILC_SDIO_BLOCK_SIZE;
+
 	/**
 	 *      function 0 block size
 	 **/
-	ret = wilc_sdio_set_block_size(wilc, 0, WILC_SDIO_BLOCK_SIZE);
+	ret = wilc_sdio_set_block_size(wilc, 0, sdio_priv->block_size);
 	if (ret) {
 		dev_err(&func->dev, "Fail cmd 52, set func 0 block size...\n");
-		return ret;
+		goto pm_runtime_put;
 	}
-	sdio_priv->block_size = WILC_SDIO_BLOCK_SIZE;
 
 	/**
 	 *      enable func1 IO
@@ -666,7 +962,7 @@
 	if (ret) {
 		dev_err(&func->dev,
 			"Fail cmd 52, set IOE register...\n");
-		return ret;
+		goto pm_runtime_put;
 	}
 
 	/**
@@ -683,7 +979,7 @@
 		if (ret) {
 			dev_err(&func->dev,
 				"Fail cmd 52, get IOR register...\n");
-			return ret;
+			goto pm_runtime_put;
 		}
 		if (cmd.data == WILC_SDIO_CCCR_IO_EN_FUNC1)
 			break;
@@ -691,16 +987,29 @@
 
 	if (loop <= 0) {
 		dev_err(&func->dev, "Fail func 1 is not ready...\n");
-		return -EINVAL;
+		goto pm_runtime_put;
 	}
 
 	/**
 	 *      func 1 is ready, set func 1 block size
 	 **/
-	ret = wilc_sdio_set_block_size(wilc, 1, WILC_SDIO_BLOCK_SIZE);
+	ret = wilc_sdio_set_block_size(wilc, 1, sdio_priv->block_size);
 	if (ret) {
 		dev_err(&func->dev, "Fail set func 1 block size...\n");
-		return ret;
+		goto pm_runtime_put;
+	}
+
+	cmd.read_write = 1;
+	cmd.function = 0;
+	cmd.raw = 0;
+	cmd.address = 0x7;
+	cmd.data = 0xA2;
+	ret = wilc_sdio_cmd52(wilc, &cmd);
+	if (ret) {
+		dev_err(&func->dev,
+			"Fail cmd 52, set Bus width register ...[%x]\n",
+			cmd.address);
+		return 0;
 	}
 
 	/**
@@ -714,22 +1023,95 @@
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Fail cmd 52, set IEN register...\n");
-		return ret;
+		goto pm_runtime_put;
+	}
+
+	cmd.read_write = 1;
+	cmd.function = 0;
+	cmd.raw = 0;
+	cmd.address = 0x18000;
+	cmd.data = 0x1;
+	ret = wilc_sdio_cmd52(wilc, &cmd);
+	if (ret) {
+		dev_err(&func->dev,
+			"Fail cmd 52, set wakeup register [%x]\n",  cmd.address);
+		return 0;
+	}
+
+	/**
+	 *	Review: BIG ENDIAN
+	 **/
+	cmd.read_write = 1;
+	cmd.function = 1;
+	cmd.raw = 0;
+	cmd.address = 0x9;
+	cmd.data = 0x1;
+	ret = wilc_sdio_cmd52(wilc, &cmd);
+	if (ret) {
+		dev_err(&func->dev, "Fail cmd 52, set Interrupt register...\n");
+		return 0;
 	}
 
 	/**
 	 *      make sure can read back chip id correctly
 	 **/
 	if (!resume) {
-		ret = wilc_sdio_read_reg(wilc, WILC_CHIPID, &chipid);
-		if (ret) {
-			dev_err(&func->dev, "Fail cmd read chip id...\n");
-			return ret;
+		chipid = wilc_get_chipid(wilc, true);
+		if (is_wilcs02_chip(chipid)) {
+			wilc->chip = WILC_S02;
+			func->card->quirks |= MMC_QUIRK_BROKEN_BYTE_MODE_512;
+			wilcs02_init_vmm_registers(wilc);
+		} else if (is_wilc3000(chipid)) {
+			wilc->chip = WILC_3000;
+		} else if (is_wilc1000(chipid)) {
+			wilc->chip = WILC_1000;
+		} else {
+			ret = -EINVAL;
+			dev_err(&func->dev, "Unsupported chipid: %x\n", chipid);
+			goto pm_runtime_put;
 		}
-		dev_err(&func->dev, "chipid (%08x)\n", chipid);
+		dev_info(&func->dev, "chipid %08x\n", chipid);
 	}
 
 	sdio_priv->isinit = true;
+
+	return 0;
+
+pm_runtime_put:
+	if (!sdio_priv->is_mmc_spi)
+		pm_runtime_put_sync_autosuspend(mmc_dev(func->card->host));
+	return ret;
+}
+
+static int wilc_s02_sdio_read_size(struct wilc *wilc, u32 *size)
+{
+	u32 tmp = 0;
+	int ret;
+
+	if (!wilc->is_mmc_spi) {
+		struct sdio_cmd52 cmd;
+
+		/**
+		 *      Read DMA count in words
+		 **/
+		cmd.read_write = 0;
+		cmd.function = 1;
+		cmd.raw = 0;
+		cmd.address = 0x0c;
+		cmd.data = 0x0;
+		wilc_sdio_cmd52(wilc, &cmd);
+		tmp = cmd.data;
+
+		cmd.address = 0x0d;
+		cmd.data = 0x0;
+		wilc_sdio_cmd52(wilc, &cmd);
+		tmp |= (cmd.data << 8);
+	} else {
+		ret = wilc->hif_func->hif_read_reg(wilc, 0x07, &tmp);
+		if (ret)
+			tmp = 0;
+	}
+	*size = tmp;
 	return 0;
 }
 
@@ -738,6 +1120,12 @@
 	u32 tmp;
 	struct sdio_cmd52 cmd;
 
+	if (wilc->chip == WILC_S02)
+	{
+		wilc_s02_sdio_read_size(wilc, size);
+		return 0;
+	}
+
 	/**
 	 *      Read DMA count in words
 	 **/
@@ -745,12 +1133,10 @@
 	cmd.function = 0;
 	cmd.raw = 0;
 	cmd.address = WILC_SDIO_INTERRUPT_DATA_SZ_REG;
-	cmd.data = 0;
 	wilc_sdio_cmd52(wilc, &cmd);
 	tmp = cmd.data;
 
 	cmd.address = WILC_SDIO_INTERRUPT_DATA_SZ_REG + 1;
-	cmd.data = 0;
 	wilc_sdio_cmd52(wilc, &cmd);
 	tmp |= (cmd.data << 8);
 
@@ -763,33 +1149,55 @@
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 	struct wilc_sdio *sdio_priv = wilc->bus_data;
 	u32 tmp;
-	u8 irq_flags;
 	struct sdio_cmd52 cmd;
+	u32 irq_flags;
 
-	wilc_sdio_read_size(wilc, &tmp);
+	if (sdio_priv->irq_gpio) {
+		wilc_sdio_read_size(wilc, &tmp);
+		if (wilc->chip == WILC_S02) {
+			*int_status = tmp;
+			return 0;
+		}
+		cmd.read_write = 0;
+		cmd.function = 0;
+		cmd.raw = 0;
+		cmd.data = 0;
+		if (wilc->chip == WILC_1000) {
+			cmd.address = WILC1000_SDIO_IRQ_FLAG_REG;
+			wilc_sdio_cmd52(wilc, &cmd);
+			irq_flags = cmd.data & 0x1f;
+		} else {
+			cmd.address = WILC3000_SDIO_IRQ_FLAG_REG;
+			wilc_sdio_cmd52(wilc, &cmd);
+			irq_flags = cmd.data & 0x0f;
+		}
+		tmp |= FIELD_PREP(IRG_FLAGS_MASK, cmd.data);
 
-	/**
-	 *      Read IRQ flags
-	 **/
-	if (!sdio_priv->irq_gpio) {
-		cmd.function = 1;
-		cmd.address = WILC_SDIO_EXT_IRQ_FLAG_REG;
+		*int_status = tmp;
 	} else {
-		cmd.function = 0;
-		cmd.address = WILC_SDIO_IRQ_FLAG_REG;
+		wilc_sdio_read_size(wilc, &tmp);
+		cmd.read_write = 0;
+		cmd.function = 1;
+		if (wilc->chip == WILC_S02) {
+			cmd.raw = 0;
+			cmd.address = 0x08;
+			cmd.data = 0x0;
+			wilc_sdio_cmd52(wilc, &cmd);
+		} else {
+			cmd.address = WILC_SDIO_EXT_IRQ_FLAG_REG;
+			cmd.data = 0;
+			wilc_sdio_cmd52(wilc, &cmd);
+
+			irq_flags = cmd.data;
+			tmp |= FIELD_PREP(IRG_FLAGS_MASK, cmd.data);
+
+			if (FIELD_GET(UNHANDLED_IRQ_MASK, irq_flags)) {
+				dev_err(&func->dev, "Unexpected interrupt (1) int=%lx\n",
+					FIELD_GET(UNHANDLED_IRQ_MASK, irq_flags));
+			}
+		}
+		*int_status = tmp;
 	}
-	cmd.raw = 0;
-	cmd.read_write = 0;
-	cmd.data = 0;
-	wilc_sdio_cmd52(wilc, &cmd);
-	irq_flags = cmd.data;
-	tmp |= FIELD_PREP(IRG_FLAGS_MASK, cmd.data);
-
-	if (FIELD_GET(UNHANDLED_IRQ_MASK, irq_flags))
-		dev_err(&func->dev, "Unexpected interrupt (1) int=%lx\n",
-			FIELD_GET(UNHANDLED_IRQ_MASK, irq_flags));
-
-	*int_status = tmp;
 
 	return 0;
 }
@@ -798,38 +1206,115 @@
 {
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 	struct wilc_sdio *sdio_priv = wilc->bus_data;
+	struct sdio_cmd52 cmd;
 	int ret;
 	u32 reg = 0;
 
-	if (sdio_priv->irq_gpio)
-		reg = val & (BIT(MAX_NUM_INT) - 1);
-
-	/* select VMM table 0 */
-	if (val & SEL_VMM_TBL0)
-		reg |= BIT(5);
-	/* select VMM table 1 */
-	if (val & SEL_VMM_TBL1)
-		reg |= BIT(6);
-	/* enable VMM */
-	if (val & EN_VMM)
-		reg |= BIT(7);
-	if (reg) {
-		struct sdio_cmd52 cmd;
-
+	if (wilc->chip == WILC_S02) {
 		cmd.read_write = 1;
-		cmd.function = 0;
-		cmd.raw = 0;
-		cmd.address = WILC_SDIO_IRQ_CLEAR_FLAG_REG;
-		cmd.data = reg;
-
+		cmd.function = 1;
+		cmd.raw = 1;
+		cmd.address = 0x08;
+		cmd.data = 0x1;
 		ret = wilc_sdio_cmd52(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
-				"Failed cmd52, set (%02x) data (%d) ...\n",
-				cmd.address, __LINE__);
+				"Failed cmd52, set 0x08 data (%d) ...\n",
+				__LINE__);
 			return ret;
 		}
+
+		cmd.read_write = 1;
+		cmd.function = 1;
+		cmd.raw = 0;
+		cmd.address = 0x9;
+		cmd.data = 0x1;
+		ret = wilc_sdio_cmd52(wilc, &cmd);
+		if (ret) {
+			dev_err(&func->dev, "Fail cmd 52, set Interrupt register...\n");
+			return 0;
+		}
+	} else if (wilc->chip == WILC_1000) {
+		if (sdio_priv->irq_gpio)
+			reg = val & (BIT(MAX_NUM_INT) - 1);
+
+		/* select VMM table 0 */
+		if (val & SEL_VMM_TBL0)
+			reg |= BIT(5);
+		/* select VMM table 1 */
+		if (val & SEL_VMM_TBL1)
+			reg |= BIT(6);
+		/* enable VMM */
+		if (val & EN_VMM)
+			reg |= BIT(7);
+		if (reg) {
+			struct sdio_cmd52 cmd;
+
+			cmd.read_write = 1;
+			cmd.function = 0;
+			cmd.raw = 0;
+			cmd.address = WILC1000_SDIO_IRQ_CLEAR_FLAG_REG;
+			cmd.data = reg;
+
+			ret = wilc_sdio_cmd52(wilc, &cmd);
+			if (ret) {
+				dev_err(&func->dev,
+					"Failed cmd52, set 0xf8 data (%d) ...\n",
+					__LINE__);
+				return ret;
+			}
+		}
+	} else {
+		if (sdio_priv->irq_gpio) {
+			reg = val & (BIT(MAX_NUM_INT) - 1);
+			if (reg) {
+				struct sdio_cmd52 cmd;
+
+				cmd.read_write = 1;
+				cmd.function = 0;
+				cmd.raw = 0;
+				cmd.address = WILC3000_SDIO_IRQ_CLEAR_FLAG_REG;
+				cmd.data = reg;
+
+				ret = wilc_sdio_cmd52(wilc, &cmd);
+				if (ret) {
+					dev_err(&func->dev,
+						"Failed cmd52, set 0xfe data (%d) ...\n",
+						__LINE__);
+					return ret;
+				}
+			}
+		}
+		reg = 0;
+		/* select VMM table 0 */
+		if (val & SEL_VMM_TBL0)
+			reg |= BIT(0);
+		/* select VMM table 1 */
+		if (val & SEL_VMM_TBL1)
+			reg |= BIT(1);
+		/* enable VMM */
+		if (val & EN_VMM)
+			reg |= BIT(2);
+
+		if (reg) {
+			struct sdio_cmd52 cmd;
+
+			cmd.read_write = 1;
+			cmd.function = 0;
+			cmd.raw = 0;
+			cmd.address = WILC3000_SDIO_VMM_TBL_CTRL_REG;
+			cmd.data = reg;
+
+			ret = wilc_sdio_cmd52(wilc, &cmd);
+			if (ret) {
+				dev_err(&func->dev,
+					"Failed cmd52, set 0xf6 data (%d) ...\n",
+					__LINE__);
+				return ret;
+			}
+		}
 	}
+
 	return 0;
 }
 
@@ -838,30 +1323,32 @@
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 	struct wilc_sdio *sdio_priv = wilc->bus_data;
 	u32 reg;
+	int ret, i;
 
 	if (nint > MAX_NUM_INT) {
-		dev_err(&func->dev, "Too many interrupts (%d)...\n", nint);
+		dev_err(&func->dev, "Too many interrupts %d\n", nint);
 		return -EINVAL;
 	}
 
-	/**
-	 *      Disable power sequencer
-	 **/
-	if (wilc_sdio_read_reg(wilc, WILC_MISC, &reg)) {
-		dev_err(&func->dev, "Failed read misc reg...\n");
-		return -EINVAL;
-	}
-
-	reg &= ~BIT(8);
-	if (wilc_sdio_write_reg(wilc, WILC_MISC, reg)) {
-		dev_err(&func->dev, "Failed write misc reg...\n");
-		return -EINVAL;
+/* WILC3000 only. Was removed in WILC1000 on revision 6200.
+ * Might be related to suspend/resume
+ */
+	if (wilc->chip == WILC_3000) {
+		/**
+		 *      Disable power sequencer
+		 **/
+		if (wilc_sdio_read_reg(wilc, WILC_MISC, &reg)) {
+			dev_err(&func->dev, "Failed read misc reg\n");
+			return -EINVAL;
+		}
+		reg &= ~BIT(8);
+		if (wilc_sdio_write_reg(wilc, WILC_MISC, reg)) {
+			dev_err(&func->dev, "Failed write misc reg\n");
+			return -EINVAL;
+		}
 	}
 
 	if (sdio_priv->irq_gpio) {
-		u32 reg;
-		int ret, i;
-
 		/**
 		 *      interrupt pin mux select
 		 **/
@@ -939,6 +1426,7 @@
 	.disable_interrupt = wilc_sdio_disable_interrupt,
 	.hif_reset = wilc_sdio_reset,
 	.hif_is_init = wilc_sdio_is_init,
+	.hif_clear_init = wilc_sdio_clear_init,
 };
 
 static int wilc_sdio_resume(struct device *dev)
@@ -946,22 +1434,29 @@
 	struct sdio_func *func = dev_to_sdio_func(dev);
 	struct wilc *wilc = sdio_get_drvdata(func);
 
-	dev_info(dev, "sdio resume\n");
-	sdio_release_host(func);
-	chip_wakeup(wilc);
+	dev_info(&func->dev, "sdio resume\n");
+	chip_wakeup(wilc, DEV_WIFI);
 	wilc_sdio_init(wilc, true);
 
-	if (wilc->suspend_event)
-		host_wakeup_notify(wilc);
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	host_wakeup_notify(wilc, DEV_WIFI);
+
+	mutex_lock(&wilc->hif_cs);
+
+	chip_allow_sleep(wilc, DEV_WIFI);
 
-	chip_allow_sleep(wilc);
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
 
 	return 0;
 }
 
 static const struct of_device_id wilc_of_match[] = {
 	{ .compatible = "microchip,wilc1000", },
-	{ /* sentinel */ }
+	{ .compatible = "microchip,wilc3000", },
+	{ /* sentinel */}
 };
 MODULE_DEVICE_TABLE(of, wilc_of_match);
 
@@ -983,4 +1478,5 @@
 module_driver(wilc_sdio_driver,
 	      sdio_register_driver,
 	      sdio_unregister_driver);
+MODULE_DESCRIPTION("Atmel WILC1000 SDIO wireless driver");
 MODULE_LICENSE("GPL");
--- linux-6.6.51/drivers/net/wireless/microchip/wilc1000/spi.c	2024-12-05 13:07:51.231696300 +0900
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/spi.c	2024-12-04 16:41:31.558534500 +0900
@@ -39,17 +39,13 @@
  * zero bytes when the SPI bus operates at 48MHz and none when it
  * operates at 1MHz.
  */
-#define WILC_SPI_RSP_HDR_EXTRA_DATA	8
+#define WILC_SPI_RSP_HDR_EXTRA_DATA	4
 
 struct wilc_spi {
 	bool isinit;		/* true if SPI protocol has been configured */
 	bool probing_crc;	/* true if we're probing chip's CRC config */
 	bool crc7_enabled;	/* true if crc7 is currently enabled */
 	bool crc16_enabled;	/* true if crc16 is currently enabled */
-	struct wilc_gpios {
-		struct gpio_desc *enable;	/* ENABLE GPIO or NULL */
-		struct gpio_desc *reset;	/* RESET GPIO or NULL */
-	} gpios;
 };
 
 static const struct wilc_hif_func wilc_hif_spi;
@@ -74,6 +70,7 @@
 #define CMD_SINGLE_READ				0xca
 #define CMD_RESET				0xcf
 
+#define SPI_RESP_RETRY_COUNT			(10)
 #define SPI_RETRY_MAX_LIMIT			10
 #define SPI_ENABLE_VMM_RETRY_LIMIT		2
 
@@ -158,73 +155,28 @@
 	u8 status;
 } __packed;
 
-static int wilc_parse_gpios(struct wilc *wilc)
-{
-	struct spi_device *spi = to_spi_device(wilc->dev);
-	struct wilc_spi *spi_priv = wilc->bus_data;
-	struct wilc_gpios *gpios = &spi_priv->gpios;
-
-	/* get ENABLE pin and deassert it (if it is defined): */
-	gpios->enable = devm_gpiod_get_optional(&spi->dev,
-						"enable", GPIOD_OUT_LOW);
-	/* get RESET pin and assert it (if it is defined): */
-	if (gpios->enable) {
-		/* if enable pin exists, reset must exist as well */
-		gpios->reset = devm_gpiod_get(&spi->dev,
-					      "reset", GPIOD_OUT_HIGH);
-		if (IS_ERR(gpios->reset)) {
-			dev_err(&spi->dev, "missing reset gpio.\n");
-			return PTR_ERR(gpios->reset);
-		}
-	} else {
-		gpios->reset = devm_gpiod_get_optional(&spi->dev,
-						       "reset", GPIOD_OUT_HIGH);
-	}
-	return 0;
-}
-
-static void wilc_wlan_power(struct wilc *wilc, bool on)
-{
-	struct wilc_spi *spi_priv = wilc->bus_data;
-	struct wilc_gpios *gpios = &spi_priv->gpios;
-
-	if (on) {
-		/* assert ENABLE: */
-		gpiod_set_value(gpios->enable, 1);
-		mdelay(5);
-		/* deassert RESET: */
-		gpiod_set_value(gpios->reset, 0);
-	} else {
-		/* assert RESET: */
-		gpiod_set_value(gpios->reset, 1);
-		/* deassert ENABLE: */
-		gpiod_set_value(gpios->enable, 0);
-	}
-}
-
 static int wilc_bus_probe(struct spi_device *spi)
 {
 	int ret;
+	static bool init_power;
 	struct wilc *wilc;
+	struct device *dev = &spi->dev;
 	struct wilc_spi *spi_priv;
 
 	spi_priv = kzalloc(sizeof(*spi_priv), GFP_KERNEL);
 	if (!spi_priv)
 		return -ENOMEM;
 
-	ret = wilc_cfg80211_init(&wilc, &spi->dev, WILC_HIF_SPI, &wilc_hif_spi);
+	ret = wilc_cfg80211_init(&wilc, dev, WILC_HIF_SPI, &wilc_hif_spi);
 	if (ret)
 		goto free;
 
 	spi_set_drvdata(spi, wilc);
 	wilc->dev = &spi->dev;
 	wilc->bus_data = spi_priv;
+	wilc->dt_dev = &spi->dev;
 	wilc->dev_irq_num = spi->irq;
 
-	ret = wilc_parse_gpios(wilc);
-	if (ret < 0)
-		goto netdev_cleanup;
-
 	wilc->rtc_clk = devm_clk_get_optional(&spi->dev, "rtc");
 	if (IS_ERR(wilc->rtc_clk)) {
 		ret = PTR_ERR(wilc->rtc_clk);
@@ -232,8 +184,24 @@
 	}
 	clk_prepare_enable(wilc->rtc_clk);
 
+	ret = wilc_of_parse_power_pins(wilc);
+	if (ret)
+		goto disable_rtc_clk;
+
+	if (!init_power) {
+		wilc_wlan_power(wilc, false);
+		init_power = 1;
+		wilc_wlan_power(wilc, true);
+	}
+
+	wilc_bt_init(wilc);
+
+	dev_info(dev, "WILC SPI probe success\n");
 	return 0;
 
+disable_rtc_clk:
+	if (!IS_ERR(wilc->rtc_clk))
+		clk_disable_unprepare(wilc->rtc_clk);
 netdev_cleanup:
 	wilc_netdev_cleanup(wilc);
 free:
@@ -249,30 +217,86 @@
 	clk_disable_unprepare(wilc->rtc_clk);
 	wilc_netdev_cleanup(wilc);
 	kfree(spi_priv);
+
+	wilc_bt_deinit();
+}
+
+static int wilc_spi_suspend(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct wilc *wilc = spi_get_drvdata(spi);
+
+	dev_info(&spi->dev, "\n\n << SUSPEND >>\n\n");
+	mutex_lock(&wilc->hif_cs);
+	chip_wakeup(wilc, DEV_WIFI);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	/* notify the chip that host will sleep */
+	host_sleep_notify(wilc, DEV_WIFI);
+	chip_allow_sleep(wilc, DEV_WIFI);
+	mutex_lock(&wilc->hif_cs);
+
+	return 0;
+}
+
+static int wilc_spi_resume(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct wilc *wilc = spi_get_drvdata(spi);
+
+	dev_info(&spi->dev, "\n\n  <<RESUME>>\n\n");
+
+	/* wake the chip to compelete the re-initialization */
+	chip_wakeup(wilc, DEV_WIFI);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	host_wakeup_notify(wilc, DEV_WIFI);
+
+	mutex_lock(&wilc->hif_cs);
+
+	chip_allow_sleep(wilc, DEV_WIFI);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	return 0;
 }
 
 static const struct of_device_id wilc_of_match[] = {
 	{ .compatible = "microchip,wilc1000", },
+	{ .compatible = "microchip,wilc3000", },
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, wilc_of_match);
 
 static const struct spi_device_id wilc_spi_id[] = {
 	{ "wilc1000", 0 },
+	{ "wilc3000", 0 },
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(spi, wilc_spi_id);
 
+static const struct dev_pm_ops wilc_spi_pm_ops = {
+	.suspend = wilc_spi_suspend,
+	.resume = wilc_spi_resume,
+};
+
 static struct spi_driver wilc_spi_driver = {
 	.driver = {
 		.name = SPI_MODALIAS,
 		.of_match_table = wilc_of_match,
+		.pm = &wilc_spi_pm_ops,
 	},
 	.id_table = wilc_spi_id,
 	.probe =  wilc_bus_probe,
 	.remove = wilc_bus_remove,
 };
 module_spi_driver(wilc_spi_driver);
+MODULE_DESCRIPTION("Atmel WILC1000 SPI wireless driver");
 MODULE_LICENSE("GPL");
 
 static int wilc_spi_tx(struct wilc *wilc, u8 *b, u32 len)
@@ -300,7 +324,6 @@
 
 		memset(&msg, 0, sizeof(msg));
 		spi_message_init(&msg);
-		msg.spi = spi;
 		spi_message_add_tail(&tr, &msg);
 
 		ret = spi_sync(spi, &msg);
@@ -343,7 +366,6 @@
 
 		memset(&msg, 0, sizeof(msg));
 		spi_message_init(&msg);
-		msg.spi = spi;
 		spi_message_add_tail(&tr, &msg);
 
 		ret = spi_sync(spi, &msg);
@@ -381,8 +403,6 @@
 
 		memset(&msg, 0, sizeof(msg));
 		spi_message_init(&msg);
-		msg.spi = spi;
-
 		spi_message_add_tail(&tr, &msg);
 		ret = spi_sync(spi, &msg);
 		if (ret < 0)
@@ -476,7 +496,7 @@
  ********************************************/
 static u8 wilc_get_crc7(u8 *buffer, u32 len)
 {
-	return crc7_be(0xfe, buffer, len);
+	return crc7_be(0xfe, buffer, len) | 0x01;
 }
 
 static int wilc_spi_single_read(struct wilc *wilc, u8 cmd, u32 adr, void *b,
@@ -532,10 +552,14 @@
 	}
 
 	r = (struct wilc_spi_rsp_data *)&rb[cmd_len];
+	/*
+	 * Clockless registers operations might return unexptected responses,
+	 * even if successful.
+	 */
 	if (r->rsp_cmd_type != cmd && !clockless) {
 		if (!spi_priv->probing_crc)
 			dev_err(&spi->dev,
-				"Failed cmd, cmd (%02x), resp (%02x)\n",
+				"Failed cmd response, cmd (%02x), resp (%02x)\n",
 				cmd, r->rsp_cmd_type);
 		return -EINVAL;
 	}
@@ -546,11 +570,11 @@
 		return -EINVAL;
 	}
 
-	for (i = 0; i < WILC_SPI_RSP_HDR_EXTRA_DATA; ++i)
+	for (i = 0; i < SPI_RESP_RETRY_COUNT; ++i)
 		if (WILC_GET_RESP_HDR_START(r->data[i]) == 0xf)
 			break;
 
-	if (i >= WILC_SPI_RSP_HDR_EXTRA_DATA) {
+	if (i >= SPI_RESP_RETRY_COUNT) {
 		dev_err(&spi->dev, "Error, data start missing\n");
 		return -EINVAL;
 	}
@@ -731,7 +755,7 @@
 		/*
 		 * Data Response header
 		 */
-		retry = 100;
+		retry = SPI_RESP_RETRY_COUNT;
 		do {
 			if (wilc_spi_rx(wilc, &rsp, 1)) {
 				dev_err(&spi->dev,
@@ -1103,6 +1127,15 @@
 	return 0;
 }
 
+static int wilc_spi_clear_init(struct wilc *wilc)
+{
+	struct wilc_spi *spi_priv = wilc->bus_data;
+
+	spi_priv->isinit = false;
+
+	return 0;
+}
+
 static int wilc_spi_init(struct wilc *wilc, bool resume)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
@@ -1120,8 +1153,6 @@
 		dev_err(&spi->dev, "Fail cmd read chip id...\n");
 	}
 
-	wilc_wlan_power(wilc, true);
-
 	/*
 	 * configure protocol
 	 */
@@ -1185,8 +1216,20 @@
 		return ret;
 	}
 
-	spi_priv->isinit = true;
+	if (!resume) {
+		chipid = wilc_get_chipid(wilc, true);
+		if (is_wilc3000(chipid)) {
+			wilc->chip = WILC_3000;
+		} else if (is_wilc1000(chipid)) {
+			wilc->chip = WILC_1000;
+		} else {
+			dev_err(&spi->dev, "Unsupported chipid: %x\n", chipid);
+			return -EINVAL;
+		}
+		dev_dbg(&spi->dev, "chipid %08x\n", chipid);
+	}
 
+	spi_priv->isinit = true;
 	return 0;
 }
 
@@ -1316,4 +1359,5 @@
 	.hif_sync_ext = wilc_spi_sync_ext,
 	.hif_reset = wilc_spi_reset,
 	.hif_is_init = wilc_spi_is_init,
+	.hif_clear_init = wilc_spi_clear_init,
 };
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/sysfs.c	2024-12-04 16:41:31.559532000 +0900
@@ -0,0 +1,123 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#include <linux/kobject.h>
+#include "cfg80211.h"
+
+static struct kobject *wilc_kobj;
+static int device_created;
+static struct wilc *wl;
+
+static ssize_t wilc_sysfs_show(struct kobject *kobj,
+			       struct kobj_attribute *attr, char *buf)
+{
+	int attr_val = -1;
+
+	if (strcmp(attr->attr.name, "p2p_mode") == 0)
+		attr_val = wl->attr_sysfs.p2p_mode;
+	if (strcmp(attr->attr.name, "ant_swtch_mode") == 0)
+		attr_val = wl->attr_sysfs.ant_swtch_mode;
+	else if (strcmp(attr->attr.name, "antenna1") == 0)
+		attr_val = wl->attr_sysfs.antenna1;
+	else if (strcmp(attr->attr.name, "antenna2") == 0)
+		attr_val = wl->attr_sysfs.antenna2;
+	else if (strcmp(attr->attr.name, "fw_dbg_level") == 0)
+		attr_val = wl->attr_sysfs.fw_dbg_level;
+
+	return sprintf(buf, "%d\n", attr_val);
+}
+
+static ssize_t wilc_sysfs_store(struct kobject *kobj,
+				struct kobj_attribute *attr, const char *buf,
+				size_t count)
+{
+	int attr_val;
+
+	if (kstrtoint(buf, 10, &attr_val))
+		pr_err("Failed to convert p2p_mode string");
+	if (strcmp(attr->attr.name, "p2p_mode") == 0) {
+		wl->attr_sysfs.p2p_mode = (attr_val ? 1 : 0);
+	} else if (strcmp(attr->attr.name, "ant_swtch_mode") == 0) {
+		if (attr_val > ANT_SWTCH_DUAL_GPIO_CTRL)
+			pr_err("Valid antenna switch modes:\n1-Single Antenna, 2-Dual Antenna\n");
+		else
+			wl->attr_sysfs.ant_swtch_mode = attr_val;
+	} else if (strcmp(attr->attr.name, "antenna1") == 0) {
+		wl->attr_sysfs.antenna1 = attr_val;
+	} else if (strcmp(attr->attr.name, "antenna2") == 0) {
+		wl->attr_sysfs.antenna2 = attr_val;
+	} else if (strcmp(attr->attr.name, "fw_dbg_level") == 0) {
+		if (attr_val < WILC_FW_PRINT_LVL_ERROR || attr_val > WILC_FW_PRINT_LVL_MAX) {
+			pr_err("valid fw debug levels:\n 1-WILC_FW_PRINT_LVL_ERROR, \n 2-WILC_FW_PRINT_LVL_DEBUG \n 3-WILC_FW_PRINT_LVL_INFO,"
+				"\n 4-WILC_FW_PRINT_LVL_FUN_PT \n5-WILC_FW_PRINT_LVL_MAX\n");
+		}
+		else {
+			wl->attr_sysfs.fw_dbg_level = attr_val;
+			wilc_set_fw_debug_level(wl, wl->attr_sysfs.fw_dbg_level);
+		}
+	}
+
+	return count;
+}
+
+static struct kobj_attribute p2p_mode_attr =
+	__ATTR(p2p_mode, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct kobj_attribute ant_swtch_mode_attr =
+	__ATTR(ant_swtch_mode, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct kobj_attribute ant_swtch_antenna1_attr =
+	__ATTR(antenna1, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct kobj_attribute ant_swtch_antenna2_attr =
+	__ATTR(antenna2, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct kobj_attribute fw_dbg_level_attr =
+	__ATTR(fw_dbg_level, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct attribute *wilc_attrs[] = {
+	&p2p_mode_attr.attr,
+	&ant_swtch_mode_attr.attr,
+	&ant_swtch_antenna1_attr.attr,
+	&ant_swtch_antenna2_attr.attr,
+	&fw_dbg_level_attr.attr,
+	NULL
+};
+
+static struct attribute_group attr_group = {
+	.attrs = wilc_attrs,
+};
+
+void wilc_sysfs_init(struct wilc *wilc)
+{
+	int retval;
+
+	if (device_created)
+		return;
+
+	wilc_kobj = kobject_create_and_add("wilc", NULL);
+	if (!wilc_kobj) {
+		retval = -ENOMEM;
+		return;
+	}
+
+	retval = sysfs_create_group(wilc_kobj, &attr_group);
+	device_created = 1;
+	wl = wilc;
+	/* By default p2p mode is Group Owner */
+	wl->attr_sysfs.p2p_mode = WILC_P2P_ROLE_GO;
+	wl->attr_sysfs.ant_swtch_mode = ANT_SWTCH_INVALID_GPIO_CTRL;
+	wl->attr_sysfs.antenna1 = 0xFF;
+	wl->attr_sysfs.antenna2 = 0xFF;
+	wl->attr_sysfs.fw_dbg_level = WILC_FW_PRINT_LVL_ERROR;
+}
+
+void wilc_sysfs_exit(void)
+{
+	device_created = 0;
+	sysfs_remove_group(wilc_kobj, &attr_group);
+	kobject_put(wilc_kobj);
+}
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/wilcs02_loopback.c	2024-12-04 16:41:31.559532000 +0900
@@ -0,0 +1,240 @@
+#include <linux/irq.h>
+#include <linux/kthread.h>
+#include <linux/firmware.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+
+#include "cfg80211.h"
+#include "wlan_cfg.h"
+#include "wilcs02_loopback.h"
+#ifdef WILC_S02_TEST_BUS_INTERFACE
+u8 test_frame[WILC_S02_TEST_FRAME_COUNT][WILC_S02_TEST_FRAME_SIZE];
+u32 test_in_progress;
+static u32 test_run_cnt;
+static u8 fmt_str[4096] = {0};
+
+extern int wilc_wlan_txq_add_cfg_pkt(struct wilc_vif *vif, u8 *buffer,
+				     u32 buffer_size);
+
+int time_compare(struct timespec64 *time1, struct timespec64 *time2)
+{
+	if (time1->tv_sec < time2->tv_sec)
+		return -1;
+	if (time1->tv_sec > time2->tv_sec)
+		return 1;
+	if (time1->tv_nsec < time2->tv_nsec)
+		return -1;
+	if (time1->tv_nsec > time2->tv_nsec)
+		return 1;
+
+	return 0;
+}
+
+int time_diff(struct timespec64 *time1, struct timespec64 *time2,
+	      struct timespec64 *diff)
+{
+	int past = 0;
+	int cmp = 0;
+
+	cmp = time_compare(time1, time2);
+	if (cmp == 0) {
+		diff->tv_sec = 0;
+		diff->tv_nsec = 0;
+		past = 1;
+	} else if (cmp == 1) {
+		diff->tv_sec = time1->tv_sec - time2->tv_sec;
+		diff->tv_nsec = time1->tv_nsec;
+
+		if (diff->tv_nsec < time2->tv_nsec) {
+			diff->tv_sec -= 1;
+			diff->tv_nsec += 1000000;
+		}
+		diff->tv_nsec = diff->tv_nsec - time2->tv_nsec;
+	} else {
+		diff->tv_sec = time2->tv_sec - time1->tv_sec;
+		diff->tv_nsec = time2->tv_nsec;
+		if (diff->tv_nsec < time1->tv_nsec) {
+			diff->tv_sec -= 1;
+			diff->tv_nsec += 1000000;
+		}
+		diff->tv_nsec = diff->tv_nsec - time1->tv_nsec;
+		past = 1;
+	}
+	return past;
+}
+
+static void wilc_test_frame_tx_complete(void *priv, int status)
+{
+	pr_debug("%s tx frame copy completed\n", __func__);
+}
+
+void wilc_test_bus_interface(struct wilc_vif *vif, u32 frame_size,
+			     u32 frame_count)
+{
+	int i, ret;
+	struct wilc *wilc = 0;
+	u32 test_frame_size;
+	struct tx_complete_data *tx_data = NULL;
+
+	if (!vif) {
+		pr_err("Test Failed: vif is null");
+		return;
+	}
+
+	test_frame_size = ALIGN((frame_size + ETH_ETHERNET_HDR_OFFSET), 4) & 0xFFFF;
+
+	pr_info("TEST::STARTED ->wilc_test_bus_interface %d %d", test_frame_size,
+		frame_size);
+
+	wilc = vif->wilc;
+	ret = wilc->hif_func->hif_write_reg(wilc,
+					    wilc->vmm_ctl.host_vmm_tx_ctl,
+					    0x6 | (test_frame_size << 8));
+	if (ret) {
+		pr_err("fail write reg host_vmm_ctl..");
+		return;
+	}
+	for (i = 0; i < frame_size; i++)
+		test_frame[0][i] = i % 0xFF;
+
+	test_in_progress = 0;
+
+	tx_data = kmalloc(sizeof(*tx_data), GFP_ATOMIC);
+	if (!tx_data)
+		return;
+
+	tx_data->buff = (u8 *)&test_frame[0];
+	tx_data->size = frame_size;
+
+	if (!wilc_wlan_txq_add_net_pkt(vif->ndev, tx_data, tx_data->buff, frame_size,
+				       wilc_test_frame_tx_complete)) {
+		pr_err("Failed to send the test packet");
+		return;
+	}
+	test_run_cnt++;
+
+	// Required only for bulk loopback test
+	for (i = 1; i < frame_count; i++) {
+		memcpy(&test_frame[i], &test_frame[0][0], frame_size);
+		tx_data->buff = (u8 *)&test_frame[i][0];
+		tx_data->size = frame_size;
+
+		if (!wilc_wlan_txq_add_net_pkt(vif->ndev, tx_data, tx_data->buff,
+					       frame_size,
+					       wilc_test_frame_tx_complete)) {
+			pr_err("Failed to send the test packet");
+			return;
+		}
+		test_run_cnt++;
+	}
+	test_in_progress = 1;
+}
+
+int vspfunc(u8 *buffer, char *format, ...)
+{
+	va_list aptr;
+	int ret;
+
+	va_start(aptr, format);
+	ret = vsprintf(buffer, format, aptr);
+	va_end(aptr);
+	return ret;
+}
+
+void print_hex_string(char *buf, int len)
+{
+	int i;
+	int offset = 0;
+
+	if (len == 0) {
+		vspfunc(fmt_str, "<empty string>"); return;
+	}
+
+	for (i = 0; i < len; i++) {
+		offset += vspfunc(fmt_str + offset, "%02x ",
+				  *((unsigned char *)buf + i));
+
+		if ((i & 0x1f) == 31) {
+			pr_debug("%s", fmt_str);
+			offset = 0;
+		}
+	}
+
+	if (offset)
+		pr_err("%s", fmt_str);
+}
+
+static void wilc_check_result(struct wilc *wilc, u8 *buffer, int size,
+			      u32 frame_size)
+{
+	u32 offset = ETH_ETHERNET_HDR_OFFSET;
+	u32 i;
+	static u32 tested_frame_count;
+
+	while ((offset +  frame_size)  <= size) {
+		for (i = 0; i < frame_size; i++)
+			if (buffer[offset + i] != test_frame[0][i])
+				break;
+		if (i == frame_size) {
+			pr_info("Packet-%d Received correctly",
+				tested_frame_count + 1);
+			tested_frame_count++;
+		} else {
+			pr_err("Packet-%d Failed at offset = %d",
+			       tested_frame_count + 1, i);
+			print_hex_string((buffer + offset + i), (frame_size - i));
+			break;
+		}
+
+		offset += ALIGN((frame_size + ETH_ETHERNET_HDR_OFFSET), 4);
+	}
+
+	pr_info("TEST: Total RECEIVED frames: %d received size = %d %d",
+		tested_frame_count, size, test_run_cnt);
+
+	if (tested_frame_count == WILC_S02_TEST_FRAME_COUNT - 1)
+		pr_info("TEST: COMPLETED::Success");
+}
+
+void wilc_test_verify_result(struct wilc *wilc, u8 *buffer, int size)
+{
+	int ret;
+	struct wilc_vif *vif = wilc_get_wl_to_vif(wilc);
+
+	if (size > (WILC_S02_TEST_2BLOCK_FRAME_SIZE + ETH_ETHERNET_HDR_OFFSET) + 8) {
+		pr_info("BULK LOOPBACK TEST:\n Test Packet Sent to host: size=:%d %d %d",
+			WILC_S02_TEST_FRAME_SIZE, size, ETH_CONFIG_PKT_HDR_OFFSET);
+		wilc_check_result(wilc, buffer, size, WILC_S02_TEST_FRAME_SIZE);
+
+		//Test2 - block transfer loopback
+		wilc_test_bus_interface(vif, WILC_S02_TEST_2BLOCK_FRAME_SIZE, 1);
+	} else if (size == ALIGN((WILC_S02_TEST_2BLOCK_FRAME_SIZE + ETH_ETHERNET_HDR_OFFSET), 4)) {
+		pr_info("2-BLOCK LOOPBACK TEST:\n Test Packet Sent to host: size= :%d",
+			WILC_S02_TEST_2BLOCK_FRAME_SIZE);
+		wilc_check_result(wilc, buffer, size,
+				  WILC_S02_TEST_2BLOCK_FRAME_SIZE);
+
+		//Test2 - block transfer loopback
+		wilc_test_bus_interface(vif, WILC_S02_TEST_1BLOCK_FRAME_SIZE, 1);
+
+	} else if (size == ALIGN((WILC_S02_TEST_1BLOCK_FRAME_SIZE + ETH_ETHERNET_HDR_OFFSET), 4)) {
+		pr_info("1-BLOCK LOOPBACK TEST:\n Test Packet Sent to host: size= :%d",
+			WILC_S02_TEST_1BLOCK_FRAME_SIZE);
+		wilc_check_result(wilc, buffer, size,
+				  WILC_S02_TEST_1BLOCK_FRAME_SIZE);
+
+		//Test2 - block transfer loopback
+		wilc_test_bus_interface(vif, WILC_S02_TEST_BYTE_FRAME_SIZE, 1);
+	} else if (size == ALIGN((WILC_S02_TEST_BYTE_FRAME_SIZE + ETH_ETHERNET_HDR_OFFSET), 4)) {
+		pr_info("BYTE LOOPBACK TEST:\n Test Packet Sent to host: size= :%d",
+			WILC_S02_TEST_BYTE_FRAME_SIZE);
+		wilc_check_result(wilc, buffer, size, WILC_S02_TEST_BYTE_FRAME_SIZE);
+	} else {
+		/* stop the bus interface test */
+		ret = wilc->hif_func->hif_write_reg(wilc,
+						    wilc->vmm_ctl.host_vmm_tx_ctl, 0x6);
+		if (ret)
+			pr_err("fail write reg host_vmm_ctl..");
+	}
+}
+#endif
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/wilcs02_loopback.h	2024-12-04 16:41:31.559532000 +0900
@@ -0,0 +1,21 @@
+#ifndef WILC_S02_LOOP_BACK_H
+#define WILC_S02_LOOP_BACK_H
+
+#define WILC_S02_TEST_BUS_INTERFACE
+
+//ETH_ETHERNET_HDR_OFFSET ~ 34
+
+#define WILC_S02_TEST_FRAME_SIZE  (1580 - ETH_ETHERNET_HDR_OFFSET)
+#define WILC_S02_TEST_2BLOCK_FRAME_SIZE  (1024 - ETH_ETHERNET_HDR_OFFSET)
+#define WILC_S02_TEST_1BLOCK_FRAME_SIZE  (512 - ETH_ETHERNET_HDR_OFFSET)
+#define WILC_S02_TEST_BYTE_FRAME_SIZE  (500 - ETH_ETHERNET_HDR_OFFSET)
+
+#define  WILC_S02_TEST_FRAME_COUNT 5
+
+extern u8 test_frame[WILC_S02_TEST_FRAME_COUNT][WILC_S02_TEST_FRAME_SIZE];
+extern u32 test_in_progress;
+
+void wilc_test_bus_interface(struct wilc_vif *vif, u32 frame_size, u32
+			     frame_count);
+void wilc_test_verify_result(struct wilc *wilc, u8 *buffer, int size);
+#endif
--- linux-6.6.51/drivers/net/wireless/microchip/wilc1000/wlan.c	2024-12-05 13:07:51.232693800 +0900
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/wlan.c	2024-12-04 16:41:31.560529100 +0900
@@ -11,23 +11,19 @@
 #include "wlan_cfg.h"
 
 #define WAKE_UP_TRIAL_RETRY		10000
+#define CMD_RETRY_LIMIT			200
 
-static inline bool is_wilc1000(u32 id)
-{
-	return (id & (~WILC_CHIP_REV_FIELD)) == WILC_1000_BASE_ID;
-}
-
-static inline void acquire_bus(struct wilc *wilc, enum bus_acquire acquire)
+void acquire_bus(struct wilc *wilc, enum bus_acquire acquire, int source)
 {
 	mutex_lock(&wilc->hif_cs);
-	if (acquire == WILC_BUS_ACQUIRE_AND_WAKEUP && wilc->power_save_mode)
-		chip_wakeup(wilc);
+	if (acquire == WILC_BUS_ACQUIRE_AND_WAKEUP)
+		chip_wakeup(wilc, source);
 }
 
-static inline void release_bus(struct wilc *wilc, enum bus_release release)
+void release_bus(struct wilc *wilc, enum bus_release release, int source)
 {
-	if (release == WILC_BUS_RELEASE_ALLOW_SLEEP && wilc->power_save_mode)
-		chip_allow_sleep(wilc);
+	if (release == WILC_BUS_RELEASE_ALLOW_SLEEP)
+		chip_allow_sleep(wilc, source);
 	mutex_unlock(&wilc->hif_cs);
 }
 
@@ -70,9 +66,12 @@
 	list_add_tail(&tqe->list, &wilc->txq[q_num].txq_head.list);
 	wilc->txq_entries += 1;
 	wilc->txq[q_num].count++;
+	PRINT_INFO(vif->ndev, TX_DBG, "Number of entries in TxQ = %d\n",
+		   wilc->txq_entries);
 
 	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
 
+	PRINT_INFO(vif->ndev, TX_DBG, "Wake the txq_handling\n");
 	complete(&wilc->txq_event);
 }
 
@@ -89,10 +88,13 @@
 	list_add(&tqe->list, &wilc->txq[q_num].txq_head.list);
 	wilc->txq_entries += 1;
 	wilc->txq[q_num].count++;
+	PRINT_INFO(vif->ndev, TX_DBG, "Number of entries in TxQ = %d\n",
+		   wilc->txq_entries);
 
 	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
 	mutex_unlock(&wilc->txq_add_to_head_cs);
 	complete(&wilc->txq_event);
+	PRINT_INFO(vif->ndev, TX_DBG, "Wake up the txq_handler\n");
 }
 
 #define NOT_TCP_ACK			(-1)
@@ -108,6 +110,8 @@
 		f->ack_session_info[f->tcp_session].src_port = src_prt;
 		f->ack_session_info[f->tcp_session].dst_port = dst_prt;
 		f->tcp_session++;
+		PRINT_INFO(vif->ndev, TCP_ENH, "TCP Session %d to Ack %d\n",
+			   f->tcp_session, seq);
 	}
 }
 
@@ -216,6 +220,8 @@
 		if (f->pending_acks[i].ack_num < bigger_ack_num) {
 			struct txq_entry_t *tqe;
 
+			PRINT_INFO(vif->ndev, TCP_ENH, "DROP ACK: %u\n",
+				   f->pending_acks[i].ack_num);
 			tqe = f->pending_acks[i].txqe;
 			if (tqe) {
 				wilc_wlan_txq_remove(wilc, tqe->q_num, tqe);
@@ -239,24 +245,53 @@
 	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
 
 	while (dropped > 0) {
-		wait_for_completion_timeout(&wilc->txq_event,
-					    msecs_to_jiffies(1));
+		if (!wait_for_completion_timeout(&wilc->txq_event,
+						 msecs_to_jiffies(1)))
+			PRINT_ER(vif->ndev, "completion timedout\n");
 		dropped--;
 	}
 }
 
+static struct net_device *get_if_handler(struct wilc *wilc, u8 *mac_header)
+{
+	struct net_device *mon_netdev = NULL;
+	struct wilc_vif *vif;
+	struct ieee80211_hdr *h = (struct ieee80211_hdr *)mac_header;
+
+	list_for_each_entry_rcu(vif, &wilc->vif_list, list) {
+		if (vif->iftype == WILC_STATION_MODE)
+			if (ether_addr_equal_unaligned(h->addr2, vif->bssid))
+				return vif->ndev;
+		if (vif->iftype == WILC_AP_MODE)
+			if (ether_addr_equal_unaligned(h->addr1, vif->bssid))
+				return vif->ndev;
+		if (vif->iftype == WILC_MONITOR_MODE)
+			mon_netdev = vif->ndev;
+	}
+
+	if (!mon_netdev)
+		pr_warn("%s Invalid handle\n", __func__);
+	return mon_netdev;
+}
+
 void wilc_enable_tcp_ack_filter(struct wilc_vif *vif, bool value)
 {
 	vif->ack_filter.enabled = value;
 }
 
-static int wilc_wlan_txq_add_cfg_pkt(struct wilc_vif *vif, u8 *buffer,
+int wilc_wlan_txq_add_cfg_pkt(struct wilc_vif *vif, u8 *buffer,
 				     u32 buffer_size)
 {
 	struct txq_entry_t *tqe;
 	struct wilc *wilc = vif->wilc;
 
-	netdev_dbg(vif->ndev, "Adding config packet ...\n");
+#ifdef WILC_S02_TEST_BUS_INTERFACE
+	if (is_test_mode && test_in_progress){
+		return 0;
+	}
+#endif
+
+	PRINT_INFO(vif->ndev, TX_DBG, "Adding config packet ...\n");
 	if (wilc->quit) {
 		netdev_dbg(vif->ndev, "Return due to clear function\n");
 		complete(&wilc->cfg_event);
@@ -278,6 +313,9 @@
 	tqe->ack_idx = NOT_TCP_ACK;
 	tqe->vif = vif;
 
+	PRINT_INFO(vif->ndev, TX_DBG,
+		   "Adding the config packet at the Queue tail\n");
+
 	wilc_wlan_txq_add_to_head(vif, AC_VO_Q, tqe);
 
 	return 1;
@@ -376,12 +414,20 @@
 	if (!ratio)
 		return -EINVAL;
 
-	for (i = 0; i < NQUEUES; i++)
+	for (i = 0; i < NQUEUES; i++) {
 		if (wl->txq[i].fw.count > max_count)
 			max_count = wl->txq[i].fw.count;
+	}
+
+	if (max_count > ECDA_MAX_LIMIT)
+		max_count = ECDA_MAX_LIMIT;
 
-	for (i = 0; i < NQUEUES; i++)
-		ratio[i] = max_count - wl->txq[i].fw.count;
+	for (i = 0; i < NQUEUES; i++) {
+		if (wl->txq[i].fw.count > ECDA_MAX_LIMIT)
+			ratio[i] = 0;
+		else
+			ratio[i] = max_count - wl->txq[i].fw.count;
+	}
 
 	return 0;
 }
@@ -421,13 +467,21 @@
 	u8 q_num;
 
 	wilc = vif->wilc;
+#ifdef WILC_S02_TEST_BUS_INTERFACE
+	if (is_test_mode && test_in_progress)
+		return 0;
+#endif
 
 	if (wilc->quit) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "drv is quitting, return from net_pkt\n");
 		tx_complete_fn(tx_data, 0);
 		return 0;
 	}
 
 	if (!wilc->initialized) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "not_init, return from net_pkt\n");
 		tx_complete_fn(tx_data, 0);
 		return 0;
 	}
@@ -435,6 +489,8 @@
 	tqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);
 
 	if (!tqe) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "malloc failed, return from net_pkt\n");
 		tx_complete_fn(tx_data, 0);
 		return 0;
 	}
@@ -445,15 +501,27 @@
 	tqe->priv = tx_data;
 	tqe->vif = vif;
 
+#ifdef WILC_S02_TEST_BUS_INTERFACE
+	if(is_test_mode){
+		q_num = 0;
+		tqe->ack_idx = NOT_TCP_ACK;
+		wilc_wlan_txq_add_to_tail(dev, q_num, tqe);
+		return 1;
+	}
+#endif
 	q_num = ac_classify(wilc, tx_data->skb);
 	tqe->q_num = q_num;
 	if (ac_change(wilc, &q_num)) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "No suitable non-ACM queue\n");
 		tx_complete_fn(tx_data, 0);
 		kfree(tqe);
 		return 0;
 	}
 
 	if (is_ac_q_limit(wilc, q_num)) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "Adding mgmt packet at the Queue tail\n");
 		tqe->ack_idx = NOT_TCP_ACK;
 		if (vif->ack_filter.enabled)
 			tcp_process(dev, tqe);
@@ -474,20 +542,27 @@
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wilc;
 
-	wilc = vif->wilc;
+#ifdef WILC_S02_TEST_BUS_INTERFACE
+	if (is_test_mode && test_in_progress)
+		return 0;
+#endif
 
+	wilc = vif->wilc;
 	if (wilc->quit) {
+		PRINT_INFO(vif->ndev, TX_DBG, "drv is quitting\n");
 		tx_complete_fn(priv, 0);
 		return 0;
 	}
 
 	if (!wilc->initialized) {
+		PRINT_INFO(vif->ndev, TX_DBG, "wilc not_init\n");
 		tx_complete_fn(priv, 0);
 		return 0;
 	}
 	tqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);
 
 	if (!tqe) {
+		PRINT_INFO(vif->ndev, TX_DBG, "Queue malloc failed\n");
 		tx_complete_fn(priv, 0);
 		return 0;
 	}
@@ -499,6 +574,8 @@
 	tqe->q_num = AC_BE_Q;
 	tqe->ack_idx = NOT_TCP_ACK;
 	tqe->vif = vif;
+
+	PRINT_INFO(vif->ndev, TX_DBG, "Adding Mgmt packet to Queue tail\n");
 	wilc_wlan_txq_add_to_tail(dev, AC_VO_Q, tqe);
 	return 1;
 }
@@ -560,7 +637,12 @@
 	return rqe;
 }
 
-void chip_allow_sleep(struct wilc *wilc)
+static int chip_allow_sleep_wilcs02(struct wilc *wilc, int source)
+{
+	return 0;
+}
+
+static int chip_allow_sleep_wilc1000(struct wilc *wilc, int source)
 {
 	u32 reg = 0;
 	const struct wilc_hif_func *hif_func = wilc->hif_func;
@@ -570,16 +652,17 @@
 	u32 trials = 100;
 	int ret;
 
-	if (wilc->io_type == WILC_HIF_SDIO) {
-		wakeup_reg = WILC_SDIO_WAKEUP_REG;
-		wakeup_bit = WILC_SDIO_WAKEUP_BIT;
+	if (wilc->io_type == WILC_HIF_SDIO ||
+	    wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+		wakeup_reg = WILC1000_SDIO_WAKEUP_REG;
+		wakeup_bit = WILC1000_SDIO_WAKEUP_BIT;
 		from_host_to_fw_reg = WILC_SDIO_HOST_TO_FW_REG;
 		from_host_to_fw_bit = WILC_SDIO_HOST_TO_FW_BIT;
 		to_host_from_fw_reg = WILC_SDIO_FW_TO_HOST_REG;
 		to_host_from_fw_bit = WILC_SDIO_FW_TO_HOST_BIT;
 	} else {
-		wakeup_reg = WILC_SPI_WAKEUP_REG;
-		wakeup_bit = WILC_SPI_WAKEUP_BIT;
+		wakeup_reg = WILC1000_SPI_WAKEUP_REG;
+		wakeup_bit = WILC1000_SPI_WAKEUP_BIT;
 		from_host_to_fw_reg = WILC_SPI_HOST_TO_FW_REG;
 		from_host_to_fw_bit = WILC_SPI_HOST_TO_FW_BIT;
 		to_host_from_fw_reg = WILC_SPI_FW_TO_HOST_REG;
@@ -589,7 +672,7 @@
 	while (--trials) {
 		ret = hif_func->hif_read_reg(wilc, to_host_from_fw_reg, &reg);
 		if (ret)
-			return;
+			return ret;
 		if ((reg & to_host_from_fw_bit) == 0)
 			break;
 	}
@@ -599,28 +682,76 @@
 	/* Clear bit 1 */
 	ret = hif_func->hif_read_reg(wilc, wakeup_reg, &reg);
 	if (ret)
-		return;
+		return ret;
 	if (reg & wakeup_bit) {
 		reg &= ~wakeup_bit;
 		ret = hif_func->hif_write_reg(wilc, wakeup_reg, reg);
 		if (ret)
-			return;
+			return ret;
 	}
 
 	ret = hif_func->hif_read_reg(wilc, from_host_to_fw_reg, &reg);
 	if (ret)
-		return;
+		return ret;
 	if (reg & from_host_to_fw_bit) {
 		reg &= ~from_host_to_fw_bit;
 		ret = hif_func->hif_write_reg(wilc, from_host_to_fw_reg, reg);
 		if (ret)
-			return;
+			return ret;
+	}
 
+	return 0;
+}
+
+static int chip_allow_sleep_wilc3000(struct wilc *wilc, int source)
+{
+	u32 reg = 0;
+	int ret;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+
+	if (wilc->io_type == WILC_HIF_SDIO ||
+	    wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+		ret = hif_func->hif_read_reg(wilc, WILC3000_SDIO_WAKEUP_REG,
+					     &reg);
+		if (ret)
+			return ret;
+		ret = hif_func->hif_write_reg(wilc, WILC3000_SDIO_WAKEUP_REG,
+					      reg & ~WILC3000_SDIO_WAKEUP_BIT);
+		if (ret)
+			return ret;
+	} else {
+		ret = hif_func->hif_read_reg(wilc, WILC3000_SPI_WAKEUP_REG,
+					     &reg);
+		if (ret)
+			return ret;
+		ret = hif_func->hif_write_reg(wilc, WILC3000_SPI_WAKEUP_REG,
+					      reg & ~WILC3000_SPI_WAKEUP_BIT);
+		if (ret)
+			return ret;
 	}
+	return 0;
+}
+
+void chip_allow_sleep(struct wilc *wilc, int source)
+{
+	int ret = 0;
+
+	if (((source == DEV_WIFI) && (wilc->keep_awake[DEV_BT] == true)) ||
+	    ((source == DEV_BT) && (wilc->keep_awake[DEV_WIFI] == true)))
+		pr_warn("Another device is preventing allow sleep operation. request source is %s\n",
+			(source == DEV_WIFI ? "Wifi" : "BT"));
+	else
+		if (wilc->chip == WILC_1000)
+			ret = chip_allow_sleep_wilc1000(wilc, source);
+		else if (wilc->chip == WILC_3000)
+			ret = chip_allow_sleep_wilc3000(wilc, source);
+		else
+			ret = chip_allow_sleep_wilcs02(wilc, source);
+	if (!ret)
+		wilc->keep_awake[source] = false;
 }
-EXPORT_SYMBOL_GPL(chip_allow_sleep);
 
-void chip_wakeup(struct wilc *wilc)
+static void chip_wakeup_wilc1000(struct wilc *wilc, int source)
 {
 	u32 ret = 0;
 	u32 clk_status_val = 0, trials = 0;
@@ -629,18 +760,19 @@
 	u32 from_host_to_fw_reg, from_host_to_fw_bit;
 	const struct wilc_hif_func *hif_func = wilc->hif_func;
 
-	if (wilc->io_type == WILC_HIF_SDIO) {
-		wakeup_reg = WILC_SDIO_WAKEUP_REG;
-		wakeup_bit = WILC_SDIO_WAKEUP_BIT;
-		clk_status_reg = WILC_SDIO_CLK_STATUS_REG;
-		clk_status_bit = WILC_SDIO_CLK_STATUS_BIT;
+	if (wilc->io_type == WILC_HIF_SDIO ||
+	    wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+		wakeup_reg = WILC1000_SDIO_WAKEUP_REG;
+		wakeup_bit = WILC1000_SDIO_WAKEUP_BIT;
+		clk_status_reg = WILC1000_SDIO_CLK_STATUS_REG;
+		clk_status_bit = WILC1000_SDIO_CLK_STATUS_BIT;
 		from_host_to_fw_reg = WILC_SDIO_HOST_TO_FW_REG;
 		from_host_to_fw_bit = WILC_SDIO_HOST_TO_FW_BIT;
 	} else {
-		wakeup_reg = WILC_SPI_WAKEUP_REG;
-		wakeup_bit = WILC_SPI_WAKEUP_BIT;
-		clk_status_reg = WILC_SPI_CLK_STATUS_REG;
-		clk_status_bit = WILC_SPI_CLK_STATUS_BIT;
+		wakeup_reg = WILC1000_SPI_WAKEUP_REG;
+		wakeup_bit = WILC1000_SPI_WAKEUP_BIT;
+		clk_status_reg = WILC1000_SPI_CLK_STATUS_REG;
+		clk_status_bit = WILC1000_SPI_CLK_STATUS_BIT;
 		from_host_to_fw_reg = WILC_SPI_HOST_TO_FW_REG;
 		from_host_to_fw_bit = WILC_SPI_HOST_TO_FW_BIT;
 	}
@@ -661,7 +793,7 @@
 		ret = hif_func->hif_read_reg(wilc, clk_status_reg,
 					     &clk_status_val);
 		if (ret) {
-			pr_err("Bus error %d %x\n", ret, clk_status_val);
+			pr_err("Bus error %d %x", ret, clk_status_val);
 			return;
 		}
 		if (clk_status_val & clk_status_bit)
@@ -670,7 +802,7 @@
 		trials++;
 	}
 	if (trials >= WAKE_UP_TRIAL_RETRY) {
-		pr_err("Failed to wake-up the chip\n");
+		pr_err("Failed to wake-up the chip");
 		return;
 	}
 	/* Sometimes spi fail to read clock regs after reading
@@ -679,23 +811,107 @@
 	if (wilc->io_type == WILC_HIF_SPI)
 		wilc->hif_func->hif_reset(wilc);
 }
-EXPORT_SYMBOL_GPL(chip_wakeup);
 
-void host_wakeup_notify(struct wilc *wilc)
+static void chip_wakeup_wilc3000(struct wilc *wilc, int source)
+{
+	u32 wakeup_reg_val, clk_status_reg_val, trials = 0;
+	u32 wakeup_reg, wakeup_bit;
+	u32 clk_status_reg, clk_status_bit;
+	int wake_seq_trials = 5;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+
+	if (wilc->io_type == WILC_HIF_SDIO ||
+	    wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+		wakeup_reg = WILC3000_SDIO_WAKEUP_REG;
+		wakeup_bit = WILC3000_SDIO_WAKEUP_BIT;
+		clk_status_reg = WILC3000_SDIO_CLK_STATUS_REG;
+		clk_status_bit = WILC3000_SDIO_CLK_STATUS_BIT;
+	} else {
+		wakeup_reg = WILC3000_SPI_WAKEUP_REG;
+		wakeup_bit = WILC3000_SPI_WAKEUP_BIT;
+		clk_status_reg = WILC3000_SPI_CLK_STATUS_REG;
+		clk_status_bit = WILC3000_SPI_CLK_STATUS_BIT;
+	}
+
+	hif_func->hif_read_reg(wilc, wakeup_reg, &wakeup_reg_val);
+	do {
+		hif_func->hif_write_reg(wilc, wakeup_reg, wakeup_reg_val |
+							  wakeup_bit);
+		/* Check the clock status */
+		hif_func->hif_read_reg(wilc, clk_status_reg,
+				       &clk_status_reg_val);
+
+		/*
+		 * in case of clocks off, wait 1ms, and check it again.
+		 * if still off, wait for another 1ms, for a total wait of 3ms.
+		 * If still off, redo the wake up sequence
+		 */
+		while ((clk_status_reg_val & clk_status_bit) == 0 &&
+		       (++trials % 4) != 0) {
+			/* Wait for the chip to stabilize*/
+			usleep_range(1000, 1100);
+
+			/*
+			 * Make sure chip is awake. This is an extra step that
+			 * can be removed later to avoid the bus access
+			 * overhead
+			 */
+			hif_func->hif_read_reg(wilc, clk_status_reg,
+					       &clk_status_reg_val);
+		}
+		/* in case of failure, Reset the wakeup bit to introduce a new
+		 * edge on the next loop
+		 */
+		if ((clk_status_reg_val & clk_status_bit) == 0) {
+			hif_func->hif_write_reg(wilc, wakeup_reg,
+						wakeup_reg_val & (~wakeup_bit));
+			/* added wait before wakeup sequence retry */
+			usleep_range(200, 300);
+		}
+	} while (((clk_status_reg_val & clk_status_bit) == 0)
+		 && (wake_seq_trials-- > 0));
+	if (!wake_seq_trials)
+		dev_err(wilc->dev, "clocks still OFF. Wake up failed\n");
+	wilc->keep_awake[source] = true;
+}
+
+static void chip_wakeup_wilcs02(struct wilc *wilc, int source)
 {
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);
-	wilc->hif_func->hif_write_reg(wilc, WILC_CORTUS_INTERRUPT_2, 1);
-	release_bus(wilc, WILC_BUS_RELEASE_ONLY);
 }
-EXPORT_SYMBOL_GPL(host_wakeup_notify);
 
-void host_sleep_notify(struct wilc *wilc)
+void chip_wakeup(struct wilc *wilc, int source)
 {
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);
-	wilc->hif_func->hif_write_reg(wilc, WILC_CORTUS_INTERRUPT_1, 1);
-	release_bus(wilc, WILC_BUS_RELEASE_ONLY);
+	if (wilc->chip == WILC_1000)
+		chip_wakeup_wilc1000(wilc, source);
+	else if (wilc->chip == WILC_3000)
+		chip_wakeup_wilc3000(wilc, source);
+	else
+		chip_wakeup_wilcs02(wilc, source);
+}
+
+void host_wakeup_notify(struct wilc *wilc, int source)
+{
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY, source);
+	if (wilc->chip == WILC_1000)
+		wilc->hif_func->hif_write_reg(wilc, WILC1000_CORTUS_INTERRUPT_2,
+					      1);
+	else if (wilc->chip == WILC_3000)
+		wilc->hif_func->hif_write_reg(wilc, WILC3000_CORTUS_INTERRUPT_2,
+					      1);
+	release_bus(wilc, WILC_BUS_RELEASE_ONLY, source);
+}
+
+void host_sleep_notify(struct wilc *wilc, int source)
+{
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY, source);
+	if (wilc->chip == WILC_1000)
+		wilc->hif_func->hif_write_reg(wilc, WILC1000_CORTUS_INTERRUPT_1,
+					      1);
+	else if (wilc->chip == WILC_3000)
+		wilc->hif_func->hif_write_reg(wilc, WILC3000_CORTUS_INTERRUPT_1,
+					      1);
+	release_bus(wilc, WILC_BUS_RELEASE_ONLY, source);
 }
-EXPORT_SYMBOL_GPL(host_sleep_notify);
 
 int wilc_wlan_handle_txq(struct wilc *wilc, u32 *txq_count)
 {
@@ -704,7 +920,7 @@
 	u32 sum;
 	u32 reg;
 	u8 ac_desired_ratio[NQUEUES] = {0, 0, 0, 0};
-	u8 ac_preserve_ratio[NQUEUES] = {1, 1, 1, 1};
+	u8 ac_preserve_ratio[NQUEUES] = {2, 2, 2, 2};
 	u8 *num_pkts_to_add;
 	u8 vmm_entries_ac[WILC_VMM_TBL_SIZE];
 	u32 offset = 0;
@@ -721,6 +937,11 @@
 	u8 *txb = wilc->tx_buffer;
 	struct wilc_vif *vif;
 
+	if (!wilc->txq_entries) {
+		*txq_count = 0;
+		return 0;
+	}
+
 	if (wilc->quit)
 		goto out_update_cnt;
 
@@ -748,8 +969,8 @@
 				continue;
 
 			ac_exist = 1;
-			for (k = 0; (k < num_pkts_to_add[ac]) &&
-			     (!max_size_over) && tqe_q[ac]; k++) {
+			for (k = 0; (!max_size_over && tqe_q[ac]) &&
+				(tqe_q[ac]->type != WILC_NET_PKT || (k < num_pkts_to_add[ac])); k++) {
 				if (i >= (WILC_VMM_TBL_SIZE - 1)) {
 					max_size_over = 1;
 					break;
@@ -790,23 +1011,27 @@
 		goto out_unlock;
 	vmm_table[i] = 0x0;
 
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
 	counter = 0;
 	func = wilc->hif_func;
 	do {
-		ret = func->hif_read_reg(wilc, WILC_HOST_TX_CTRL, &reg);
+		reg = 0;
+		ret = func->hif_read_reg(wilc, wilc->vmm_ctl.host_wmm_stat, &reg);
 		if (ret)
 			break;
 
-		if ((reg & 0x1) == 0) {
+		/* wmm stat received */
+		if ((wilc->chip == WILC_S02 && (reg & 0x1) == 0x1) ||
+			(wilc->chip != WILC_S02 && (reg & 0x1) == 0x0)) {
 			ac_update_fw_ac_pkt_info(wilc, reg);
 			break;
 		}
 
 		counter++;
-		if (counter > 200) {
+		if (counter > CMD_RETRY_LIMIT) {
 			counter = 0;
-			ret = func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, 0);
+			ret = func->hif_write_reg(wilc,
+						  wilc->vmm_ctl.host_tx_ctl, 0);
 			break;
 		}
 	} while (!wilc->quit);
@@ -817,39 +1042,106 @@
 	timeout = 200;
 	do {
 		ret = func->hif_block_tx(wilc,
-					 WILC_VMM_TBL_RX_SHADOW_BASE,
+					 wilc->vmm_ctl.vmm_tbl_rx_shadow_base,
 					 (u8 *)vmm_table,
 					 ((i + 1) * 4));
 		if (ret)
 			break;
 
-		ret = func->hif_write_reg(wilc, WILC_HOST_VMM_CTL, 0x2);
-		if (ret)
-			break;
+		if (wilc->chip == WILC_S02) {
+			ret = wilc->hif_func->hif_write_reg(wilc,
+							    wilc->vmm_ctl.host_vmm_tx_ctl,
+							    WILC_S02_HOST_MALLOC);
+			if (ret) {
+				pr_err("fail write reg host_vmm_ctl");
+				break;
+			}
+
+			do {
+				ret = func->hif_read_reg(wilc,
+							      wilc->vmm_ctl.host_vmm_rx_ctl,
+							      &reg);
+				if (ret)
+					break;
+
+				if ((reg >> 2) & 0x1) {
+					entries = ((reg >> 3) & 0x3f);
+					break;
+				}
+			} while (--timeout);
+		} else if (wilc->chip == WILC_1000) {
+			ret = wilc->hif_func->hif_write_reg(wilc,
+							    wilc->vmm_ctl.host_vmm_tx_ctl,
+							    0x2);
+			if (ret)
+				break;
 
-		do {
-			ret = func->hif_read_reg(wilc, WILC_HOST_VMM_CTL, &reg);
+			do {
+				ret = func->hif_read_reg(wilc,
+						      wilc->vmm_ctl.host_vmm_tx_ctl,
+						      &reg);
+				if (ret)
+					break;
+				if (FIELD_GET(WILC_VMM_ENTRY_AVAILABLE, reg)) {
+					entries = FIELD_GET(WILC_VMM_ENTRY_COUNT,
+							    reg);
+					break;
+				}
+			} while (--timeout);
+		} else {
+			ret = func->hif_write_reg(wilc,
+					      wilc->vmm_ctl.host_vmm_tx_ctl,
+					      0);
 			if (ret)
 				break;
-			if (FIELD_GET(WILC_VMM_ENTRY_AVAILABLE, reg)) {
-				entries = FIELD_GET(WILC_VMM_ENTRY_COUNT, reg);
+
+			/* interrupt firmware */
+			ret = func->hif_write_reg(wilc,
+					      WILC_INTERRUPT_CORTUS_0,
+					      1);
+			if (ret)
 				break;
-			}
-		} while (--timeout);
+
+			do {
+				ret = func->hif_read_reg(wilc,
+						      WILC_INTERRUPT_CORTUS_0,
+						      &reg);
+				if (ret)
+					break;
+
+				if (reg == 0) {
+					/* Get the entries */
+
+					ret = func->hif_read_reg(wilc,
+							      wilc->vmm_ctl.host_vmm_tx_ctl,
+							      &reg);
+					if (ret)
+						break;
+
+					entries = FIELD_GET(WILC_VMM_ENTRY_COUNT,
+							    reg);
+					break;
+				}
+			} while (--timeout);
+		}
+
 		if (timeout <= 0) {
-			ret = func->hif_write_reg(wilc, WILC_HOST_VMM_CTL, 0x0);
+			if (wilc->chip != WILC_S02)
+				ret = func->hif_write_reg(wilc,
+							  wilc->vmm_ctl.host_vmm_tx_ctl, 0x0);
 			break;
 		}
 
 		if (ret)
 			break;
 
-		if (entries == 0) {
-			ret = func->hif_read_reg(wilc, WILC_HOST_TX_CTRL, &reg);
+		if (entries == 0 && wilc->chip != WILC_S02) {
+			ret = func->hif_read_reg(wilc, wilc->vmm_ctl.host_tx_ctl, &reg);
 			if (ret)
 				break;
+
 			reg &= ~BIT(0);
-			ret = func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, reg);
+			ret = func->hif_write_reg(wilc, wilc->vmm_ctl.host_tx_ctl, reg);
 		}
 	} while (0);
 
@@ -862,11 +1154,15 @@
 		 * the packet from tx queue.
 		 */
 		ret = WILC_VMM_ENTRY_FULL_RETRY;
+		if (!timeout && wilc->chip == WILC_S02)
+			wilc->hif_func->hif_write_reg(wilc,
+						      wilc->vmm_ctl.host_vmm_tx_ctl,
+						      DISBLE_RX_VMM);
 		goto out_release_bus;
 	}
 
-	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
-
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+	schedule();
 	offset = 0;
 	i = 0;
 	do {
@@ -904,6 +1200,8 @@
 		} else if (tqe->type == WILC_NET_PKT) {
 			int prio = tqe->q_num;
 
+			wilc->txq[prio].fw.count++;
+
 			bssid = tqe->vif->bssid;
 			buffer_offset = ETH_ETHERNET_HDR_OFFSET;
 			memcpy(&txb[offset + 4], &prio, sizeof(prio));
@@ -924,22 +1222,28 @@
 			vif->ack_filter.pending_acks[tqe->ack_idx].txqe = NULL;
 		kfree(tqe);
 	} while (--entries);
-	for (i = 0; i < NQUEUES; i++)
-		wilc->txq[i].fw.count += ac_pkt_num_to_chip[i];
 
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);
 
-	ret = func->hif_clear_int_ext(wilc, ENABLE_TX_VMM);
-	if (ret)
-		goto out_release_bus;
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
+
+	if (wilc->chip != WILC_S02) {
+		ret = func->hif_clear_int_ext(wilc, ENABLE_TX_VMM);
+
+		if (ret)
+			goto out_release_bus;
+	}
 
 	ret = func->hif_block_tx_ext(wilc, 0, txb, offset);
 
+	if (!ret)
+		cfg_packet_timeout = 0;
+
 out_release_bus:
-	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
 
 out_unlock:
 	mutex_unlock(&wilc->txq_add_to_head_cs);
+	schedule();
 
 out_update_cnt:
 	*txq_count = wilc->txq_entries;
@@ -954,6 +1258,13 @@
 	int is_cfg_packet;
 	u8 *buff_ptr;
 
+#ifdef WILC_S02_TEST_BUS_INTERFACE
+	if (is_test_mode && test_in_progress) {
+		wilc_test_verify_result(wilc, buffer, size);
+		return;
+	}
+#endif
+
 	do {
 		buff_ptr = buffer + offset;
 		header = get_unaligned_le32(buff_ptr);
@@ -968,12 +1279,38 @@
 
 		if (pkt_offset & IS_MANAGMEMENT) {
 			buff_ptr += HOST_HDR_OFFSET;
-			wilc_wfi_mgmt_rx(wilc, buff_ptr, pkt_len,
-					 pkt_offset & IS_MGMT_AUTH_PKT);
+
+			if (pkt_offset & IS_MON_PKT) {
+				struct wilc_vif *vif;
+
+				vif = wilc_get_vif_from_type(wilc,
+							     WILC_MONITOR_MODE);
+				if (vif)
+					wilc_wfi_monitor_rx(vif->ndev, buff_ptr,
+							    pkt_len);
+			} else {
+				wilc_wfi_mgmt_rx(wilc, buff_ptr, pkt_len,
+						 pkt_offset & IS_MGMT_AUTH_PKT);
+			}
 		} else {
 			if (!is_cfg_packet) {
-				wilc_frmw_to_host(wilc, buff_ptr, pkt_len,
-						  pkt_offset);
+				struct net_device *wilc_netdev;
+				struct wilc_vif *vif;
+				int srcu_idx;
+
+				srcu_idx = srcu_read_lock(&wilc->srcu);
+				wilc_netdev = get_if_handler(wilc, buff_ptr);
+
+				if (!wilc_netdev) {
+					pr_err("%s: wilc_netdev in wilc is NULL\n",
+					       __func__);
+					srcu_read_unlock(&wilc->srcu, srcu_idx);
+					return;
+				}
+				vif = netdev_priv(wilc_netdev);
+				wilc_frmw_to_host(vif, buff_ptr, pkt_len,
+						  pkt_offset, PKT_STATUS_NEW);
+				srcu_read_unlock(&wilc->srcu, srcu_idx);
 			} else {
 				struct wilc_cfg_rsp rsp;
 
@@ -1011,8 +1348,11 @@
 
 		kfree(rqe);
 	}
-	if (wilc->quit)
+	if (wilc->quit) {
+		pr_info("%s Quitting. Exit handle RX queue\n",
+			__func__);
 		complete(&wilc->cfg_event);
+	}
 }
 
 static void wilc_unknown_isr_ext(struct wilc *wilc)
@@ -1029,11 +1369,17 @@
 	int ret = 0;
 	struct rxq_entry_t *rqe;
 
-	size = FIELD_GET(WILC_INTERRUPT_DATA_SIZE, int_status) << 2;
+	if (wilc->chip != WILC_S02)
+		size = FIELD_GET(WILC_INTERRUPT_DATA_SIZE, int_status) << 2;
+	else
+		size = int_status;
 
 	while (!size && retries < 10) {
 		wilc->hif_func->hif_read_size(wilc, &size);
-		size = FIELD_GET(WILC_INTERRUPT_DATA_SIZE, size) << 2;
+
+		if (wilc->chip != WILC_S02)
+			size = FIELD_GET(WILC_INTERRUPT_DATA_SIZE, size) << 2;
+
 		retries++;
 	}
 
@@ -1047,8 +1393,10 @@
 
 	wilc->hif_func->hif_clear_int_ext(wilc, DATA_INT_CLR | ENABLE_RX_VMM);
 	ret = wilc->hif_func->hif_block_rx_ext(wilc, 0, buffer, size);
-	if (ret)
+	if (ret) {
+		pr_err("%s: fail block rx\n", __func__);
 		return;
+	}
 
 	offset += size;
 	wilc->rx_buffer_offset = offset;
@@ -1066,18 +1414,24 @@
 {
 	u32 int_status;
 
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);
+	if (wilc->close)
+		return;
+
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
 	wilc->hif_func->hif_read_int(wilc, &int_status);
 
-	if (int_status & DATA_INT_EXT)
+	if (wilc->chip == WILC_S02 || (wilc->chip != WILC_S02 && int_status &
+				    DATA_INT_EXT))
 		wilc_wlan_handle_isr_ext(wilc, int_status);
 
-	if (!(int_status & (ALL_INT_EXT)))
+	if (wilc->chip != WILC_S02 && !(int_status & (ALL_INT_EXT))) {
+		pr_warn("%s,>> UNKNOWN_INTERRUPT - 0x%08x\n", __func__,
+			int_status);
 		wilc_unknown_isr_ext(wilc);
+	}
 
-	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
 }
-EXPORT_SYMBOL_GPL(wilc_handle_isr);
 
 int wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,
 				u32 buffer_size)
@@ -1087,6 +1441,7 @@
 	u8 *dma_buffer;
 	int ret = 0;
 	u32 reg = 0;
+	int timeout = CMD_RETRY_LIMIT;
 
 	blksz = BIT(12);
 
@@ -1097,21 +1452,29 @@
 	offset = 0;
 	pr_debug("%s: Downloading firmware size = %d\n", __func__, buffer_size);
 
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);
-
-	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
-	reg &= ~BIT(10);
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
-	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
-	if (reg & BIT(10))
-		pr_err("%s: Failed to reset\n", __func__);
 
-	release_bus(wilc, WILC_BUS_RELEASE_ONLY);
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
+	if (wilc->chip != WILC_S02) {
+		wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
+		reg &= ~BIT(10);
+		ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
+		wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
+		if (reg & BIT(10))
+			pr_err("%s: Failed to reset\n", __func__);
+	}
+	release_bus(wilc, WILC_BUS_RELEASE_ONLY, DEV_WIFI);
 	do {
-		addr = get_unaligned_le32(&buffer[offset]);
-		size = get_unaligned_le32(&buffer[offset + 4]);
-		acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);
-		offset += 8;
+		if (wilc->chip == WILC_S02) {
+			addr = wilc->vmm_ctl.vmm_tbl_fw_update_base;
+			size = buffer_size;
+			offset = 0;
+		} else {
+			addr = get_unaligned_le32(&buffer[offset]);
+			size = get_unaligned_le32(&buffer[offset + 4]);
+				offset += 8;
+		}
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
+
 		while (((int)size) && (offset < buffer_size)) {
 			if (size <= blksz)
 				size2 = size;
@@ -1124,11 +1487,49 @@
 			if (ret)
 				break;
 
-			addr += size2;
+			if (wilc->chip == WILC_S02) {
+				ret = wilc->hif_func->hif_write_reg(wilc,
+								    wilc->vmm_ctl.host_vmm_tx_ctl,
+								    WILC_S02_FW_UPGRADE | (offset << 8));
+				if (ret) {
+					pr_err("fail write reg host_vmm_ctl..\n");
+					ret = -EINVAL;
+					break;
+				}
+
+				timeout = 50000;
+				do {
+					ret = wilc->hif_func->hif_read_reg(wilc,
+							      wilc->vmm_ctl.host_vmm_rx_ctl,
+							      &reg);
+					if (ret)
+						break;
+
+					if ((reg >> 1) & 0x3)
+						break;
+
+				} while (--timeout);
+
+				if ((reg >> 1) & 0x2) {
+					pr_err("The best firmware already installed on WILCS02");
+					release_bus(wilc,
+						    WILC_BUS_RELEASE_ALLOW_SLEEP,
+						    DEV_WIFI);
+					goto fail;
+				}
+
+				if (timeout <= 0 || ret) {
+					pr_err("timeout = %d ret = %d..\n", timeout, ret);
+					ret = -EINVAL;
+					break;
+				}
+			} else {
+				addr += size2;
+			}
 			offset += size2;
 			size -= size2;
 		}
-		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
 
 		if (ret) {
 			pr_err("%s Bus error\n", __func__);
@@ -1137,10 +1538,28 @@
 		pr_debug("%s Offset = %d\n", __func__, offset);
 	} while (offset < buffer_size);
 
+	if (wilc->chip == WILC_S02) {
+		pr_err("FW reset after download");
+		ret = wilc_s02_reset_firmware(wilc, WILC_S02_SOFT_RESET | (WILC_S02_FLASH_RESET << 8));
+	}
 fail:
-
 	kfree(dma_buffer);
 
+	return (ret < 0) ? ret : 0;
+}
+
+int wilc_wlan_start_wilcs02_fw(struct wilc *wilc)
+{
+	u32 reg = 0;
+	int ret;
+
+	ret = wilc->hif_func->hif_write_reg(wilc,
+					    WILC_HOST_GP_REG,
+					    (WILC_MSG_MAC_OPEN | ((reg & GENMASK(15, 0)) < 16)));
+	if (ret)
+		pr_err("fail write reg host_vmm_ctl");
+	pr_info("%s start firmware response [%d]", __func__, ret);
+
 	return ret;
 }
 
@@ -1150,21 +1569,25 @@
 	int ret;
 	u32 chipid;
 
-	if (wilc->io_type == WILC_HIF_SDIO) {
+	if (wilc->io_type == WILC_HIF_SDIO ||
+	    wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
 		reg = 0;
 		reg |= BIT(3);
 	} else if (wilc->io_type == WILC_HIF_SPI) {
 		reg = 1;
 	}
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
 	ret = wilc->hif_func->hif_write_reg(wilc, WILC_VMM_CORE_CFG, reg);
 	if (ret)
 		goto release;
 
 	reg = 0;
-	if (wilc->io_type == WILC_HIF_SDIO && wilc->dev_irq_num)
+	if (wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ)
 		reg |= WILC_HAVE_SDIO_IRQ_GPIO;
 
+	if (wilc->chip == WILC_3000)
+		reg |= WILC_HAVE_SLEEP_CLK_SRC_RTC;
+
 	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_1, reg);
 	if (ret)
 		goto release;
@@ -1187,7 +1610,7 @@
 	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
 
 release:
-	release_bus(wilc, WILC_BUS_RELEASE_ONLY);
+	release_bus(wilc, WILC_BUS_RELEASE_ONLY, DEV_WIFI);
 	return ret;
 }
 
@@ -1196,29 +1619,44 @@
 	u32 reg = 0;
 	int ret;
 
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);
+	if (wilc->chip == WILC_S02) {
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
+		ret = wilc->hif_func->hif_write_reg(wilc,  WILC_HOST_GP_REG, WILC_MSG_MAC_CLOSE);
+		if (ret)
+			pr_err("fail write reg host_vmm_ctl..\n");
 
-	ret = wilc->hif_func->hif_read_reg(wilc, WILC_GP_REG_0, &reg);
-	if (ret) {
-		netdev_err(vif->ndev, "Error while reading reg\n");
-		goto release;
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+		return ret;
 	}
 
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_0,
-					(reg | WILC_ABORT_REQ_BIT));
-	if (ret) {
-		netdev_err(vif->ndev, "Error while writing reg\n");
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
+
+	ret = wilc->hif_func->hif_read_reg(wilc, GLOBAL_MODE_CONTROL, &reg);
+	if (ret)
 		goto release;
-	}
 
-	ret = wilc->hif_func->hif_read_reg(wilc, WILC_FW_HOST_COMM, &reg);
+	reg &= ~WILC_GLOBAL_MODE_ENABLE_WIFI;
+	ret = wilc->hif_func->hif_write_reg(wilc, GLOBAL_MODE_CONTROL, reg);
+	if (ret)
+		goto release;
+
+	ret = wilc->hif_func->hif_read_reg(wilc, PWR_SEQ_MISC_CTRL, &reg);
+	if (ret)
+		goto release;
+
+	reg &= ~WILC_PWR_SEQ_ENABLE_WIFI_SLEEP;
+	ret = wilc->hif_func->hif_write_reg(wilc, PWR_SEQ_MISC_CTRL, reg);
+	if (ret)
+		goto release;
+
+	ret = wilc->hif_func->hif_read_reg(wilc, WILC_GP_REG_0, &reg);
 	if (ret) {
 		netdev_err(vif->ndev, "Error while reading reg\n");
 		goto release;
 	}
-	reg = BIT(0);
 
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_FW_HOST_COMM, reg);
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_0,
+					(reg | WILC_ABORT_REQ_BIT));
 	if (ret) {
 		netdev_err(vif->ndev, "Error while writing reg\n");
 		goto release;
@@ -1227,7 +1665,7 @@
 	ret = 0;
 release:
 	/* host comm is disabled - we can't issue sleep command anymore: */
-	release_bus(wilc, WILC_BUS_RELEASE_ONLY);
+	release_bus(wilc, WILC_BUS_RELEASE_ONLY, DEV_WIFI);
 
 	return ret;
 }
@@ -1258,7 +1696,6 @@
 	wilc->rx_buffer = NULL;
 	kfree(wilc->tx_buffer);
 	wilc->tx_buffer = NULL;
-	wilc->hif_func->hif_deinit(wilc);
 }
 
 static int wilc_wlan_cfg_commit(struct wilc_vif *vif, int type,
@@ -1307,7 +1744,9 @@
 		return ret_size;
 	}
 
-	netdev_dbg(vif->ndev, "%s: seqno[%d]\n", __func__, wilc->cfg_seq_no);
+	PRINT_INFO(vif->ndev, TX_DBG,
+		   "[WILC]PACKET Commit with sequence number%d\n",
+		   wilc->cfg_seq_no);
 
 	if (wilc_wlan_cfg_commit(vif, WILC_CFG_SET, drv_handler))
 		ret_size = 0;
@@ -1362,6 +1801,7 @@
 	return ret_size;
 }
 
+unsigned int cfg_packet_timeout;
 int wilc_send_config_pkt(struct wilc_vif *vif, u8 mode, struct wid *wids,
 			 u32 count)
 {
@@ -1369,13 +1809,30 @@
 	int ret = 0;
 	u32 drv = wilc_get_vif_idx(vif);
 
+#ifdef WILC_S02_TEST_BUS_INTERFACE
+	if (is_test_mode && test_in_progress)
+		return 0;
+#endif
+
+
+	if (wait_for_recovery) {
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   "Host interface is suspended\n");
+		while (wait_for_recovery)
+			msleep(300);
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   "Host interface is resumed\n");
+	}
+
 	if (mode == WILC_GET_CFG) {
 		for (i = 0; i < count; i++) {
-			if (!wilc_wlan_cfg_get(vif, !i,
-					       wids[i].id,
-					       (i == count - 1),
-					       drv)) {
+			PRINT_D(vif->ndev, CORECONFIG_DBG,
+				"Sending CFG packet [%d][%d]\n", !i,
+				(i == count - 1));
+			if (!wilc_wlan_cfg_get(vif, !i, wids[i].id,
+					       (i == count - 1), drv)) {
 				ret = -ETIMEDOUT;
+				PRINT_ER(vif->ndev, "Get Timed out\n");
 				break;
 			}
 		}
@@ -1387,17 +1844,52 @@
 		}
 	} else if (mode == WILC_SET_CFG) {
 		for (i = 0; i < count; i++) {
-			if (!wilc_wlan_cfg_set(vif, !i,
-					       wids[i].id,
-					       wids[i].val,
+			PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+				   "Sending config SET PACKET WID:%x\n",
+				   wids[i].id);
+			if (!wilc_wlan_cfg_set(vif, !i, wids[i].id, wids[i].val,
 					       wids[i].size,
-					       (i == count - 1),
-					       drv)) {
+					       (i == count - 1), drv)) {
 				ret = -ETIMEDOUT;
+				PRINT_ER(vif->ndev, "Set Timed out\n");
 				break;
 			}
 		}
 	}
+	cfg_packet_timeout = (ret < 0) ? cfg_packet_timeout + 1 : 0;
+	return ret;
+}
+
+int wilcs02_init_vmm_registers(struct wilc *wilc)
+{
+	u32 reg;
+	int ret = 0;
+
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
+
+	wilc->vmm_ctl.host_vmm_tx_ctl = WILC_HOST_GP_REG;
+	wilc->vmm_ctl.host_vmm_rx_ctl = WILC_ARM_GP_REG;
+	wilc->vmm_ctl.host_rx_ctl = WILC_ARM_GP_REG;
+	wilc->vmm_ctl.host_tx_ctl = WILC_HOST_GP_REG;
+	wilc->vmm_ctl.host_wmm_stat = WILC_S02_REG_ADDR_WMM_STAT;
+	ret = wilc->hif_func->hif_read_reg(wilc, WILC_S02_REG_ADDR_SHADOW_RX_TBL,
+					   &reg);
+	if (ret) {
+		pr_err("fail read reg WILC_S02_REG_ADDR_SHADOW_RX_TBL\n");
+		goto end;
+	}
+
+	wilc->vmm_ctl.vmm_tbl_rx_shadow_base = reg;
+
+	ret = wilc->hif_func->hif_read_reg(wilc, WILC_S02_REG_ADDR_FW_UPDATE,
+					   &reg);
+	if (ret) {
+		pr_err("fail read reg WILC_S02_REG_ADDR_FW_UPDATE\n");
+		goto end;
+	}
+	wilc->vmm_ctl.vmm_tbl_fw_update_base = reg;
+end:
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
 
 	return ret;
 }
@@ -1410,64 +1902,92 @@
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wilc = vif->wilc;
 
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
 
 	chipid = wilc_get_chipid(wilc, true);
 
-	if ((chipid & 0xfff) != 0xa0) {
-		ret = wilc->hif_func->hif_read_reg(wilc,
-						   WILC_CORTUS_RESET_MUX_SEL,
-						   &reg);
-		if (ret) {
-			netdev_err(dev, "fail read reg 0x1118\n");
-			goto release;
-		}
-		reg |= BIT(0);
-		ret = wilc->hif_func->hif_write_reg(wilc,
-						    WILC_CORTUS_RESET_MUX_SEL,
-						    reg);
-		if (ret) {
-			netdev_err(dev, "fail write reg 0x1118\n");
-			goto release;
-		}
-		ret = wilc->hif_func->hif_write_reg(wilc,
-						    WILC_CORTUS_BOOT_REGISTER,
-						    WILC_CORTUS_BOOT_FROM_IRAM);
+	if (wilc->chip == WILC_S02) /* chip is initialized in probe */
+		goto end;
+
+	ret = wilc->hif_func->hif_read_reg(wilc, WILC_CORTUS_RESET_MUX_SEL,
+					   &reg);
+	if (ret) {
+		pr_err("fail read reg 0x1118\n");
+		goto end;
+	}
+
+	reg |= BIT(0);
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_CORTUS_RESET_MUX_SEL,
+					    reg);
+	if (ret) {
+		pr_err("fail write reg 0x1118\n");
+		goto end;
+	}
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_CORTUS_BOOT_REGISTER,
+					    WILC_CORTUS_BOOT_FROM_IRAM);
+	if (ret) {
+		pr_err("fail write reg 0xc0000 ...\n");
+		goto end;
+	}
+
+	if (wilc->chip == WILC_3000) {
+		ret = wilc->hif_func->hif_read_reg(wilc, 0x207ac, &reg);
+		PRINT_INFO(vif->ndev, INIT_DBG, "Bootrom sts = %x\n", reg);
+		ret = wilc->hif_func->hif_write_reg(wilc, 0x4f0000,
+						    0x71);
 		if (ret) {
-			netdev_err(dev, "fail write reg 0xc0000\n");
-			goto release;
+			pr_err("fail write reg 0x4f0000 ...\n");
+			goto end;
 		}
 	}
 
-release:
-	release_bus(wilc, WILC_BUS_RELEASE_ONLY);
+	wilc->vmm_ctl.host_vmm_tx_ctl = WILC_HOST_VMM_CTL;
+	wilc->vmm_ctl.host_vmm_rx_ctl = WILC_HOST_VMM_CTL;
+	wilc->vmm_ctl.host_tx_ctl = WILC_HOST_TX_CTRL;
+	wilc->vmm_ctl.host_rx_ctl = WILC_HOST_RX_CTRL;
+	wilc->vmm_ctl.vmm_tbl_rx_shadow_base = WILC_VMM_TBL_RX_SHADOW_BASE;
+	wilc->vmm_ctl.host_wmm_stat = WILC_HOST_TX_CTRL;
+
+end:
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
 
 	return ret;
 }
 
 u32 wilc_get_chipid(struct wilc *wilc, bool update)
 {
+	int ret;
 	u32 chipid = 0;
 	u32 rfrevid = 0;
 
 	if (wilc->chipid == 0 || update) {
-		wilc->hif_func->hif_read_reg(wilc, WILC_CHIPID, &chipid);
-		wilc->hif_func->hif_read_reg(wilc, WILC_RF_REVISION_ID,
-					     &rfrevid);
-		if (!is_wilc1000(chipid)) {
-			wilc->chipid = 0;
+		wilc->hif_func->hif_read_reg(wilc, WILC_S02_CHIP_ID, &chipid);
+		if (is_wilcs02_chip(chipid)) {
+			wilc->chipid = chipid;
 			return wilc->chipid;
 		}
-		if (chipid == WILC_1000_BASE_ID_2A) { /* 0x1002A0 */
-			if (rfrevid != 0x1)
-				chipid = WILC_1000_BASE_ID_2A_REV1;
-		} else if (chipid == WILC_1000_BASE_ID_2B) { /* 0x1002B0 */
-			if (rfrevid == 0x4)
-				chipid = WILC_1000_BASE_ID_2B_REV1;
-			else if (rfrevid != 0x3)
-				chipid = WILC_1000_BASE_ID_2B_REV2;
-		}
 
+		ret = wilc->hif_func->hif_read_reg(wilc, WILC3000_CHIP_ID,
+						   &chipid);
+		if (!is_wilc3000(chipid)) {
+			wilc->hif_func->hif_read_reg(wilc, WILC_CHIPID, &chipid);
+			wilc->hif_func->hif_read_reg(wilc, WILC_RF_REVISION_ID,
+						     &rfrevid);
+
+			if (!is_wilc1000(chipid)) {
+				wilc->chipid = 0;
+				return wilc->chipid;
+			}
+			if (chipid == WILC_1000_BASE_ID_2A) { /* 0x1002A0 */
+				if (rfrevid != 0x1)
+					chipid = WILC_1000_BASE_ID_2A_REV1;
+			} else if (chipid == WILC_1000_BASE_ID_2B) { /* 0x1002B0 */
+				if (rfrevid == 0x4)
+					chipid = WILC_1000_BASE_ID_2B_REV1;
+				else if (rfrevid != 0x3)
+					chipid = WILC_1000_BASE_ID_2B_REV2;
+			}
+		}
 		wilc->chipid = chipid;
 	}
 	return wilc->chipid;
@@ -1483,10 +2003,12 @@
 
 	wilc->quit = 0;
 
+	PRINT_INFO(vif->ndev, INIT_DBG, "Initializing WILC_Wlan\n");
+
 	if (!wilc->hif_func->hif_is_init(wilc)) {
-		acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY, DEV_WIFI);
 		ret = wilc->hif_func->hif_init(wilc, false);
-		release_bus(wilc, WILC_BUS_RELEASE_ONLY);
+		release_bus(wilc, WILC_BUS_RELEASE_ONLY, DEV_WIFI);
 		if (ret)
 			goto fail;
 	}
@@ -1504,14 +2026,16 @@
 
 	if (!wilc->tx_buffer) {
 		ret = -ENOBUFS;
+		PRINT_ER(vif->ndev, "Can't allocate Tx Buffer");
 		goto fail;
 	}
 
 	if (!wilc->rx_buffer)
 		wilc->rx_buffer = kmalloc(WILC_RX_BUFF_SIZE, GFP_KERNEL);
-
+	PRINT_D(vif->ndev, TX_DBG, "g_wlan.rx_buffer =%p\n", wilc->rx_buffer);
 	if (!wilc->rx_buffer) {
 		ret = -ENOBUFS;
+		PRINT_ER(vif->ndev, "Can't allocate Rx Buffer");
 		goto fail;
 	}
 
--- linux-6.6.51/drivers/net/wireless/microchip/wilc1000/wlan.h	2024-12-05 13:07:51.232693800 +0900
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/wlan.h	2024-12-04 16:41:31.560529100 +0900
@@ -38,6 +38,8 @@
 
 #define ETH_CONFIG_PKT_HDR_OFFSET	(ETH_ETHERNET_HDR_OFFSET + \
 					 ETH_CONFIG_PKT_HDR_LEN)
+#define PKT_STATUS_NEW          0
+#define PKT_STATUS_BUFFERED     1
 
 /********************************************
  *
@@ -45,7 +47,6 @@
  *
  ********************************************/
 #define WILC_PERIPH_REG_BASE		0x1000
-#define WILC_CHANGING_VIR_IF		0x108c
 #define WILC_CHIPID			WILC_PERIPH_REG_BASE
 #define WILC_GLB_RESET_0		(WILC_PERIPH_REG_BASE + 0x400)
 #define WILC_PIN_MUX_0			(WILC_PERIPH_REG_BASE + 0x408)
@@ -53,11 +54,25 @@
 #define WILC_HOST_RX_CTRL_0		(WILC_PERIPH_REG_BASE + 0x70)
 #define WILC_HOST_RX_CTRL_1		(WILC_PERIPH_REG_BASE + 0x74)
 #define WILC_HOST_VMM_CTL		(WILC_PERIPH_REG_BASE + 0x78)
+#define WILC_HOST_GP_REG		0x24
+#define WILC_ARM_GP_REG			0x28
+#define WILC_MSG_MAC_OPEN		(0x1 | (0x1 << 8))
+#define WILC_MSG_MAC_CLOSE		(0x1 | (0x2 << 8))
+#define WILC_MSG_MAC_RESET		(0x1 | (0x3 << 8))
+
 #define WILC_HOST_RX_CTRL		(WILC_PERIPH_REG_BASE + 0x80)
 #define WILC_HOST_RX_EXTRA_SIZE		(WILC_PERIPH_REG_BASE + 0x84)
 #define WILC_HOST_TX_CTRL_1		(WILC_PERIPH_REG_BASE + 0x88)
 #define WILC_MISC			(WILC_PERIPH_REG_BASE + 0x428)
 #define WILC_INTR_REG_BASE		(WILC_PERIPH_REG_BASE + 0xa00)
+
+#define WILC_INTERRUPT_CORTUS_0		(WILC_PERIPH_REG_BASE + 0xa8)
+#define WILC1000_CORTUS_INTERRUPT_1	(WILC_INTERRUPT_CORTUS_0 + 0x4)
+#define WILC3000_CORTUS_INTERRUPT_1	(WILC_INTERRUPT_CORTUS_0 + 0x14)
+
+#define WILC1000_CORTUS_INTERRUPT_2	(WILC_INTERRUPT_CORTUS_0 + 0x8)
+#define WILC3000_CORTUS_INTERRUPT_2	(WILC_INTERRUPT_CORTUS_0 + 0x18)
+
 #define WILC_INTR_ENABLE		WILC_INTR_REG_BASE
 #define WILC_INTR2_ENABLE		(WILC_INTR_REG_BASE + 4)
 
@@ -94,11 +109,20 @@
 #define WILC_SPI_INT_STATUS		(WILC_SPI_REG_BASE + 0x40)
 #define WILC_SPI_INT_CLEAR		(WILC_SPI_REG_BASE + 0x44)
 
-#define WILC_SPI_WAKEUP_REG		0x1
-#define WILC_SPI_WAKEUP_BIT		BIT(1)
+/* WILC1000 specific */
+#define WILC1000_SPI_WAKEUP_REG	0x1
+#define WILC1000_SPI_WAKEUP_BIT	BIT(1)
+
+#define WILC1000_SPI_CLK_STATUS_REG	0x0f
+#define WILC1000_SPI_CLK_STATUS_BIT	BIT(2)
+
+/* WILC3000 specific */
+#define WILC3000_SPI_WAKEUP_REG	0x1
+#define WILC3000_SPI_WAKEUP_BIT	BIT(1)
+
+#define WILC3000_SPI_CLK_STATUS_REG	0x13
+#define WILC3000_SPI_CLK_STATUS_BIT	BIT(2)
 
-#define WILC_SPI_CLK_STATUS_REG        0x0f
-#define WILC_SPI_CLK_STATUS_BIT        BIT(2)
 #define WILC_SPI_HOST_TO_FW_REG		0x0b
 #define WILC_SPI_HOST_TO_FW_BIT		BIT(0)
 
@@ -121,17 +145,31 @@
 #define WILC_SDIO_CCCR_ABORT_RESET	BIT(3)
 
 /* Vendor specific CCCR registers */
-#define WILC_SDIO_WAKEUP_REG		0xf0
-#define WILC_SDIO_WAKEUP_BIT		BIT(0)
+/* WILC1000 */
+#define WILC1000_SDIO_WAKEUP_REG	0xf0
+#define WILC1000_SDIO_WAKEUP_BIT	BIT(0)
+
+#define WILC1000_SDIO_CLK_STATUS_REG	0xf1
+#define WILC1000_SDIO_CLK_STATUS_BIT	BIT(0)
+
+#define WILC1000_SDIO_IRQ_FLAG_REG	0xf7
+#define WILC1000_SDIO_IRQ_CLEAR_FLAG_REG	0xf8
 
-#define WILC_SDIO_CLK_STATUS_REG	0xf1
-#define WILC_SDIO_CLK_STATUS_BIT	BIT(0)
+/* WILC3000 specific */
+#define WILC3000_SDIO_WAKEUP_REG	0xf0
+#define WILC3000_SDIO_WAKEUP_BIT	BIT(0)
 
+#define WILC3000_SDIO_CLK_STATUS_REG	0xf0 /* clk & wakeup are on same reg*/
+#define WILC3000_SDIO_CLK_STATUS_BIT	BIT(4)
+
+#define WILC3000_SDIO_IRQ_FLAG_REG	0xfe
+#define WILC3000_SDIO_IRQ_CLEAR_FLAG_REG	0xfe
+#define WILC3000_SDIO_VMM_TBL_CTRL_REG	0xf1
+
+/* Common vendor specific CCCR register */
 #define WILC_SDIO_INTERRUPT_DATA_SZ_REG	0xf2 /* Read size (2 bytes) */
 
 #define WILC_SDIO_VMM_TBL_CTRL_REG	0xf6
-#define WILC_SDIO_IRQ_FLAG_REG		0xf7
-#define WILC_SDIO_IRQ_CLEAR_FLAG_REG	0xf8
 
 #define WILC_SDIO_HOST_TO_FW_REG	0xfa
 #define WILC_SDIO_HOST_TO_FW_BIT	BIT(0)
@@ -151,24 +189,26 @@
 
 #define WILC_VMM_TBL_RX_SHADOW_BASE	WILC_AHB_SHARE_MEM_BASE
 #define WILC_VMM_TBL_RX_SHADOW_SIZE	256
+#define VMM_TBL_RX_SHADOW_BASE   	0xA0420
+#define VMM_TBL_RX_SHADOW_SIZE		256
 
-#define WILC_FW_HOST_COMM		0x13c0
 #define WILC_GP_REG_0			0x149c
 #define WILC_GP_REG_1			0x14a0
 
+#define GLOBAL_MODE_CONTROL		0x1614
+#define PWR_SEQ_MISC_CTRL		0x3008
+
+#define WILC_GLOBAL_MODE_ENABLE_WIFI	BIT(0)
+#define WILC_PWR_SEQ_ENABLE_WIFI_SLEEP	BIT(28)
+
+#define COE_AUTO_PS_ON_NULL_PKT		0x160468
+#define COE_AUTO_PS_OFF_NULL_PKT	0x16046C
+#define CCA_CTL_2 (0x160EF4)
+#define CCA_CTL_7 (0x160F08)
+
 #define WILC_HAVE_SDIO_IRQ_GPIO		BIT(0)
-#define WILC_HAVE_USE_PMU		BIT(1)
 #define WILC_HAVE_SLEEP_CLK_SRC_RTC	BIT(2)
 #define WILC_HAVE_SLEEP_CLK_SRC_XO	BIT(3)
-#define WILC_HAVE_EXT_PA_INV_TX_RX	BIT(4)
-#define WILC_HAVE_LEGACY_RF_SETTINGS	BIT(5)
-#define WILC_HAVE_XTAL_24		BIT(6)
-#define WILC_HAVE_DISABLE_WILC_UART	BIT(7)
-#define WILC_HAVE_USE_IRQ_AS_HOST_WAKE	BIT(8)
-
-#define WILC_CORTUS_INTERRUPT_BASE	0x10A8
-#define WILC_CORTUS_INTERRUPT_1		(WILC_CORTUS_INTERRUPT_BASE + 0x4)
-#define WILC_CORTUS_INTERRUPT_2		(WILC_CORTUS_INTERRUPT_BASE + 0x8)
 
 /* tx control register 1 to 4 for RX */
 #define WILC_REG_4_TO_1_RX		0x1e1c
@@ -178,6 +218,30 @@
 
 #define WILC_CORTUS_RESET_MUX_SEL	0x1118
 #define WILC_CORTUS_BOOT_REGISTER	0xc0000
+#define WILC3000_CHIP_ID		0x3b0000
+#define WILC_S02_CHIP_ID		0x1
+#define WILC_S02_FW_VERSION		0x2
+
+/* WILC_S02- MSG Handler */
+#define WILC_S02_CANCEL_RX		0x0
+#define WILC_S02_START_WLAN		0x1
+#define WILC_S02_HOST_MALLOC		0x2
+#define WILC_S02_FW_UPGRADE		0x3
+#define WILC_S02_SOFT_RESET		0x4
+#define WILC_S02_SDIO_TEST		0x6
+#define WILC_S02_SDIO_VMM_CLEAR		0x7
+#define WILC_S02_REG_ADDR_WMM_STAT	0x9
+
+/* type of soft resets */
+#define WILC_S02_RAM_RESET		BIT(0)
+#define WILC_S02_FLASH_RESET		BIT(1)
+#define WILC_S02_WLAN_RESET		BIT(2)
+
+#define WILC_S02_REG_ADDR_FW_UPDATE	0x5
+#define WILC_S02_REG_ADDR_SHADOW_RX_TBL	0x6
+
+#define WILC_S02_REG_ADDR_CFG		0x8
+
 
 #define WILC_CORTUS_BOOT_FROM_IRAM	0x71
 
@@ -190,8 +254,28 @@
 #define WILC_1000_BASE_ID_2B_REV1	(WILC_1000_BASE_ID_2B + 1)
 #define WILC_1000_BASE_ID_2B_REV2	(WILC_1000_BASE_ID_2B + 2)
 
+#define WILC_3000_BASE_ID		0x300000
+#define WILC_S02_BASE_ID		0x000053
+
+
 #define WILC_CHIP_REV_FIELD		GENMASK(11, 0)
 
+static inline bool is_wilc1000(u32 id)
+{
+	return (id & (~WILC_CHIP_REV_FIELD)) == WILC_1000_BASE_ID;
+}
+
+static inline bool is_wilc3000(u32 id)
+{
+	return (id & (~WILC_CHIP_REV_FIELD)) == WILC_3000_BASE_ID;
+}
+
+static inline bool is_wilcs02_chip(u32 id)
+{
+	return (id & (WILC_CHIP_REV_FIELD)) == WILC_S02_BASE_ID;
+}
+
+
 /********************************************
  *
  *      Wlan Defines
@@ -213,7 +297,11 @@
 #define WILC_RX_BUFF_SIZE	(96 * 1024)
 #define WILC_TX_BUFF_SIZE	(64 * 1024)
 
+#define GPIO_NUM_CHIP_EN	94
+#define GPIO_NUM_RESET		60
+
 #define NQUEUES			4
+#define ECDA_MAX_LIMIT		32
 #define AC_BUFFER_SIZE		1000
 
 #define VO_AC_COUNT_FIELD		GENMASK(31, 25)
@@ -262,7 +350,6 @@
 #define INT_2			BIT(IRG_FLAGS_OFFSET + 2)
 #define INT_3			BIT(IRG_FLAGS_OFFSET + 3)
 #define INT_4			BIT(IRG_FLAGS_OFFSET + 4)
-#define INT_5			BIT(IRG_FLAGS_OFFSET + 5)
 #define MAX_NUM_INT		5
 #define IRG_FLAGS_MASK		GENMASK(IRG_FLAGS_OFFSET + MAX_NUM_INT, \
 					IRG_FLAGS_OFFSET)
@@ -297,7 +384,11 @@
 
 #define DATA_INT_CLR		CLR_INT0
 
+#define SDIO_MSG_VMM_INT_CLR	0x7
+
 #define ENABLE_RX_VMM		(SEL_VMM_TBL1 | EN_VMM)
+#define DISBLE_RX_VMM		(SDIO_MSG_VMM_INT_CLR | 1 << 8)
+#define DISBLE_TX_VMM		(SDIO_MSG_VMM_INT_CLR | 2 << 8)
 #define ENABLE_TX_VMM		(SEL_VMM_TBL0 | EN_VMM)
 /* time for expiring the completion of cfg packets */
 #define WILC_CFG_PKTS_TIMEOUT	msecs_to_jiffies(3000)
@@ -306,6 +397,7 @@
 #define IS_MANAGMEMENT_CALLBACK	0x080
 #define IS_MGMT_STATUS_SUCCES	0x040
 #define IS_MGMT_AUTH_PKT       0x010
+#define IS_MON_PKT		0x020
 
 #define WILC_WID_TYPE		GENMASK(15, 12)
 #define WILC_VMM_ENTRY_FULL_RETRY	1
@@ -351,6 +443,22 @@
 	int buffer_size;
 };
 
+enum wilc_chip_type {
+	WILC_1000,
+	WILC_3000,
+	WILC_S02,
+};
+
+struct wilc_vmm_ctl {
+	u32 vmm_tbl_rx_shadow_base;
+	u32 vmm_tbl_fw_update_base;
+	u32 host_vmm_rx_ctl;
+	u32 host_vmm_tx_ctl;
+	u32 host_tx_ctl;
+	u32 host_rx_ctl;
+	u32 host_wmm_stat;
+};
+
 /********************************************
  *
  *      Host IF Structure
@@ -374,6 +482,7 @@
 	void (*disable_interrupt)(struct wilc *nic);
 	int (*hif_reset)(struct wilc *wilc);
 	bool (*hif_is_init)(struct wilc *wilc);
+	int (*hif_clear_init)(struct wilc *wilc);
 };
 
 #define WILC_MAX_CFG_FRAME_SIZE		1468
@@ -406,12 +515,14 @@
 int wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,
 				u32 buffer_size);
 int wilc_wlan_start(struct wilc *wilc);
+int wilc_wlan_start_wilcs02_fw(struct wilc *wilc);
 int wilc_wlan_stop(struct wilc *wilc, struct wilc_vif *vif);
 int wilc_wlan_txq_add_net_pkt(struct net_device *dev,
 			      struct tx_complete_data *tx_data, u8 *buffer,
 			      u32 buffer_size,
 			      void (*tx_complete_fn)(void *, int));
 int wilc_wlan_handle_txq(struct wilc *wl, u32 *txq_count);
+void wilc_wfi_handle_monitor_rx(struct wilc *wilc, u8 *buff, u32 size);
 void wilc_handle_isr(struct wilc *wilc);
 void wilc_wlan_cleanup(struct net_device *dev);
 int wilc_wlan_cfg_set(struct wilc_vif *vif, int start, u16 wid, u8 *buffer,
@@ -421,17 +532,22 @@
 int wilc_wlan_txq_add_mgmt_pkt(struct net_device *dev, void *priv, u8 *buffer,
 			       u32 buffer_size, void (*func)(void *, int));
 void wilc_enable_tcp_ack_filter(struct wilc_vif *vif, bool value);
-int wilc_wlan_get_num_conn_ifcs(struct wilc *wilc);
 netdev_tx_t wilc_mac_xmit(struct sk_buff *skb, struct net_device *dev);
 
-void wilc_wfi_p2p_rx(struct wilc_vif *vif, u8 *buff, u32 size);
+bool wilc_wfi_p2p_rx(struct wilc_vif *vif, u8 *buff, u32 size);
 bool wilc_wfi_mgmt_frame_rx(struct wilc_vif *vif, u8 *buff, u32 size);
-void host_wakeup_notify(struct wilc *wilc);
-void host_sleep_notify(struct wilc *wilc);
-void chip_allow_sleep(struct wilc *wilc);
-void chip_wakeup(struct wilc *wilc);
+void host_wakeup_notify(struct wilc *wilc, int source);
+void host_sleep_notify(struct wilc *wilc, int source);
+void chip_allow_sleep(struct wilc *wilc, int source);
+void chip_wakeup(struct wilc *wilc, int source);
 int wilc_send_config_pkt(struct wilc_vif *vif, u8 mode, struct wid *wids,
 			 u32 count);
+void wilc_bt_init(struct wilc *wilc);
+void wilc_bt_deinit(void);
+void eap_buff_timeout(struct timer_list *t);
+void acquire_bus(struct wilc *wilc, enum bus_acquire acquire, int source);
+void release_bus(struct wilc *wilc, enum bus_release release, int source);
 int wilc_wlan_init(struct net_device *dev);
 u32 wilc_get_chipid(struct wilc *wilc, bool update);
+int wilcs02_init_vmm_registers(struct wilc *wilc);
 #endif
--- linux-6.6.51/drivers/net/wireless/microchip/wilc1000/wlan_cfg.c	2024-12-05 13:07:51.232693800 +0900
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/wlan_cfg.c	2024-12-04 16:41:31.560529100 +0900
@@ -47,6 +47,11 @@
 	{WID_NIL, NULL}
 };
 
+static const struct wilc_cfg_bin g_cfg_bin[] = {
+	{WID_ANTENNA_SELECTION, NULL},
+	{WID_NIL, NULL}
+};
+
 #define WILC_RESP_MSG_TYPE_CONFIG_REPLY		'R'
 #define WILC_RESP_MSG_TYPE_STATUS_INFO		'I'
 #define WILC_RESP_MSG_TYPE_NETWORK_INFO		'N'
@@ -186,7 +191,40 @@
 
 			len = 2 + get_unaligned_le16(&info[2]);
 			break;
+		case WID_BIN_DATA:
+			while (cfg->bin[i].id != WID_NIL &&
+			       cfg->bin[i].id != wid)
+				i++;
 
+			if (cfg->bin[i].id == wid) {
+				u16 length = (info[3] << 8) | info[2];
+				u8 checksum = 0;
+				int j = 0;
+
+				/*
+				 * Compute the Checksum of received
+				 * data field
+				 */
+				for (j = 0; j < length; j++)
+					checksum += info[4 + j];
+				/*
+				 * Verify the checksum of received BIN
+				 * DATA
+				 */
+				if (checksum != info[4 + length]) {
+					pr_err("%s: Checksum Failed\n",
+					       __func__);
+					return;
+				}
+
+				memcpy(cfg->bin[i].bin, &info[2], length + 2);
+				/*
+				 * value length + data length +
+				 * checksum
+				 */
+				len = 2 + length + 1;
+			}
+			break;
 		default:
 			break;
 		}
@@ -310,6 +348,21 @@
 				ret = size;
 			}
 		}
+	} else if (type == CFG_BIN_CMD) { /* binary command */
+		while (cfg->bin[i].id != WID_NIL && cfg->bin[i].id != wid)
+			i++;
+
+		if (cfg->bin[i].id == wid) {
+			u32 size = cfg->bin[i].bin[0] |
+				(cfg->bin[i].bin[1] << 8);
+
+			if (buffer_size >= size) {
+				memcpy(buffer, &cfg->bin[i].bin[2], size);
+				ret = size;
+			}
+		}
+	} else {
+		pr_err("[CFG]: illegal type (%08x)\n", wid);
 	}
 	return ret;
 }
@@ -358,6 +411,7 @@
 int wilc_wlan_cfg_init(struct wilc *wl)
 {
 	struct wilc_cfg_str_vals *str_vals;
+	struct wilc_bin_vals *bin_vals;
 	int i = 0;
 
 	wl->cfg.b = kmemdup(g_cfg_byte, sizeof(g_cfg_byte), GFP_KERNEL);
@@ -380,6 +434,15 @@
 	if (!str_vals)
 		goto out_s;
 
+	wl->cfg.bin = kmemdup(g_cfg_bin, sizeof(g_cfg_bin), GFP_KERNEL);
+	if (!wl->cfg.bin)
+		goto out_str_val;
+
+	bin_vals = kzalloc(sizeof(*bin_vals), GFP_KERNEL);
+	if (!bin_vals)
+		goto out_bin;
+
+	/* store the string cfg parameters */
 	wl->cfg.str_vals = str_vals;
 	/* store the string cfg parameters */
 	wl->cfg.s[i].id = WID_FIRMWARE_VERSION;
@@ -393,8 +456,22 @@
 	i++;
 	wl->cfg.s[i].id = WID_NIL;
 	wl->cfg.s[i].str = NULL;
+
+	/* store the bin parameters */
+	i = 0;
+	wl->cfg.bin[i].id = WID_ANTENNA_SELECTION;
+	wl->cfg.bin[i].bin = bin_vals->antenna_param;
+	i++;
+
+	wl->cfg.bin[i].id = WID_NIL;
+	wl->cfg.bin[i].bin = NULL;
+
 	return 0;
 
+out_bin:
+	kfree(wl->cfg.bin);
+out_str_val:
+	kfree(str_vals);
 out_s:
 	kfree(wl->cfg.s);
 out_w:
@@ -413,4 +490,6 @@
 	kfree(wl->cfg.w);
 	kfree(wl->cfg.s);
 	kfree(wl->cfg.str_vals);
+	kfree(wl->cfg.bin);
+	kfree(wl->cfg.bin_vals);
 }
--- linux-6.6.51/drivers/net/wireless/microchip/wilc1000/wlan_cfg.h	2024-12-05 13:07:51.233690900 +0900
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/wlan_cfg.h	2024-12-04 16:41:31.561526500 +0900
@@ -27,20 +27,31 @@
 	u8 *str;
 };
 
+struct wilc_cfg_bin {
+	u16 id;
+	u8 *bin;
+};
+
 struct wilc_cfg_str_vals {
 	u8 mac_address[7];
 	u8 firmware_version[129];
 	u8 assoc_rsp[WILC_MAX_ASSOC_RESP_FRAME_SIZE];
 };
 
+struct wilc_bin_vals {
+	u8 antenna_param[5];
+};
+
 struct wilc_cfg {
 	struct wilc_cfg_byte *b;
 	struct wilc_cfg_hword *hw;
 	struct wilc_cfg_word *w;
 	struct wilc_cfg_str *s;
 	struct wilc_cfg_str_vals *str_vals;
+	struct wilc_cfg_bin *bin;
+	struct wilc_bin_vals *bin_vals;
 };
-
+//#define WILCS02_TEST_BUS_INTERFACE
 struct wilc;
 int wilc_wlan_cfg_set_wid(u8 *frame, u32 offset, u16 id, u8 *buf, int size);
 int wilc_wlan_cfg_get_wid(u8 *frame, u32 offset, u16 id);
--- linux-6.6.51/drivers/net/wireless/microchip/wilc1000/wlan_if.h	2024-12-05 13:07:51.233690900 +0900
+++ linux4microchip-fpga-2024.09/drivers/net/wireless/microchip/wilc1000/wlan_if.h	2024-12-04 16:41:31.561526500 +0900
@@ -8,6 +8,7 @@
 #define WILC_WLAN_IF_H
 
 #include <linux/netdevice.h>
+#include "debugfs.h"
 #include "fw.h"
 
 #define WILC_MAX_ASSOC_RESP_FRAME_SIZE 512
@@ -17,6 +18,7 @@
  *      Wlan Configuration ID
  *
  ********************************************/
+#define	FW_WILC3000_BLE		"mchp/wilc3000_ble_firmware.bin"
 
 enum bss_types {
 	WILC_FW_BSS_TYPE_INFRA = 0,
@@ -37,6 +39,10 @@
 	WILC_FW_PREAMBLE_AUTO = 2,	/* Auto Preamble Selection */
 };
 
+#define DEV_WIFI	0
+#define DEV_BT		1
+#define DEV_MAX		2
+
 enum {
 	WILC_FW_PASSIVE_SCAN = 0,
 	WILC_FW_ACTIVE_SCAN = 1,
@@ -191,6 +197,14 @@
 	WILC_FW_AUTH_REQ_IDX = 2
 };
 
+enum {
+    WILC_FW_PRINT_LVL_ERROR   = 1,
+    WILC_FW_PRINT_LVL_DEBUG   = 2,
+    WILC_FW_PRINT_LVL_INFO    = 3,
+    WILC_FW_PRINT_LVL_FUN_PT  = 4,
+    WILC_FW_PRINT_LVL_MAX,
+};
+
 enum wid_type {
 	WID_CHAR		= 0,
 	WID_SHORT		= 1,
@@ -200,6 +214,13 @@
 	WID_BIN			= 5,
 };
 
+enum {
+	ANTENNA1		= 0,
+	ANTENNA2		= 1,
+	DIVERSITY		= 2,
+	NUM_ANT_MODE
+};
+
 struct wid {
 	u16 id;
 	enum wid_type type;
@@ -670,8 +691,10 @@
 	WID_TX_POWER			= 0x00CE,
 	WID_WOWLAN_TRIGGER		= 0X00CF,
 	WID_SET_MFP                     = 0x00D0,
+	WID_USE_PRIORITY_EAPOL		= 0x00D1,
 
 	WID_DEFAULT_MGMT_KEY_ID		= 0x00D2,
+	WID_FW_PRINT_LEVEL			= 0x0216,
 	/*  EMAC Short WID list */
 	/*  RTS Threshold */
 	/*
@@ -805,7 +828,9 @@
 	WID_ADD_BEACON			= 0x408a,
 
 	WID_SETUP_MULTICAST_FILTER	= 0x408b,
+	WID_ANTENNA_SELECTION		= 0x408c,
 	WID_EXTERNAL_AUTH_PARAM		= 0x408d,
+
 	/* Miscellaneous WIDs */
 	WID_ALL				= 0x7FFE,
 	WID_MAX				= 0xFFFF
