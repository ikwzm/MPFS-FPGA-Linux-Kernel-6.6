--- linux-6.6.51/Documentation/devicetree/bindings/soc/microchip/atmel,at91rm9200-tcb.yaml	2024-12-05 13:07:31.694455500 +0900
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/soc/microchip/atmel,at91rm9200-tcb.yaml	2024-12-04 16:41:11.056124600 +0900
@@ -20,6 +20,7 @@
           - atmel,at91rm9200-tcb
           - atmel,at91sam9x5-tcb
           - atmel,sama5d2-tcb
+          - microchip,sam9x60-tcb
       - const: simple-mfd
       - const: syscon
 
--- /dev/null
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/soc/microchip/microchip,mpfs-control-scb.yaml	2024-12-04 16:41:11.056124600 +0900
@@ -0,0 +1,49 @@
+# SPDX-License-Identifier: GPL-2.0-only OR BSD-2-Clause
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/soc/microchip/microchip,mpfs-control-scb.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Microchip PolarFire SoC System Controller Bus (SCB) Control Register region
+
+maintainers:
+  - Conor Dooley <conor.dooley@microchip.com>
+
+description:
+  An assortment of system controller related registers, including voltage and
+  temperature sensors and the status/control registers for the system
+  controller's mailbox.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: microchip,pic64gx-control-scb
+          - const: microchip,mpfs-control-scb
+          - const: syscon
+          - const: simple-mfd
+      - items:
+          - const: microchip,mpfs-control-scb
+          - const: syscon
+          - const: simple-mfd
+  reg:
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+
+additionalProperties: false
+
+examples:
+  - |
+    soc {
+      #address-cells = <1>;
+      #size-cells = <1>;
+
+      syscon@37020000 {
+        compatible = "microchip,mpfs-control-scb", "syscon", "simple-mfd";
+        reg = <0x37020000 0x100>;
+      };
+    };
+
--- /dev/null
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/soc/microchip/microchip,mpfs-mss-top-sysreg.yaml	2024-12-04 16:41:11.056124600 +0900
@@ -0,0 +1,71 @@
+# SPDX-License-Identifier: GPL-2.0-only OR BSD-2-Clause
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/soc/microchip/microchip,mpfs-mss-top-sysreg.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Microchip PolarFire SoC Microprocessor Subsystem (MSS) sysreg Register region
+
+maintainers:
+  - Conor Dooley <conor.dooley@microchip.com>
+
+description:
+  An wide assortment of registers that control elements of the MSS on PolarFire
+  SoC, including pinmuxing, resets and clocks among others.
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - const: microchip,pic64gx-mss-top-sysreg
+          - const: microchip,mpfs-mss-top-sysreg
+          - const: syscon
+          - const: simple-mfd
+      - items:
+          - const: microchip,mpfs-mss-top-sysreg
+          - const: syscon
+          - const: simple-mfd
+
+  reg:
+    maxItems: 1
+
+  '#reset-cells':
+    description: |
+      The AHB/AXI peripherals on the PolarFire SoC have reset support, so
+      from CLK_ENVM to CLK_CFM. The reset consumer should specify the
+      desired peripheral via the clock ID in its "resets" phandle cell.
+      See include/dt-bindings/clock/microchip,mpfs-clock.h for the full list
+      of PolarFire clock/reset IDs.
+    const: 1
+
+  '#address-cells':
+    const: 1
+
+  '#size-cells':
+    const: 1
+
+  interrupt-controller@54:
+    type: object
+    description: |
+      This interrupt controller is the GPIO interrupt multiplexer.
+
+required:
+  - compatible
+  - reg
+  - '#reset-cells'
+
+additionalProperties: false
+
+examples:
+  - |
+    soc {
+      #address-cells = <1>;
+      #size-cells = <1>;
+
+      syscon@20002000 {
+        compatible = "microchip,mpfs-mss-top-sysreg", "syscon", "simple-mfd";
+        reg = <0x20002000 0x1000>;
+        #reset-cells = <1>;
+      };
+    };
+
--- linux-6.6.51/Documentation/devicetree/bindings/soc/microchip/microchip,mpfs-sys-controller.yaml	2024-12-05 13:07:31.694455500 +0900
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/soc/microchip/microchip,mpfs-sys-controller.yaml	2024-12-04 16:41:11.057121800 +0900
@@ -24,7 +24,19 @@
     maxItems: 1
 
   compatible:
-    const: microchip,mpfs-sys-controller
+    enum:
+      - microchip,mpfs-sys-controller
+      - microchip,pic64gx-sys-controller
+
+  microchip,bitstream-flash:
+    $ref: /schemas/types.yaml#/definitions/phandle
+    description:
+      The SPI flash connected to the system controller's QSPI controller.
+      The system controller may retrieve FPGA bitstreams from this flash to
+      perform In-Application Programming (IAP) or during device initialisation
+      for Auto Update. The MSS and system controller have separate QSPI
+      controllers and this flash is connected to both. Software running in the
+      MSS can write bitstreams to the flash.
 
 required:
   - compatible
--- linux-6.6.51/drivers/soc/Kconfig	2024-12-05 13:07:53.413858600 +0900
+++ linux4microchip-fpga-2024.09/drivers/soc/Kconfig	2024-12-04 16:41:33.664899100 +0900
@@ -23,7 +23,6 @@
 source "drivers/soc/renesas/Kconfig"
 source "drivers/soc/rockchip/Kconfig"
 source "drivers/soc/samsung/Kconfig"
-source "drivers/soc/sifive/Kconfig"
 source "drivers/soc/starfive/Kconfig"
 source "drivers/soc/sunxi/Kconfig"
 source "drivers/soc/tegra/Kconfig"
--- linux-6.6.51/drivers/soc/Makefile	2024-12-05 13:07:53.414855900 +0900
+++ linux4microchip-fpga-2024.09/drivers/soc/Makefile	2024-12-04 16:41:33.665896400 +0900
@@ -28,7 +28,6 @@
 obj-y				+= renesas/
 obj-y				+= rockchip/
 obj-$(CONFIG_SOC_SAMSUNG)	+= samsung/
-obj-y				+= sifive/
 obj-y				+= sunxi/
 obj-$(CONFIG_ARCH_TEGRA)	+= tegra/
 obj-y				+= ti/
--- linux-6.6.51/drivers/soc/atmel/soc.c	2024-12-05 13:07:53.424829300 +0900
+++ linux4microchip-fpga-2024.09/drivers/soc/atmel/soc.c	2024-12-04 16:41:33.676867300 +0900
@@ -101,6 +101,29 @@
 		 AT91_CIDR_VERSION_MASK, SAM9X60_D6K_EXID_MATCH,
 		 "sam9x60 8MiB SDRAM SiP", "sam9x60"),
 #endif
+#ifdef CONFIG_SOC_SAM9X7
+	AT91_SOC(SAM9X7_CIDR_MATCH, AT91_CIDR_MATCH_MASK,
+		 AT91_CIDR_VERSION_MASK, SAM9X75_EXID_MATCH,
+		 "sam9x75", "sam9x7"),
+	AT91_SOC(SAM9X7_CIDR_MATCH, AT91_CIDR_MATCH_MASK,
+		 AT91_CIDR_VERSION_MASK, SAM9X72_EXID_MATCH,
+		 "sam9x72", "sam9x7"),
+	AT91_SOC(SAM9X7_CIDR_MATCH, AT91_CIDR_MATCH_MASK,
+		 AT91_CIDR_VERSION_MASK, SAM9X70_EXID_MATCH,
+		 "sam9x70", "sam9x7"),
+	AT91_SOC(SAM9X7_CIDR_MATCH, SAM9X75_D1G_EXID_MATCH,
+		 AT91_CIDR_VERSION_MASK, SAM9X75_EXID_MATCH,
+		 "sam9x75 1Gb DDR3L SiP ", "sam9x7"),
+	AT91_SOC(SAM9X7_CIDR_MATCH, SAM9X75_D5M_EXID_MATCH,
+		 AT91_CIDR_VERSION_MASK, SAM9X75_EXID_MATCH,
+		 "sam9x75 512Mb DDR2 SiP", "sam9x7"),
+	AT91_SOC(SAM9X7_CIDR_MATCH, SAM9X75_D1M_EXID_MATCH,
+		 AT91_CIDR_VERSION_MASK, SAM9X75_EXID_MATCH,
+		 "sam9x75 128Mb DDR2 SiP", "sam9x7"),
+	AT91_SOC(SAM9X7_CIDR_MATCH, SAM9X75_D2G_EXID_MATCH,
+		 AT91_CIDR_VERSION_MASK, SAM9X75_EXID_MATCH,
+		 "sam9x75 2Gb DDR3L SiP", "sam9x7"),
+#endif
 #ifdef CONFIG_SOC_SAMA5
 	AT91_SOC(SAMA5D2_CIDR_MATCH, AT91_CIDR_MATCH_MASK,
 		 AT91_CIDR_VERSION_MASK, SAMA5D21CU_EXID_MATCH,
@@ -223,6 +246,9 @@
 		 "samv70q19", "samv7"),
 #endif
 #ifdef CONFIG_SOC_SAMA7
+	AT91_SOC(SAMA7D65_CIDR_MATCH, AT91_CIDR_MASK_SAMA7G5,
+		 AT91_CIDR_VERSION_MASK_SAMA7G5, SAMA7D65_EXID_MATCH,
+		 "sama7d65", "sama7d6"),
 	AT91_SOC(SAMA7G5_CIDR_MATCH, AT91_CIDR_MATCH_MASK,
 		 AT91_CIDR_VERSION_MASK_SAMA7G5, SAMA7G51_EXID_MATCH,
 		 "sama7g51", "sama7g5"),
@@ -282,6 +308,7 @@
 	void __iomem *regs;
 	static const struct of_device_id chipids[] = {
 		{ .compatible = "atmel,sama5d2-chipid" },
+		{ .compatible = "microchip,sama7d65-chipid"},
 		{ .compatible = "microchip,sama7g5-chipid" },
 		{ },
 	};
@@ -370,6 +397,7 @@
 	{ .compatible = "atmel,at91sam9", },
 	{ .compatible = "atmel,sama5", },
 	{ .compatible = "atmel,samv7", },
+	{ .compatible = "microchip,sama7d65",},
 	{ .compatible = "microchip,sama7g5", },
 	{ }
 };
--- linux-6.6.51/drivers/soc/atmel/soc.h	2024-12-05 13:07:53.424829300 +0900
+++ linux4microchip-fpga-2024.09/drivers/soc/atmel/soc.h	2024-12-04 16:41:33.676867300 +0900
@@ -44,7 +44,9 @@
 #define AT91SAM9X5_CIDR_MATCH		0x019a05a0
 #define AT91SAM9N12_CIDR_MATCH		0x019a07a0
 #define SAM9X60_CIDR_MATCH		0x019b35a0
+#define SAMA7D65_CIDR_MATCH		0x00262100
 #define SAMA7G5_CIDR_MATCH		0x00162100
+#define SAM9X7_CIDR_MATCH		0x09750020
 
 #define AT91SAM9M11_EXID_MATCH		0x00000001
 #define AT91SAM9M10_EXID_MATCH		0x00000002
@@ -66,6 +68,8 @@
 #define SAM9X60_D1G_EXID_MATCH		0x00000010
 #define SAM9X60_D6K_EXID_MATCH		0x00000011
 
+#define SAMA7D65_EXID_MATCH		0x00000080
+
 #define SAMA7G51_EXID_MATCH		0x3
 #define SAMA7G52_EXID_MATCH		0x2
 #define SAMA7G53_EXID_MATCH		0x1
@@ -74,6 +78,14 @@
 #define SAMA7G54_D2G_EXID_MATCH		0x00000020
 #define SAMA7G54_D4G_EXID_MATCH		0x00000028
 
+#define SAM9X75_EXID_MATCH		0x00000000
+#define SAM9X72_EXID_MATCH		0x00000004
+#define SAM9X70_EXID_MATCH		0x00000005
+#define SAM9X75_D1G_EXID_MATCH		0x00000001
+#define SAM9X75_D5M_EXID_MATCH		0x00000002
+#define SAM9X75_D1M_EXID_MATCH		0x00000003
+#define SAM9X75_D2G_EXID_MATCH		0x00000006
+
 #define AT91SAM9XE128_CIDR_MATCH	0x329973a0
 #define AT91SAM9XE256_CIDR_MATCH	0x329a93a0
 #define AT91SAM9XE512_CIDR_MATCH	0x329aa3a0
--- linux-6.6.51/drivers/soc/microchip/Kconfig	2024-12-05 13:07:53.466717200 +0900
+++ linux4microchip-fpga-2024.09/drivers/soc/microchip/Kconfig	2024-12-04 16:41:33.721747000 +0900
@@ -1,6 +1,7 @@
 config POLARFIRE_SOC_SYS_CTRL
 	tristate "Microchip PolarFire SoC (MPFS) system controller support"
 	depends on POLARFIRE_SOC_MAILBOX
+	depends on MTD
 	help
 	  This driver adds support for the PolarFire SoC (MPFS) system controller.
 
@@ -8,3 +9,30 @@
 	  module will be called mpfs_system_controller.
 
 	  If unsure, say N.
+
+config POLARFIRE_SOC_GENERIC_SERVICE
+	tristate "PFSOC FPGA generic system services"
+	depends on POLARFIRE_SOC_SYS_CTRL
+	help
+	  The PolarFire SoC system controller is communicated with via a mailbox.
+	  This driver implemtents the services provided by the system controller
+	  which do not belong in a specific subsystem, such as reading the fpga
+	  device certificate, all of which follow the same format:
+	    - a command + optional payload sent to the sys controller
+	    - a status + a payload returned to Linux
+
+	  To compile this driver as a module, choose M here. the
+	  module will be called mpfs_generic_service.
+
+	  If unsure, say N.
+
+config POLARFIRE_SOC_SYSCONS
+	bool "PolarFire SoC (MPFS) syscon drivers"
+	default y
+	depends on SOC_MICROCHIP_POLARFIRE
+	select MFD_CORE
+	help
+	  Filler text
+
+	  If unsure, say N.
+
--- linux-6.6.51/drivers/soc/microchip/Makefile	2024-12-05 13:07:53.467714500 +0900
+++ linux4microchip-fpga-2024.09/drivers/soc/microchip/Makefile	2024-12-04 16:41:33.722744300 +0900
@@ -1 +1,3 @@
 obj-$(CONFIG_POLARFIRE_SOC_SYS_CTRL)	+= mpfs-sys-controller.o
+obj-$(CONFIG_POLARFIRE_SOC_GENERIC_SERVICE)	+= mpfs-generic-service.o
+obj-$(CONFIG_POLARFIRE_SOC_SYSCONS)	+= mpfs-control-scb.o mpfs-mss-top-sysreg.o
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/soc/microchip/mpfs-control-scb.c	2024-12-04 16:41:33.722744300 +0900
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+
+static const struct mfd_cell mpfs_control_scb_devs[] = {
+	{ .name = "mpfs-tvs", },
+};
+
+static int mpfs_control_scb_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	ret = mfd_add_devices(dev, PLATFORM_DEVID_NONE, mpfs_control_scb_devs,
+				   1, NULL, 0, NULL);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static const struct of_device_id mpfs_control_scb_of_match[] = {
+	{.compatible = "microchip,mpfs-control-scb", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, mpfs_control_scb_of_match);
+
+static struct platform_driver mpfs_control_scb_driver = {
+	.driver = {
+		.name = "mpfs-control-scb",
+		.of_match_table = mpfs_control_scb_of_match,
+	},
+	.probe = mpfs_control_scb_probe,
+};
+module_platform_driver(mpfs_control_scb_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Conor Dooley <conor.dooley@microchip.com>");
+MODULE_DESCRIPTION("PolarFire SoC control scb driver");
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/soc/microchip/mpfs-generic-service.c	2024-12-04 16:41:33.722744300 +0900
@@ -0,0 +1,218 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Microchip PolarFire SoC (MPFS) generic service driver
+ *
+ * Copyright (c) 2020-2022 Microchip Corporation. All rights reserved.
+ *
+ * Author: Conor Dooley <conor.dooley@microchip.com>
+ *
+ */
+
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/of_platform.h>
+#include <soc/microchip/mpfs.h>
+
+static DEFINE_MUTEX(mpfs_generic_service_mutex);
+
+#define MPFS_MAX_PAYLOAD	4096U
+#define MPFS_MIN_PAYLOAD	9u
+
+struct mpfs_generic_service_priv {
+	struct mpfs_sys_controller *sys_controller;
+	struct mpfs_mss_response *response;
+	struct device *dev;
+	u8 *response_msg;
+};
+
+struct mpfs_generic_service_priv *generic_service_priv;
+
+static inline void mpfs_generic_service_free_message_structs(void)
+{
+	devm_kfree(generic_service_priv->dev, generic_service_priv->response->resp_msg);
+	devm_kfree(generic_service_priv->dev, generic_service_priv->response);
+	generic_service_priv->response = NULL;
+}
+
+static ssize_t mpfs_generic_service_write(struct file *filep, const char __user *userbuf,
+					  size_t len, loff_t *offset)
+{
+	struct mpfs_mss_response *response;
+	u8 *cmd_data;
+	struct mpfs_mss_msg msg;
+	int ret;
+
+	if (len < MPFS_MIN_PAYLOAD || len > MPFS_MAX_PAYLOAD)
+		return -EINVAL;
+
+	cmd_data = devm_kmalloc(generic_service_priv->dev, len, GFP_KERNEL);
+	if (!cmd_data)
+		return -ENOMEM;
+
+	ret = copy_from_user(cmd_data, userbuf, len);
+	if (ret) {
+		devm_kfree(generic_service_priv->dev, cmd_data);
+		return -EFAULT;
+	}
+
+	if (generic_service_priv->response)
+		mpfs_generic_service_free_message_structs();
+
+	response = devm_kmalloc(generic_service_priv->dev, sizeof(*response), GFP_KERNEL);
+	if (!response) {
+		devm_kfree(generic_service_priv->dev, cmd_data);
+		return -ENOMEM;
+	}
+
+	response->resp_status = 0U;
+	response->resp_size = ALIGN(*(u16 *)(cmd_data + 3), (4U));
+	response->resp_msg = devm_kzalloc(generic_service_priv->dev,
+					  response->resp_size * sizeof(u8), GFP_KERNEL);
+	if (!response->resp_msg) {
+		devm_kfree(generic_service_priv->dev, cmd_data);
+		devm_kfree(generic_service_priv->dev, response);
+		return -ENOMEM;
+	}
+
+	generic_service_priv->response = response;
+
+	msg = (struct mpfs_mss_msg) {
+		.cmd_opcode = *(cmd_data),
+		.cmd_data_size = *(u16 *)(cmd_data + 1),
+		.response = generic_service_priv->response,
+		.cmd_data = cmd_data + MPFS_MIN_PAYLOAD,
+		.mbox_offset = *(u16 *)(cmd_data + 5),
+		.resp_offset = *(u16 *)(cmd_data + 7)
+	};
+
+	if (msg.cmd_data_size != len - MPFS_MIN_PAYLOAD) {
+		devm_kfree(generic_service_priv->dev, cmd_data);
+		mpfs_generic_service_free_message_structs();
+		return -EINVAL;
+	}
+
+	ret = mpfs_blocking_transaction(generic_service_priv->sys_controller, &msg);
+	devm_kfree(generic_service_priv->dev, cmd_data);
+	if (ret) {
+		mpfs_generic_service_free_message_structs();
+		return -EIO;
+	}
+
+	return len;
+}
+
+static ssize_t mpfs_generic_service_read(struct file *filp, char __user *userbuf,
+					 size_t len, loff_t *f_pos)
+{
+	u8 *buffer, *response_msg;
+	int ret;
+
+	if (!generic_service_priv->response)
+		return -ENOMSG;
+
+	response_msg = (u8 *)generic_service_priv->response->resp_msg;
+	buffer = devm_kmalloc(generic_service_priv->dev,
+			      generic_service_priv->response->resp_size + 1, GFP_KERNEL);
+
+	if (!buffer) {
+		mpfs_generic_service_free_message_structs();
+		return -ENOMEM;
+	}
+
+	*buffer = generic_service_priv->response->resp_status;
+
+	memcpy(buffer + 1, response_msg, generic_service_priv->response->resp_size);
+
+	ret = simple_read_from_buffer(userbuf, len, f_pos, buffer,
+				      generic_service_priv->response->resp_size + 1);
+
+	mpfs_generic_service_free_message_structs();
+	devm_kfree(generic_service_priv->dev, buffer);
+
+	return ret;
+}
+
+static int mpfs_generic_service_open(struct inode *inode, struct file *filp)
+{
+	if (!mutex_trylock(&mpfs_generic_service_mutex)) {
+		pr_debug("Device Busy\n");
+		return -EBUSY;
+	}
+	return 0;
+}
+
+static int mpfs_generic_service_release(struct inode *inode, struct file *filp)
+{
+	mutex_unlock(&mpfs_generic_service_mutex);
+	return 0;
+}
+
+static const struct file_operations mpfs_generic_service_fops = {
+	.owner = THIS_MODULE,
+	.read = mpfs_generic_service_read,
+	.open = mpfs_generic_service_open,
+	.write = mpfs_generic_service_write,
+	.release = mpfs_generic_service_release
+};
+
+static struct miscdevice mpfs_generic_service_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "mpfs_generic_service",
+	.fops = &mpfs_generic_service_fops
+};
+
+static int mpfs_generic_service_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+
+	generic_service_priv =
+		devm_kzalloc(dev, sizeof(*generic_service_priv), GFP_KERNEL);
+	if (!generic_service_priv)
+		return -ENOMEM;
+
+	generic_service_priv->sys_controller =  mpfs_sys_controller_get(&pdev->dev);
+	if (IS_ERR(generic_service_priv->sys_controller))
+		return dev_err_probe(dev, PTR_ERR(generic_service_priv->sys_controller),
+				     "Could not register as a sub device of the system controller\n");
+
+	generic_service_priv->dev = dev;
+
+	platform_set_drvdata(pdev, generic_service_priv);
+	misc_register(&mpfs_generic_service_dev);
+	/*
+	 * This driver exposes all the system controller functions to userspace
+	 * without performing any validation. Additionally, while access to the
+	 * system controller itself is serialised, services requested using this
+	 * driver from userspace may interfere with kernel's own use of the
+	 * same services.
+	 */
+	dev_warn(&pdev->dev,
+		 "Registered MPFS generic service - FOR DEVELOPMENT ONLY, DO NOT USE IN PRODUCTION\n");
+
+	return 0;
+}
+
+static const struct of_device_id mpfs_generic_service_of_match[] = {
+	{
+		.compatible = "microchip,mpfs-generic-service",
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, mpfs_generic_service_of_match);
+
+static struct platform_driver mpfs_generic_service_driver = {
+	.driver = {
+	.name = "mpfs-generic-service",
+	.of_match_table = mpfs_generic_service_of_match,
+	},
+	.probe = mpfs_generic_service_probe,
+};
+module_platform_driver(mpfs_generic_service_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Conor Dooley <conor.dooley@microchip.com>");
+MODULE_DESCRIPTION("PolarFire SoC (MPFS) generic service driver");
--- /dev/null
+++ linux4microchip-fpga-2024.09/drivers/soc/microchip/mpfs-mss-top-sysreg.c	2024-12-04 16:41:33.723741700 +0900
@@ -0,0 +1,47 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+
+static const struct mfd_cell mpfs_mss_top_sysreg_devs[] = {
+	{ .name = "mpfs-reset", },
+};
+
+static int mpfs_mss_top_sysreg_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	ret = mfd_add_devices(dev, PLATFORM_DEVID_NONE, mpfs_mss_top_sysreg_devs,
+				   1, NULL, 0, NULL);
+	if (ret)
+		return ret;
+
+	if (devm_of_platform_populate(dev))
+		dev_err(dev, "Error populating children\n");
+
+	return 0;
+}
+
+static const struct of_device_id mpfs_mss_top_sysreg_of_match[] = {
+	{.compatible = "microchip,mpfs-mss-top-sysreg", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, mpfs_mss_top_sysreg_of_match);
+
+static struct platform_driver mpfs_mss_top_sysreg_driver = {
+	.driver = {
+		.name = "mpfs-mss-top-sysreg",
+		.of_match_table = mpfs_mss_top_sysreg_of_match,
+	},
+	.probe = mpfs_mss_top_sysreg_probe,
+};
+module_platform_driver(mpfs_mss_top_sysreg_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Conor Dooley <conor.dooley@microchip.com>");
+MODULE_DESCRIPTION("PolarFire SoC mss top sysreg driver");
--- linux-6.6.51/drivers/soc/microchip/mpfs-sys-controller.c	2024-12-05 13:07:53.467714500 +0900
+++ linux4microchip-fpga-2024.09/drivers/soc/microchip/mpfs-sys-controller.c	2024-12-04 16:41:33.724739000 +0900
@@ -12,6 +12,8 @@
 #include <linux/kref.h>
 #include <linux/module.h>
 #include <linux/jiffies.h>
+#include <linux/mtd/mtd.h>
+#include <linux/spi/spi.h>
 #include <linux/interrupt.h>
 #include <linux/of.h>
 #include <linux/mailbox_client.h>
@@ -30,9 +32,15 @@
 	struct mbox_client client;
 	struct mbox_chan *chan;
 	struct completion c;
+	struct mtd_info *flash;
 	struct kref consumers;
 };
 
+struct mpfs_syscon_config {
+	unsigned int nb_subdevs;
+	struct platform_device *subdevs;
+};
+
 int mpfs_blocking_transaction(struct mpfs_sys_controller *sys_controller, struct mpfs_mss_msg *msg)
 {
 	unsigned long timeout = msecs_to_jiffies(MPFS_SYS_CTRL_TIMEOUT_MS);
@@ -63,7 +71,9 @@
 	 */
 	if (!wait_for_completion_timeout(&sys_controller->c, timeout)) {
 		ret = -EBADMSG;
-		dev_warn(sys_controller->client.dev, "MPFS sys controller service failed\n");
+		dev_warn(sys_controller->client.dev,
+			 "MPFS sys controller service failed with status: %d\n",
+			 msg->response->resp_status);
 	} else {
 		ret = 0;
 	}
@@ -99,27 +109,34 @@
 	kref_put(&sys_controller->consumers, mpfs_sys_controller_delete);
 }
 
-static struct platform_device subdevs[] = {
-	{
-		.name		= "mpfs-rng",
-		.id		= -1,
-	},
-	{
-		.name		= "mpfs-generic-service",
-		.id		= -1,
-	}
-};
+struct mtd_info *mpfs_sys_controller_get_flash(struct mpfs_sys_controller *mpfs_client)
+{
+	return mpfs_client->flash;
+}
+EXPORT_SYMBOL(mpfs_sys_controller_get_flash);
 
 static int mpfs_sys_controller_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct mpfs_sys_controller *sys_controller;
+	struct mpfs_syscon_config *of_data;
+	struct device_node *np;
 	int i, ret;
 
 	sys_controller = kzalloc(sizeof(*sys_controller), GFP_KERNEL);
 	if (!sys_controller)
 		return -ENOMEM;
 
+	np = of_parse_phandle(dev->of_node, "microchip,bitstream-flash", 0);
+	if (!np)
+		goto no_flash;
+
+	sys_controller->flash = of_get_mtd_device_by_node(np);
+	of_node_put(np);
+	if (IS_ERR(sys_controller->flash))
+		return dev_err_probe(dev, PTR_ERR(sys_controller->flash), "Failed to get flash\n");
+
+no_flash:
 	sys_controller->client.dev = dev;
 	sys_controller->client.rx_callback = mpfs_sys_controller_rx_callback;
 	sys_controller->client.tx_block = 1U;
@@ -138,14 +155,21 @@
 
 	platform_set_drvdata(pdev, sys_controller);
 
-	dev_info(&pdev->dev, "Registered MPFS system controller\n");
+	of_data = (struct mpfs_syscon_config *) device_get_match_data(dev);
+	if (!of_data) {
+		dev_err(dev, "Error getting match data\n");
+		return -EINVAL;
+	}
 
-	for (i = 0; i < ARRAY_SIZE(subdevs); i++) {
-		subdevs[i].dev.parent = dev;
-		if (platform_device_register(&subdevs[i]))
-			dev_warn(dev, "Error registering sub device %s\n", subdevs[i].name);
+	for (i = 0; i < of_data->nb_subdevs; i++) {
+		of_data->subdevs[i].dev.parent = dev;
+		if (platform_device_register(&of_data->subdevs[i]))
+			dev_warn(dev, "Error registering sub device %s\n",
+				 of_data->subdevs[i].name);
 	}
 
+	dev_info(&pdev->dev, "Registered MPFS system controller\n");
+
 	return 0;
 }
 
@@ -158,8 +182,45 @@
 	return 0;
 }
 
+static struct platform_device mpfs_subdevs[] = {
+	{
+		.name		= "mpfs-rng",
+		.id		= -1,
+	},
+	{
+		.name		= "mpfs-generic-service",
+		.id		= -1,
+	},
+	{
+		.name		= "mpfs-auto-update",
+		.id		= -1,
+	},
+};
+
+static struct platform_device pic64gx_subdevs[] = {
+	{
+		.name		= "mpfs-rng",
+		.id		= -1,
+	},
+	{
+		.name		= "mpfs-generic-service",
+		.id		= -1,
+	},
+};
+
+static const struct mpfs_syscon_config mpfs_config = {
+	.nb_subdevs = ARRAY_SIZE(mpfs_subdevs),
+	.subdevs = mpfs_subdevs,
+};
+
+static const struct mpfs_syscon_config pic64gx_config = {
+	.nb_subdevs = ARRAY_SIZE(pic64gx_subdevs),
+	.subdevs = pic64gx_subdevs,
+};
+
 static const struct of_device_id mpfs_sys_controller_of_match[] = {
-	{.compatible = "microchip,mpfs-sys-controller", },
+	{.compatible = "microchip,mpfs-sys-controller", .data = &mpfs_config},
+	{.compatible = "microchip,pic64gx-sys-controller", .data = &pic64gx_config},
 	{},
 };
 MODULE_DEVICE_TABLE(of, mpfs_sys_controller_of_match);
@@ -174,7 +235,6 @@
 		goto err_no_device;
 
 	match = of_match_node(mpfs_sys_controller_of_match,  dev->parent->of_node);
-	of_node_put(dev->parent->of_node);
 	if (!match)
 		goto err_no_device;
 
diff -urN linux-6.6.51/drivers/soc/sifive/Kconfig linux4microchip-fpga-2024.09/drivers/soc/sifive/Kconfig
--- linux-6.6.51/drivers/soc/sifive/Kconfig	2024-12-05 13:07:53.495639800 +0900
+++ linux4microchip-fpga-2024.09/drivers/soc/sifive/Kconfig	1970-01-01 09:00:00.000000000 +0900
@@ -1,10 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-
-if SOC_SIFIVE || SOC_STARFIVE
-
-config SIFIVE_CCACHE
-	bool "Sifive Composable Cache controller"
-	help
-	  Support for the composable cache controller on SiFive platforms.
-
-endif
diff -urN linux-6.6.51/drivers/soc/sifive/Makefile linux4microchip-fpga-2024.09/drivers/soc/sifive/Makefile
--- linux-6.6.51/drivers/soc/sifive/Makefile	2024-12-05 13:07:53.495639800 +0900
+++ linux4microchip-fpga-2024.09/drivers/soc/sifive/Makefile	1970-01-01 09:00:00.000000000 +0900
@@ -1,3 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-
-obj-$(CONFIG_SIFIVE_CCACHE)	+= sifive_ccache.o
diff -urN linux-6.6.51/drivers/soc/sifive/sifive_ccache.c linux4microchip-fpga-2024.09/drivers/soc/sifive/sifive_ccache.c
--- linux-6.6.51/drivers/soc/sifive/sifive_ccache.c	2024-12-05 13:07:53.495639800 +0900
+++ linux4microchip-fpga-2024.09/drivers/soc/sifive/sifive_ccache.c	1970-01-01 09:00:00.000000000 +0900
@@ -1,272 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SiFive composable cache controller Driver
- *
- * Copyright (C) 2018-2022 SiFive, Inc.
- *
- */
-
-#define pr_fmt(fmt) "CCACHE: " fmt
-
-#include <linux/debugfs.h>
-#include <linux/interrupt.h>
-#include <linux/of_irq.h>
-#include <linux/of_address.h>
-#include <linux/device.h>
-#include <linux/bitfield.h>
-#include <asm/cacheinfo.h>
-#include <soc/sifive/sifive_ccache.h>
-
-#define SIFIVE_CCACHE_DIRECCFIX_LOW 0x100
-#define SIFIVE_CCACHE_DIRECCFIX_HIGH 0x104
-#define SIFIVE_CCACHE_DIRECCFIX_COUNT 0x108
-
-#define SIFIVE_CCACHE_DIRECCFAIL_LOW 0x120
-#define SIFIVE_CCACHE_DIRECCFAIL_HIGH 0x124
-#define SIFIVE_CCACHE_DIRECCFAIL_COUNT 0x128
-
-#define SIFIVE_CCACHE_DATECCFIX_LOW 0x140
-#define SIFIVE_CCACHE_DATECCFIX_HIGH 0x144
-#define SIFIVE_CCACHE_DATECCFIX_COUNT 0x148
-
-#define SIFIVE_CCACHE_DATECCFAIL_LOW 0x160
-#define SIFIVE_CCACHE_DATECCFAIL_HIGH 0x164
-#define SIFIVE_CCACHE_DATECCFAIL_COUNT 0x168
-
-#define SIFIVE_CCACHE_CONFIG 0x00
-#define SIFIVE_CCACHE_CONFIG_BANK_MASK GENMASK_ULL(7, 0)
-#define SIFIVE_CCACHE_CONFIG_WAYS_MASK GENMASK_ULL(15, 8)
-#define SIFIVE_CCACHE_CONFIG_SETS_MASK GENMASK_ULL(23, 16)
-#define SIFIVE_CCACHE_CONFIG_BLKS_MASK GENMASK_ULL(31, 24)
-
-#define SIFIVE_CCACHE_WAYENABLE 0x08
-#define SIFIVE_CCACHE_ECCINJECTERR 0x40
-
-#define SIFIVE_CCACHE_MAX_ECCINTR 4
-
-static void __iomem *ccache_base;
-static int g_irq[SIFIVE_CCACHE_MAX_ECCINTR];
-static struct riscv_cacheinfo_ops ccache_cache_ops;
-static int level;
-
-enum {
-	DIR_CORR = 0,
-	DATA_CORR,
-	DATA_UNCORR,
-	DIR_UNCORR,
-};
-
-#ifdef CONFIG_DEBUG_FS
-static struct dentry *sifive_test;
-
-static ssize_t ccache_write(struct file *file, const char __user *data,
-			    size_t count, loff_t *ppos)
-{
-	unsigned int val;
-
-	if (kstrtouint_from_user(data, count, 0, &val))
-		return -EINVAL;
-	if ((val < 0xFF) || (val >= 0x10000 && val < 0x100FF))
-		writel(val, ccache_base + SIFIVE_CCACHE_ECCINJECTERR);
-	else
-		return -EINVAL;
-	return count;
-}
-
-static const struct file_operations ccache_fops = {
-	.owner = THIS_MODULE,
-	.open = simple_open,
-	.write = ccache_write
-};
-
-static void setup_sifive_debug(void)
-{
-	sifive_test = debugfs_create_dir("sifive_ccache_cache", NULL);
-
-	debugfs_create_file("sifive_debug_inject_error", 0200,
-			    sifive_test, NULL, &ccache_fops);
-}
-#endif
-
-static void ccache_config_read(void)
-{
-	u32 cfg;
-
-	cfg = readl(ccache_base + SIFIVE_CCACHE_CONFIG);
-	pr_info("%llu banks, %llu ways, sets/bank=%llu, bytes/block=%llu\n",
-		FIELD_GET(SIFIVE_CCACHE_CONFIG_BANK_MASK, cfg),
-		FIELD_GET(SIFIVE_CCACHE_CONFIG_WAYS_MASK, cfg),
-		BIT_ULL(FIELD_GET(SIFIVE_CCACHE_CONFIG_SETS_MASK, cfg)),
-		BIT_ULL(FIELD_GET(SIFIVE_CCACHE_CONFIG_BLKS_MASK, cfg)));
-
-	cfg = readl(ccache_base + SIFIVE_CCACHE_WAYENABLE);
-	pr_info("Index of the largest way enabled: %u\n", cfg);
-}
-
-static const struct of_device_id sifive_ccache_ids[] = {
-	{ .compatible = "sifive,fu540-c000-ccache" },
-	{ .compatible = "sifive,fu740-c000-ccache" },
-	{ .compatible = "sifive,ccache0" },
-	{ /* end of table */ }
-};
-
-static ATOMIC_NOTIFIER_HEAD(ccache_err_chain);
-
-int register_sifive_ccache_error_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&ccache_err_chain, nb);
-}
-EXPORT_SYMBOL_GPL(register_sifive_ccache_error_notifier);
-
-int unregister_sifive_ccache_error_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&ccache_err_chain, nb);
-}
-EXPORT_SYMBOL_GPL(unregister_sifive_ccache_error_notifier);
-
-static int ccache_largest_wayenabled(void)
-{
-	return readl(ccache_base + SIFIVE_CCACHE_WAYENABLE) & 0xFF;
-}
-
-static ssize_t number_of_ways_enabled_show(struct device *dev,
-					   struct device_attribute *attr,
-					   char *buf)
-{
-	return sprintf(buf, "%u\n", ccache_largest_wayenabled());
-}
-
-static DEVICE_ATTR_RO(number_of_ways_enabled);
-
-static struct attribute *priv_attrs[] = {
-	&dev_attr_number_of_ways_enabled.attr,
-	NULL,
-};
-
-static const struct attribute_group priv_attr_group = {
-	.attrs = priv_attrs,
-};
-
-static const struct attribute_group *ccache_get_priv_group(struct cacheinfo
-							   *this_leaf)
-{
-	/* We want to use private group for composable cache only */
-	if (this_leaf->level == level)
-		return &priv_attr_group;
-	else
-		return NULL;
-}
-
-static irqreturn_t ccache_int_handler(int irq, void *device)
-{
-	unsigned int add_h, add_l;
-
-	if (irq == g_irq[DIR_CORR]) {
-		add_h = readl(ccache_base + SIFIVE_CCACHE_DIRECCFIX_HIGH);
-		add_l = readl(ccache_base + SIFIVE_CCACHE_DIRECCFIX_LOW);
-		pr_err("DirError @ 0x%08X.%08X\n", add_h, add_l);
-		/* Reading this register clears the DirError interrupt sig */
-		readl(ccache_base + SIFIVE_CCACHE_DIRECCFIX_COUNT);
-		atomic_notifier_call_chain(&ccache_err_chain,
-					   SIFIVE_CCACHE_ERR_TYPE_CE,
-					   "DirECCFix");
-	}
-	if (irq == g_irq[DIR_UNCORR]) {
-		add_h = readl(ccache_base + SIFIVE_CCACHE_DIRECCFAIL_HIGH);
-		add_l = readl(ccache_base + SIFIVE_CCACHE_DIRECCFAIL_LOW);
-		/* Reading this register clears the DirFail interrupt sig */
-		readl(ccache_base + SIFIVE_CCACHE_DIRECCFAIL_COUNT);
-		atomic_notifier_call_chain(&ccache_err_chain,
-					   SIFIVE_CCACHE_ERR_TYPE_UE,
-					   "DirECCFail");
-		panic("CCACHE: DirFail @ 0x%08X.%08X\n", add_h, add_l);
-	}
-	if (irq == g_irq[DATA_CORR]) {
-		add_h = readl(ccache_base + SIFIVE_CCACHE_DATECCFIX_HIGH);
-		add_l = readl(ccache_base + SIFIVE_CCACHE_DATECCFIX_LOW);
-		pr_err("DataError @ 0x%08X.%08X\n", add_h, add_l);
-		/* Reading this register clears the DataError interrupt sig */
-		readl(ccache_base + SIFIVE_CCACHE_DATECCFIX_COUNT);
-		atomic_notifier_call_chain(&ccache_err_chain,
-					   SIFIVE_CCACHE_ERR_TYPE_CE,
-					   "DatECCFix");
-	}
-	if (irq == g_irq[DATA_UNCORR]) {
-		add_h = readl(ccache_base + SIFIVE_CCACHE_DATECCFAIL_HIGH);
-		add_l = readl(ccache_base + SIFIVE_CCACHE_DATECCFAIL_LOW);
-		pr_err("DataFail @ 0x%08X.%08X\n", add_h, add_l);
-		/* Reading this register clears the DataFail interrupt sig */
-		readl(ccache_base + SIFIVE_CCACHE_DATECCFAIL_COUNT);
-		atomic_notifier_call_chain(&ccache_err_chain,
-					   SIFIVE_CCACHE_ERR_TYPE_UE,
-					   "DatECCFail");
-	}
-
-	return IRQ_HANDLED;
-}
-
-static int __init sifive_ccache_init(void)
-{
-	struct device_node *np;
-	struct resource res;
-	int i, rc, intr_num;
-
-	np = of_find_matching_node(NULL, sifive_ccache_ids);
-	if (!np)
-		return -ENODEV;
-
-	if (of_address_to_resource(np, 0, &res)) {
-		rc = -ENODEV;
-		goto err_node_put;
-	}
-
-	ccache_base = ioremap(res.start, resource_size(&res));
-	if (!ccache_base) {
-		rc = -ENOMEM;
-		goto err_node_put;
-	}
-
-	if (of_property_read_u32(np, "cache-level", &level)) {
-		rc = -ENOENT;
-		goto err_unmap;
-	}
-
-	intr_num = of_property_count_u32_elems(np, "interrupts");
-	if (!intr_num) {
-		pr_err("No interrupts property\n");
-		rc = -ENODEV;
-		goto err_unmap;
-	}
-
-	for (i = 0; i < intr_num; i++) {
-		g_irq[i] = irq_of_parse_and_map(np, i);
-		rc = request_irq(g_irq[i], ccache_int_handler, 0, "ccache_ecc",
-				 NULL);
-		if (rc) {
-			pr_err("Could not request IRQ %d\n", g_irq[i]);
-			goto err_free_irq;
-		}
-	}
-	of_node_put(np);
-
-	ccache_config_read();
-
-	ccache_cache_ops.get_priv_group = ccache_get_priv_group;
-	riscv_set_cacheinfo_ops(&ccache_cache_ops);
-
-#ifdef CONFIG_DEBUG_FS
-	setup_sifive_debug();
-#endif
-	return 0;
-
-err_free_irq:
-	while (--i >= 0)
-		free_irq(g_irq[i], NULL);
-err_unmap:
-	iounmap(ccache_base);
-err_node_put:
-	of_node_put(np);
-	return rc;
-}
-
-device_initcall(sifive_ccache_init);
--- /dev/null
+++ linux4microchip-fpga-2024.09/include/soc/at91/sama7-sfr.h	2024-12-04 16:41:38.437131600 +0900
@@ -0,0 +1,59 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Microchip SFR (Special Function Registers) registers for SAMA7 family.
+ *
+ * Copyright (C) 2023 Microchip Technology Inc. and its subsidiaries
+ *
+ * Author: Cristian Birsan <cristian.birsan@microchip.com>
+ */
+
+#ifndef _LINUX_MFD_SYSCON_AT91_SAMA7_SFR_H
+#define _LINUX_MFD_SYSCON_AT91_SAMA7_SFR_H
+
+#define SAMA7_SFR_OHCIICR	0x00	/* OHCI INT Configuration Register */
+#define SAMA7_SFR_OHCIISR	0x04	/* OHCI INT Status Register */
+/* 0x08 ~ 0xe3: Reserved */
+#define SAMA7_SFR_WPMR		0xe4	/* Write Protection Mode Register */
+#define SAMA7_SFR_WPSR		0xe4	/* Write Protection Status Register */
+/* 0xec ~ 0x200b: Reserved */
+#define SAMA7_SFR_DEBUG		0x200c	/* Debug Register */
+
+/* 0x2010 ~ 0x2027: Reserved */
+#define SAMA7_SFR_EHCIOHCI	0x2020  /* EHCI OHCI Clock Configuration Reg */
+
+#define SAMA7_SFR_HSS_AXI_QOS	0x2028	/* HSS AXI QOS Register */
+#define SAMA7_SFR_UDDRC		0x202c  /* UDDRC Register */
+#define SAMA7_SFR_CAN_SRAM_SEL	0x2030	/* CAN SRAM Select. Register */
+/* 0x2034 ~ 0x203f: Reserved */
+
+#define SAMA7_SFR_UTMI0		0x2040
+#define SAMA7_SFR_UTMI0R(x)	(SAMA7_SFR_UTMI0 + 4*(x))
+
+#define SAMA7_SFR_UTMI0R0	0x2040	/* UTMI0 Configuration Register */
+#define SAMA7_SFR_UTMI0R1	0x2044	/* UTMI1 Configuration Register */
+#define SAMA7_SFR_UTMI0R2	0x2048	/* UTMI2 Configuration Register */
+
+/* Field definitions */
+#define SAMA7_SFR_OHCIICR_ARIE			BIT(0)
+#define SAMA7_SFR_OHCIICR_APPSTART		BIT(1)
+#define SAMA7_SFR_OHCIICR_USB_SUSP(x)		BIT(8 + (x))
+#define SAMA7_SFR_OHCIICR_USB_SUSPEND		GENMASK(10, 8)
+
+#define SAMA7_SFR_OHCIISR_RIS(x)		BIT(x)
+
+#define SAMA7_SFR_WPMR_WPEN			BIT(0)
+#define SAMA7_SFR_WPMR_KEY			0x53465200 /* SFR in ASCII*/
+#define SAMA7_SFR_WPMR_WPKEY_MASK		GENMASK(31, 8)
+
+#define SAMA7_SFR_WPSR_WPSRC_MASK		GENMASK(23, 8)
+#define SAMA7_SFR_WPSR_WPVS_MASK		BIT(0)
+
+#define SAMA7_SFR_CAN_SRAM_UPPER(x)		BIT(x)
+
+#define SAMA7_SFR_UTMI_RX_VBUS			BIT(25) /* VBUS Valid bit */
+#define SAMA7_SFR_UTMI_RX_TX_PREEM_AMP_TUNE_1X	BIT(23) /* TXPREEMPAMPTUNE 1x */
+#define SAMA7_SFR_UTMI_COMMONON			BIT(3)  /* PLL Common ON bit */
+
+#define SAMA7_SFR_EHCIOHCI_PHYCLK		BIT(1)  /* Alternate PHY Clk */
+
+#endif /* _LINUX_MFD_SYSCON_AT91_SAMA7_SFR_H */
--- linux-6.6.51/include/soc/at91/sama7-sfrbu.h	2024-12-05 13:07:58.098325800 +0900
+++ linux4microchip-fpga-2024.09/include/soc/at91/sama7-sfrbu.h	2024-12-04 16:41:38.438128900 +0900
@@ -18,13 +18,6 @@
 #define		AT91_SFRBU_PSWBU_SOFTSWITCH	(1 << 1)	/* Power switch BU source selection */
 #define		AT91_SFRBU_PSWBU_CTRL		(1 << 0)	/* Power switch BU control */
 
-#define AT91_SFRBU_25LDOCR			(0x0C)		/* SFRBU 2.5V LDO Control Register */
-#define		AT91_SFRBU_25LDOCR_LDOANAKEY	(0x3B6E18 << 8)	/* Specific value mandatory to allow writing of other register bits. */
-#define		AT91_SFRBU_25LDOCR_STATE	(1 << 3)	/* LDOANA Switch On/Off Control */
-#define		AT91_SFRBU_25LDOCR_LP		(1 << 2)	/* LDOANA Low-Power Mode Control */
-#define		AT91_SFRBU_PD_VALUE_MSK		(0x3)
-#define		AT91_SFRBU_25LDOCR_PD_VALUE(v)	((v) & AT91_SFRBU_PD_VALUE_MSK)	/* LDOANA Pull-down value */
-
 #define AT91_FRBU_DDRPWR			(0x10)		/* SFRBU DDR Power Control Register */
 #define		AT91_FRBU_DDRPWR_STATE		(1 << 0)	/* DDR Power Mode State */
 
--- linux-6.6.51/include/soc/microchip/mpfs.h	2024-12-05 13:07:58.106304400 +0900
+++ linux4microchip-fpga-2024.09/include/soc/microchip/mpfs.h	2024-12-04 16:41:38.446107500 +0900
@@ -38,14 +38,16 @@
 
 struct mpfs_sys_controller *mpfs_sys_controller_get(struct device *dev);
 
+struct mtd_info *mpfs_sys_controller_get_flash(struct mpfs_sys_controller *mpfs_client);
+
 #endif /* if IS_ENABLED(CONFIG_POLARFIRE_SOC_SYS_CTRL) */
 
 #if IS_ENABLED(CONFIG_MCHP_CLK_MPFS)
-
-u32 mpfs_reset_read(struct device *dev);
-
-void mpfs_reset_write(struct device *dev, u32 val);
-
+#if IS_ENABLED(CONFIG_RESET_CONTROLLER)
+int mpfs_reset_controller_register(struct device *clk_dev, void __iomem *base);
+#else
+static inline int mpfs_reset_controller_register(struct device *clk_dev, void __iomem *base) { return 0; }
+#endif /* if IS_ENABLED(CONFIG_RESET_CONTROLLER) */
 #endif /* if IS_ENABLED(CONFIG_MCHP_CLK_MPFS) */
 
 #endif /* __SOC_MPFS_H__ */
