--- linux-6.6.51/Documentation/devicetree/bindings/i2c/microchip,corei2c.yaml	2024-12-05 13:07:30.766937000 +0900
+++ linux4microchip-fpga-2024.09/Documentation/devicetree/bindings/i2c/microchip,corei2c.yaml	2024-12-04 16:41:09.924153400 +0900
@@ -16,7 +16,9 @@
   compatible:
     oneOf:
       - items:
-          - const: microchip,mpfs-i2c # Microchip PolarFire SoC compatible SoCs
+          - enum:
+              - microchip,pic64gx-i2c
+              - microchip,mpfs-i2c
           - const: microchip,corei2c-rtl-v7 # Microchip Fabric based i2c IP core
       - const: microchip,corei2c-rtl-v7 # Microchip Fabric based i2c IP core
 
--- linux-6.6.51/drivers/i2c/busses/i2c-at91-core.c	2024-12-05 13:07:46.062526300 +0900
+++ linux4microchip-fpga-2024.09/drivers/i2c/busses/i2c-at91-core.c	2024-12-04 16:41:26.311573100 +0900
@@ -119,6 +119,7 @@
 	.clk_offset = 4,
 	.has_hold_field = true,
 	.has_dig_filtr = true,
+	.has_adv_dig_filtr = true,
 };
 
 static struct at91_twi_pdata sama5d2_config = {
--- linux-6.6.51/drivers/i2c/busses/i2c-at91-master.c	2024-12-05 13:07:46.063523600 +0900
+++ linux4microchip-fpga-2024.09/drivers/i2c/busses/i2c-at91-master.c	2024-12-04 16:41:26.311573100 +0900
@@ -37,7 +37,7 @@
 	/* FIFO should be enabled immediately after the software reset */
 	if (dev->fifo_size)
 		at91_twi_write(dev, AT91_TWI_CR, AT91_TWI_FIFOEN);
-	at91_twi_write(dev, AT91_TWI_CR, AT91_TWI_MSEN);
+	at91_twi_write(dev, AT91_TWI_CR, AT91_TWI_MSDIS);
 	at91_twi_write(dev, AT91_TWI_CR, AT91_TWI_SVDIS);
 	at91_twi_write(dev, AT91_TWI_CWGR, dev->twi_cwgr_reg);
 
@@ -592,7 +592,6 @@
 	if (time_left == 0) {
 		dev->transfer_status |= at91_twi_read(dev, AT91_TWI_SR);
 		dev_err(dev->dev, "controller timed out\n");
-		at91_init_twi_bus(dev);
 		ret = -ETIMEDOUT;
 		goto error;
 	}
@@ -638,16 +637,29 @@
 			       AT91_TWI_THRCLR | AT91_TWI_LOCKCLR);
 	}
 
-	/*
-	 * some faulty I2C slave devices might hold SDA down;
-	 * we can send a bus clear command, hoping that the pins will be
-	 * released
-	 */
-	i2c_recover_bus(&dev->adapter);
-
 	return ret;
 }
 
+static void at91_twi_disable(struct at91_twi_dev *dev)
+{
+	/* return if previous operation is completed */
+	if (!(at91_twi_read(dev, AT91_TWI_SR) & AT91_TWI_TXCOMP)) {
+		/* wait for previous command to complete before disabling the controller */
+		dev_dbg(dev->dev, "wait for command to complete...\n");
+		reinit_completion(&dev->cmd_complete);
+		dev->transfer_status = 0;
+		at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);
+		wait_for_completion_timeout(&dev->cmd_complete, dev->adapter.timeout);
+		if (!(dev->transfer_status & AT91_TWI_TXCOMP)) {
+			dev_dbg(dev->dev, "IP still busy, resetting the controller...\n");
+			at91_init_twi_bus(dev);
+			return;
+		}
+	}
+
+	at91_twi_write(dev, AT91_TWI_CR, AT91_TWI_MSDIS);
+}
+
 static int at91_twi_xfer(struct i2c_adapter *adap, struct i2c_msg *msg, int num)
 {
 	struct at91_twi_dev *dev = i2c_get_adapdata(adap);
@@ -663,6 +675,8 @@
 	if (ret < 0)
 		goto out;
 
+	at91_twi_write(dev, AT91_TWI_CR, AT91_TWI_MSEN);
+
 	if (num == 2) {
 		int internal_address = 0;
 		int i;
@@ -715,7 +729,26 @@
 	ret = at91_do_twi_transfer(dev);
 	i2c_put_dma_safe_msg_buf(dma_buf, m_start, !ret);
 
-	ret = (ret < 0) ? ret : num;
+	if (ret < 0) {
+		/* disable controller before using GPIO recovery */
+		if (!dev->pdata->has_clear_cmd)
+			at91_twi_disable(dev);
+
+		/*
+		 * some faulty I2C slave devices might hold SDA down;
+		 * we can send a bus clear command, hoping that the pins will be
+		 * released
+		 */
+		i2c_recover_bus(&dev->adapter);
+
+		/* disable controller if not disabled before */
+		if (dev->pdata->has_clear_cmd)
+			at91_twi_disable(dev);
+	} else {
+		at91_twi_disable(dev);
+		ret = num;
+	}
+
 out:
 	pm_runtime_mark_last_busy(dev->dev);
 	pm_runtime_put_autosuspend(dev->dev);
--- linux-6.6.51/drivers/i2c/busses/i2c-microchip-corei2c.c	2024-12-05 13:07:46.086462700 +0900
+++ linux4microchip-fpga-2024.09/drivers/i2c/busses/i2c-microchip-corei2c.c	2024-12-04 16:41:26.337502800 +0900
@@ -106,14 +106,18 @@
 	void __iomem *base;
 	struct device *dev;
 	struct clk *i2c_clk;
+	struct i2c_msg *msg_queue;
 	u8 *buf;
 	struct completion msg_complete;
 	struct i2c_adapter adapter;
 	int msg_err;
+	int total_num;
+	int current_num;
 	u32 bus_clk_rate;
 	u32 isr_status;
 	u16 msg_len;
 	u8 addr;
+	bool repeated_send_needed;
 };
 
 static void mchp_corei2c_core_disable(struct mchp_corei2c_dev *idev)
@@ -222,6 +226,35 @@
 	return 0;
 }
 
+static void mchp_corei2c_next_msg(struct mchp_corei2c_dev *idev)
+{
+
+	if (idev->current_num < idev->total_num) {
+		struct i2c_msg *this_msg = ++(idev->msg_queue);
+		u8 ctrl;
+
+		if (idev->current_num < (idev->total_num - 1)) {
+			struct i2c_msg *next_msg = idev->msg_queue;
+
+			idev->repeated_send_needed = next_msg->flags & I2C_M_RD;
+		} else {
+			idev->repeated_send_needed = false;
+		}
+
+		idev->addr = i2c_8bit_addr_from_msg(this_msg);
+		idev->msg_len = this_msg->len;
+		idev->buf = this_msg->buf;
+
+		ctrl = readb(idev->base + CORE_I2C_CTRL);
+		ctrl |= CTRL_STA;
+		writeb(ctrl, idev->base + CORE_I2C_CTRL);
+
+		idev->current_num++;
+	} else {
+		complete(&idev->msg_complete);
+	}
+}
+
 static irqreturn_t mchp_corei2c_handle_isr(struct mchp_corei2c_dev *idev)
 {
 	u32 status = idev->isr_status;
@@ -247,10 +280,15 @@
 		break;
 	case STATUS_M_SLAW_ACK:
 	case STATUS_M_TX_DATA_ACK:
-		if (idev->msg_len > 0)
+		if (idev->msg_len > 0) {
 			mchp_corei2c_fill_tx(idev);
-		else
-			last_byte = true;
+		} else {
+			if (idev->repeated_send_needed) {
+				finished = true;
+			} else {
+				last_byte = true;
+			}
+		}
 		break;
 	case STATUS_M_TX_DATA_NACK:
 	case STATUS_M_SLAR_NACK:
@@ -287,7 +325,7 @@
 		mchp_corei2c_stop(idev);
 
 	if (last_byte || finished)
-		complete(&idev->msg_complete);
+		mchp_corei2c_next_msg(idev);
 
 	return IRQ_HANDLED;
 }
@@ -311,21 +349,47 @@
 	return ret;
 }
 
-static int mchp_corei2c_xfer_msg(struct mchp_corei2c_dev *idev,
-				 struct i2c_msg *msg)
+static int mchp_corei2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
+			     int num)
 {
-	u8 ctrl;
+	struct mchp_corei2c_dev *idev = i2c_get_adapdata(adap);
+	struct i2c_msg *this_msg = msgs;
 	unsigned long time_left;
+	u8 ctrl;
+
+	mchp_corei2c_core_enable(idev);
 
-	idev->addr = i2c_8bit_addr_from_msg(msg);
-	idev->msg_len = msg->len;
-	idev->buf = msg->buf;
+	/*
+	 * The isr controls the flow of a transfer, this info needs to be saved
+	 * to a location that it can access the queue information from.
+	 */
+	idev->repeated_send_needed = false;
+	idev->msg_queue = msgs;
+	idev->total_num = num;
+	idev->current_num = 0;
+
+	/*
+	 * But the first entry to the isr is triggered by the start in this
+	 * function, so the first message needs to be "dequeued".
+	 */
+	idev->addr = i2c_8bit_addr_from_msg(this_msg);
+	idev->msg_len = this_msg->len;
+	idev->buf = this_msg->buf;
 	idev->msg_err = 0;
 
-	reinit_completion(&idev->msg_complete);
+	if (idev->total_num > 1) {
+		struct i2c_msg *next_msg = msgs + 1;
 
-	mchp_corei2c_core_enable(idev);
+		idev->repeated_send_needed = next_msg->flags & I2C_M_RD;
+	}
+
+	idev->current_num++;
 
+	reinit_completion(&idev->msg_complete);
+
+	/*
+	 * Send the first start to pass control to the interrupt handler
+	 */
 	ctrl = readb(idev->base + CORE_I2C_CTRL);
 	ctrl |= CTRL_STA;
 	writeb(ctrl, idev->base + CORE_I2C_CTRL);
@@ -335,20 +399,12 @@
 	if (!time_left)
 		return -ETIMEDOUT;
 
-	return idev->msg_err;
-}
-
-static int mchp_corei2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
-			     int num)
-{
-	struct mchp_corei2c_dev *idev = i2c_get_adapdata(adap);
-	int i, ret;
-
-	for (i = 0; i < num; i++) {
-		ret = mchp_corei2c_xfer_msg(idev, msgs++);
-		if (ret)
-			return ret;
-	}
+	/*
+	 * TODO: fix error handing with new xfer based lifecycle as this will
+	 * only report the last error received after all are sent
+	 */
+	if (idev->msg_err)
+		return idev->msg_err;
 
 	return num;
 }
